/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/constants.ts
var DEFAULT_BASE_FOLDER, DEFAULT_DIRECTORIES, OPTIONAL_DIRECTORIES, COMMAND_IDS, RIBBON_BUTTONS, DATE_FORMATS, DEFAULT_TEMPLATES, REGEX_PATTERNS;
var init_constants = __esm({
  "src/constants.ts"() {
    "use strict";
    DEFAULT_BASE_FOLDER = "LinkPlugin";
    DEFAULT_DIRECTORIES = [
      "journal",
      "templates",
      "workspace",
      "reference"
    ];
    OPTIONAL_DIRECTORIES = [
      "context",
      "schema",
      "Projects"
    ];
    COMMAND_IDS = {
      CREATE_LINKED_NOTE: "create-linked-note",
      REBUILD_DIRECTORY: "rebuild-directory-structure",
      OPEN_TODAY_JOURNAL: "open-today-journal",
      CREATE_TODAY_NOTE: "create-today-note",
      CREATE_FUTURE_NOTE: "create-future-note",
      CREATE_MONTHLY_FOLDERS: "create-monthly-folders",
      EXPAND_SHORTCODE: "expand-shortcode",
      SHOW_LINK_SUGGESTIONS: "show-link-suggestions"
    };
    RIBBON_BUTTONS = {
      TODAY_JOURNAL: {
        icon: "calendar-days",
        title: "Open Today's Journal",
        tooltip: "Open or create today's journal entry"
      },
      CREATE_NOTE: {
        icon: "file-plus",
        title: "Create Linked Note",
        tooltip: "Create a new linked note from selected text"
      },
      MONTHLY_FOLDERS: {
        icon: "folder-plus",
        title: "Create Monthly Folders",
        tooltip: "Create monthly folders for the current year"
      },
      SHORTCODE_HELP: {
        icon: "zap",
        title: "Shortcode Help",
        tooltip: "Show available shortcodes and examples"
      },
      REBUILD_STRUCTURE: {
        icon: "folder-sync",
        title: "Rebuild Directory Structure",
        tooltip: "Rebuild the plugin's directory structure"
      },
      PLUGIN_SETTINGS: {
        icon: "settings",
        title: "Link Plugin Settings",
        tooltip: "Open Link Plugin settings"
      }
    };
    DATE_FORMATS = {
      DEFAULT_JOURNAL: "YYYY-MM-DD dddd",
      ISO_DATE: "YYYY-MM-DD",
      FOLDER_FORMAT: "YYYY/MM"
    };
    DEFAULT_TEMPLATES = {
      JOURNAL: `# {{date}}

## Daily Log

## Tasks
- [ ] 

## Notes

## Reflection

---
Previous: {{previous}}
Next: {{next}}
`,
      NOTE: `---
title: {{title}}
created: {{date}}
source: {{source}}
tags: []
---

# {{title}}

`
    };
    REGEX_PATTERNS = {
      WIKI_LINK: /\[\[(.*?)\]\]/g,
      SHORTCODE: /[\w>+*{}\[\]()]+$/,
      DATE_FILENAME: /\d{4}-\d{2}-\d{2}/,
      INVALID_FILENAME_CHARS: /[\\/:*?"<>|]/g
    };
  }
});

// src/settings/directorySettings.ts
var DirectorySettings;
var init_directorySettings = __esm({
  "src/settings/directorySettings.ts"() {
    "use strict";
    init_constants();
    DirectorySettings = class {
      static getDefaults() {
        return {
          baseFolder: DEFAULT_BASE_FOLDER,
          // Creates all directories under 'LinkPlugin/' by default
          directoryStructure: DEFAULT_DIRECTORIES,
          restrictedDirectories: [],
          documentDirectory: "workspace",
          // Updated to match README structure
          journalRootFolder: "journal"
          // Updated to match README structure
        };
      }
      static validate(settings) {
        const validated = {};
        if (settings.baseFolder && typeof settings.baseFolder === "string") {
          validated.baseFolder = settings.baseFolder.trim();
        }
        if (settings.directoryStructure && Array.isArray(settings.directoryStructure)) {
          validated.directoryStructure = settings.directoryStructure;
        }
        if (settings.restrictedDirectories && Array.isArray(settings.restrictedDirectories)) {
          validated.restrictedDirectories = settings.restrictedDirectories;
        }
        if (settings.documentDirectory && typeof settings.documentDirectory === "string") {
          validated.documentDirectory = settings.documentDirectory;
        }
        if (settings.journalRootFolder && typeof settings.journalRootFolder === "string") {
          validated.journalRootFolder = settings.journalRootFolder;
        }
        return validated;
      }
    };
  }
});

// src/settings/journalSettings.ts
var JournalSettings;
var init_journalSettings = __esm({
  "src/settings/journalSettings.ts"() {
    "use strict";
    init_constants();
    JournalSettings = class {
      static getDefaults() {
        return {
          journalDateFormat: DATE_FORMATS.DEFAULT_JOURNAL,
          journalFolderFormat: DATE_FORMATS.FOLDER_FORMAT,
          journalTemplate: DEFAULT_TEMPLATES.JOURNAL
        };
      }
      static validate(settings) {
        const validated = {};
        if (settings.journalDateFormat && typeof settings.journalDateFormat === "string") {
          validated.journalDateFormat = settings.journalDateFormat;
        }
        if (settings.journalFolderFormat && typeof settings.journalFolderFormat === "string") {
          validated.journalFolderFormat = settings.journalFolderFormat;
        }
        if (settings.journalTemplate && typeof settings.journalTemplate === "string") {
          validated.journalTemplate = settings.journalTemplate;
        }
        return validated;
      }
      static isValidDateFormat(format) {
        try {
          const validTokens = ["YYYY", "MM", "DD", "dddd", "MMM", "MMMM"];
          return validTokens.some((token) => format.includes(token));
        } catch (e) {
          return false;
        }
      }
    };
  }
});

// src/settings/noteSettings.ts
var NoteSettings;
var init_noteSettings = __esm({
  "src/settings/noteSettings.ts"() {
    "use strict";
    init_constants();
    NoteSettings = class {
      static getDefaults() {
        return {
          noteTemplate: DEFAULT_TEMPLATES.NOTE,
          openNewNote: true
        };
      }
      static validate(settings) {
        const validated = {};
        if (settings.noteTemplate && typeof settings.noteTemplate === "string") {
          validated.noteTemplate = settings.noteTemplate;
        }
        if (typeof settings.openNewNote === "boolean") {
          validated.openNewNote = settings.openNewNote;
        }
        return validated;
      }
      static validateTemplate(template) {
        const errors = [];
        const requiredVars = ["{{title}}"];
        const missingVars = requiredVars.filter((varName) => !template.includes(varName));
        if (missingVars.length > 0) {
          errors.push(`Missing required template variables: ${missingVars.join(", ")}`);
        }
        const templateVarPattern = /\{\{[^}]*\}\}/g;
        const matches = template.match(templateVarPattern);
        if (matches) {
          matches.forEach((match) => {
            if (!match.endsWith("}}")) {
              errors.push(`Malformed template variable: ${match}`);
            }
          });
        }
        return {
          isValid: errors.length === 0,
          errors
        };
      }
    };
  }
});

// src/settings/shortcodeSettings.ts
var ShortcodeSettings;
var init_shortcodeSettings = __esm({
  "src/settings/shortcodeSettings.ts"() {
    "use strict";
    ShortcodeSettings = class {
      static getDefaults() {
        return {
          shortcodeEnabled: true,
          shortcodeTriggerKey: "Tab",
          customShortcodes: {}
        };
      }
      static validate(settings) {
        const validated = {};
        if (typeof settings.shortcodeEnabled === "boolean") {
          validated.shortcodeEnabled = settings.shortcodeEnabled;
        }
        if (settings.shortcodeTriggerKey && typeof settings.shortcodeTriggerKey === "string") {
          const validTriggerKeys = ["Tab", "Enter", "Space"];
          if (validTriggerKeys.includes(settings.shortcodeTriggerKey)) {
            validated.shortcodeTriggerKey = settings.shortcodeTriggerKey;
          }
        }
        if (settings.customShortcodes && typeof settings.customShortcodes === "object") {
          const validatedShortcodes = {};
          for (const [key, value] of Object.entries(settings.customShortcodes)) {
            if (typeof key === "string" && typeof value === "string") {
              if (this.isValidShortcodePattern(key) && value.trim().length > 0) {
                validatedShortcodes[key] = value;
              }
            }
          }
          validated.customShortcodes = validatedShortcodes;
        }
        return validated;
      }
      static isValidShortcodePattern(pattern) {
        const validPattern = /^[a-zA-Z0-9_\-+>*{}\[\]()]+$/;
        return validPattern.test(pattern) && pattern.length > 0 && pattern.length <= 100;
      }
      static getBuiltinShortcodes() {
        return {
          "table3x4": "Creates a 3x4 table structure",
          "h2+ul>li*3": "Creates heading with 3-item list",
          "div>h3+ul>li*5": "Creates section with heading and 5 list items",
          "link[url]{text}": "Creates markdown link"
        };
      }
    };
  }
});

// src/settings/generalSettings.ts
var GeneralSettings;
var init_generalSettings = __esm({
  "src/settings/generalSettings.ts"() {
    "use strict";
    GeneralSettings = class {
      static getDefaults() {
        return {
          debugMode: false
        };
      }
      static validate(settings) {
        const validated = {};
        if (typeof settings.debugMode === "boolean") {
          validated.debugMode = settings.debugMode;
        }
        return validated;
      }
      static getDebugInfo() {
        return {
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          language: navigator.language
        };
      }
    };
  }
});

// src/settings/settingsValidator.ts
function validateSettings(settings) {
  const validatedSettings = {
    ...DirectorySettings.getDefaults(),
    ...JournalSettings.getDefaults(),
    ...NoteSettings.getDefaults(),
    ...ShortcodeSettings.getDefaults(),
    ...GeneralSettings.getDefaults()
  };
  const directoryValidation = DirectorySettings.validate(settings);
  const journalValidation = JournalSettings.validate(settings);
  const noteValidation = NoteSettings.validate(settings);
  const shortcodeValidation = ShortcodeSettings.validate(settings);
  const generalValidation = GeneralSettings.validate(settings);
  Object.assign(
    validatedSettings,
    directoryValidation,
    journalValidation,
    noteValidation,
    shortcodeValidation,
    generalValidation
  );
  return validatedSettings;
}
function validateSettingsWithDetails(settings) {
  const errors = [];
  const warnings = [];
  if (settings.noteTemplate) {
    const templateValidation = NoteSettings.validateTemplate(settings.noteTemplate);
    if (!templateValidation.isValid) {
      errors.push(...templateValidation.errors);
    }
  }
  if (settings.journalDateFormat && !JournalSettings.isValidDateFormat(settings.journalDateFormat)) {
    warnings.push("Invalid journal date format provided, using default");
  }
  if (settings.customShortcodes) {
    for (const [pattern, expansion] of Object.entries(settings.customShortcodes)) {
      if (!ShortcodeSettings.isValidShortcodePattern(pattern)) {
        warnings.push(`Invalid shortcode pattern: ${pattern}`);
      }
    }
  }
  if (settings.directoryStructure && settings.directoryStructure.length === 0) {
    warnings.push("Empty directory structure provided, using defaults");
  }
  const validatedSettings = validateSettings(settings);
  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    validatedSettings
  };
}
var init_settingsValidator = __esm({
  "src/settings/settingsValidator.ts"() {
    "use strict";
    init_directorySettings();
    init_journalSettings();
    init_noteSettings();
    init_shortcodeSettings();
    init_generalSettings();
  }
});

// src/settings/defaultSettings.ts
var DEFAULT_SETTINGS;
var init_defaultSettings = __esm({
  "src/settings/defaultSettings.ts"() {
    "use strict";
    init_directorySettings();
    init_journalSettings();
    init_noteSettings();
    init_shortcodeSettings();
    init_generalSettings();
    DEFAULT_SETTINGS = {
      ...DirectorySettings.getDefaults(),
      ...JournalSettings.getDefaults(),
      ...NoteSettings.getDefaults(),
      ...ShortcodeSettings.getDefaults(),
      ...GeneralSettings.getDefaults()
    };
  }
});

// src/settings.ts
var settings_exports = {};
__export(settings_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  DirectorySettings: () => DirectorySettings,
  GeneralSettings: () => GeneralSettings,
  JournalSettings: () => JournalSettings,
  NoteSettings: () => NoteSettings,
  ShortcodeSettings: () => ShortcodeSettings,
  validateSettings: () => validateSettings,
  validateSettingsWithDetails: () => validateSettingsWithDetails
});
var init_settings = __esm({
  "src/settings.ts"() {
    "use strict";
    init_settingsValidator();
    init_directorySettings();
    init_journalSettings();
    init_noteSettings();
    init_shortcodeSettings();
    init_generalSettings();
    init_defaultSettings();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinkPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");
init_settings();

// src/ui/settingsTab.ts
var import_obsidian = require("obsidian");
init_settings();

// src/services/dateService.ts
var DateService = class {
  /**
   * Initialize the date service with Obsidian's moment instance
   * This should be called once when the plugin loads
   */
  static initialize() {
    this.moment = window.moment;
    if (!this.moment) {
      throw new Error("Obsidian moment.js not available");
    }
  }
  /**
   * Get current date/time
   */
  static now() {
    return this.moment();
  }
  /**
   * Create moment from date input
   */
  static from(input) {
    return this.moment(input);
  }
  /**
   * Create moment from date string with format
   */
  static fromFormat(input, format, strict = true) {
    return this.moment(input, format, strict);
  }
  /**
   * Format a date using the specified format
   */
  static format(date, format = "YYYY-MM-DD") {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.format(format);
  }
  /**
   * Get today's date formatted
   */
  static today(format = "YYYY-MM-DD") {
    return this.moment().format(format);
  }
  /**
   * Get current year
   */
  static currentYear() {
    return this.moment().format("YYYY");
  }
  /**
   * Get current month name
   */
  static currentMonth() {
    return this.moment().format("MMMM");
  }
  /**
   * Get start of year for given date
   */
  static startOfYear(date) {
    return (date ? this.moment(date) : this.moment()).startOf("year");
  }
  /**
   * End of year for given date
   */
  static endOfYear(date) {
    return (date ? this.moment(date) : this.moment()).endOf("year");
  }
  /**
   * Start of month for given date
   */
  static startOfMonth(date) {
    return (date ? this.moment(date) : this.moment()).startOf("month");
  }
  /**
   * End of month for given date
   */
  static endOfMonth(date) {
    return (date ? this.moment(date) : this.moment()).endOf("month");
  }
  /**
   * Add time to a date
   */
  static add(date, amount, unit) {
    return this.moment(date).add(amount, unit);
  }
  /**
   * Subtract time from a date
   */
  static subtract(date, amount, unit) {
    return this.moment(date).subtract(amount, unit);
  }
  /**
   * Check if date is valid
   */
  static isValid(date) {
    return this.moment(date).isValid();
  }
  /**
   * Check if date is same or before another date
   */
  static isSameOrBefore(date1, date2) {
    return this.moment(date1).isSameOrBefore(date2);
  }
  /**
   * Extract date from filename using format
   */
  static extractDateFromFilename(filename, format) {
    try {
      const date = this.moment(filename, format, true);
      return date.isValid() ? date : null;
    } catch (error) {
      return null;
    }
  }
  /**
   * Get journal path components for a date
   */
  static getJournalPathComponents(date) {
    const momentDate = date ? this.moment(date) : this.moment();
    const year = momentDate.format("YYYY");
    const monthName = momentDate.format("MMMM");
    return {
      year,
      monthName,
      yearFolder: `y_${year}`,
      monthFolder: monthName
    };
  }
  /**
   * Get formatted filename for journal entry
   */
  static getJournalFilename(date, format = "YYYY-MM-DD dddd") {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.format(format);
  }
  /**
   * Get previous day
   */
  static previousDay(date) {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.subtract(1, "day");
  }
  /**
   * Get next day
   */
  static nextDay(date) {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.add(1, "day");
  }
  /**
   * Create date range iterator
   */
  static *dateRange(startDate, endDate, unit = "day") {
    const current = this.moment(startDate);
    const end = this.moment(endDate);
    while (current.isSameOrBefore(end)) {
      yield this.moment(current);
      current.add(1, unit);
    }
  }
  /**
   * Get monthly folder path for a date
   */
  static getMonthlyFolderPath(basePath, date) {
    const components = this.getJournalPathComponents(date);
    return `${basePath}/${components.yearFolder}/${components.monthFolder}`;
  }
  /**
   * Get full journal file path
   */
  static getJournalFilePath(basePath, date, format = "YYYY-MM-DD dddd") {
    const monthlyPath = this.getMonthlyFolderPath(basePath, date);
    const filename = this.getJournalFilename(date, format);
    return `${monthlyPath}/${filename}.md`;
  }
  /**
   * Validate date format string
   */
  static isValidFormat(format) {
    try {
      const testDate = this.moment();
      testDate.format(format);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Get debug information about the moment instance
   */
  static getDebugInfo() {
    var _a;
    return {
      available: !!this.moment,
      version: ((_a = this.moment) == null ? void 0 : _a.version) || "unknown",
      type: typeof this.moment
    };
  }
};

// src/ui/settingsTab.ts
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Obsidian Link Plugin Settings" });
    const description = containerEl.createEl("p");
    description.innerHTML = `
      Configure your Link Plugin settings below. Settings are organized into categories for easy management.
      <br><strong>Tip:</strong> Hover over setting names for detailed descriptions.
    `;
    description.style.marginBottom = "2em";
    description.style.color = "var(--text-muted)";
    this.addDirectorySettings(containerEl);
    this.addJournalSettings(containerEl);
    this.addNoteSettings(containerEl);
    this.addShortcodeSettings(containerEl);
    this.addGeneralSettings(containerEl);
    this.addAdvancedSettings(containerEl);
  }
  addDirectorySettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F4C1} Directory Structure" });
    const directoryDesc = containerEl.createEl("p");
    directoryDesc.textContent = "Configure how the plugin organizes your files and folders.";
    directoryDesc.style.color = "var(--text-muted)";
    directoryDesc.style.marginBottom = "1em";
    new import_obsidian.Setting(containerEl).setName("Base Folder").setDesc("Root folder for all plugin-created directories. Prevents collision with existing vault structure.").addText((text) => text.setPlaceholder("LinkPlugin").setValue(this.plugin.settings.baseFolder).onChange(async (value) => {
      if (value.trim()) {
        this.plugin.settings.baseFolder = value.trim();
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Workspace Directory").setDesc("Directory name for general notes and documents within the base folder.").addText((text) => text.setPlaceholder("workspace").setValue(this.plugin.settings.documentDirectory).onChange(async (value) => {
      if (value.trim()) {
        this.plugin.settings.documentDirectory = value.trim();
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Journal Directory").setDesc("Directory name for journal entries within the base folder.").addText((text) => text.setPlaceholder("journal").setValue(this.plugin.settings.journalRootFolder).onChange(async (value) => {
      if (value.trim()) {
        this.plugin.settings.journalRootFolder = value.trim();
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Rebuild Directory Structure").setDesc("Recreate the directory structure based on current settings.").addButton((button) => button.setButtonText("Rebuild").setTooltip("Click to rebuild the directory structure").onClick(async () => {
      var _a;
      try {
        await this.plugin.directoryManager.rebuildDirectoryStructure();
        const notice = document.createElement("div");
        notice.textContent = "\u2705 Directory structure rebuilt successfully!";
        notice.style.color = "var(--text-success)";
        notice.style.fontWeight = "bold";
        (_a = button.buttonEl.parentElement) == null ? void 0 : _a.appendChild(notice);
        setTimeout(() => notice.remove(), 3e3);
      } catch (error) {
        this.plugin.errorHandler.handleError(error, "Failed to rebuild directory structure");
      }
    }));
  }
  addJournalSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F4C5} Journal Settings" });
    const journalDesc = containerEl.createEl("p");
    journalDesc.textContent = "Configure date formats and templates for journal entries.";
    journalDesc.style.color = "var(--text-muted)";
    journalDesc.style.marginBottom = "1em";
    new import_obsidian.Setting(containerEl).setName("Journal Date Format").setDesc("Format for journal entry filenames. Uses moment.js format tokens (e.g., YYYY-MM-DD dddd).").addText((text) => text.setPlaceholder("YYYY-MM-DD dddd").setValue(this.plugin.settings.journalDateFormat).onChange(async (value) => {
      if (value.trim()) {
        if (JournalSettings.isValidDateFormat(value)) {
          this.plugin.settings.journalDateFormat = value.trim();
          await this.plugin.saveSettings();
          this.showValidationMessage(text.inputEl, "\u2705 Valid format", "success");
        } else {
          this.showValidationMessage(text.inputEl, "\u274C Invalid date format", "error");
        }
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Journal Folder Format").setDesc("Format for organizing journal folders by date.").addText((text) => text.setPlaceholder("YYYY/MM").setValue(this.plugin.settings.journalFolderFormat).onChange(async (value) => {
      if (value.trim()) {
        this.plugin.settings.journalFolderFormat = value.trim();
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Journal Template").setDesc("Template for new journal entries. Use {{date}}, {{title}}, {{previous}}, {{next}} as placeholders.").addTextArea((text) => {
      text.inputEl.rows = 8;
      text.inputEl.style.width = "100%";
      text.inputEl.style.minHeight = "150px";
      text.setPlaceholder(`# {{date}}

## Daily Log

## Tasks
- [ ] 

## Notes

## Reflection

---
Previous: {{previous}}
Next: {{next}}`);
      text.setValue(this.plugin.settings.journalTemplate);
      text.onChange(async (value) => {
        this.plugin.settings.journalTemplate = value;
        await this.plugin.saveSettings();
      });
      return text;
    });
    new import_obsidian.Setting(containerEl).setName("Create Monthly Folders").setDesc("Pre-create monthly folders for the current year.").addButton((button) => button.setButtonText("Create Folders").setTooltip("Create all monthly folders for the current year").onClick(async () => {
      var _a;
      try {
        const startOfYear = DateService.startOfYear();
        const endOfYear = DateService.endOfYear();
        await this.plugin.journalManager.createMonthlyFoldersForRange(startOfYear, endOfYear);
        const notice = document.createElement("div");
        notice.textContent = "\u2705 Monthly folders created successfully!";
        notice.style.color = "var(--text-success)";
        notice.style.fontWeight = "bold";
        (_a = button.buttonEl.parentElement) == null ? void 0 : _a.appendChild(notice);
        setTimeout(() => notice.remove(), 3e3);
      } catch (error) {
        this.plugin.errorHandler.handleError(error, "Failed to create monthly folders");
      }
    }));
  }
  addNoteSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F4DD} Note Creation" });
    const noteDesc = containerEl.createEl("p");
    noteDesc.textContent = "Configure templates and behavior for new note creation.";
    noteDesc.style.color = "var(--text-muted)";
    noteDesc.style.marginBottom = "1em";
    new import_obsidian.Setting(containerEl).setName("Note Template").setDesc("Default template for new notes. Use {{title}}, {{date}}, {{source}} as placeholders.").addTextArea((text) => {
      text.inputEl.rows = 6;
      text.inputEl.style.width = "100%";
      text.inputEl.style.minHeight = "120px";
      text.setPlaceholder(`---
title: {{title}}
created: {{date}}
source: {{source}}
tags: []
---

# {{title}}

`);
      text.setValue(this.plugin.settings.noteTemplate);
      text.onChange(async (value) => {
        const validation = NoteSettings.validateTemplate(value);
        if (validation.isValid) {
          this.plugin.settings.noteTemplate = value;
          await this.plugin.saveSettings();
          this.showValidationMessage(text.inputEl, "\u2705 Valid template", "success");
        } else {
          this.showValidationMessage(text.inputEl, `\u274C ${validation.errors.join(", ")}`, "error");
        }
      });
      return text;
    });
    new import_obsidian.Setting(containerEl).setName("Open New Notes").setDesc("Automatically open newly created notes in the editor.").addToggle((toggle) => toggle.setValue(this.plugin.settings.openNewNote).onChange(async (value) => {
      this.plugin.settings.openNewNote = value;
      await this.plugin.saveSettings();
    }));
  }
  addShortcodeSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u26A1 Shortcodes" });
    const shortcodeDesc = containerEl.createEl("p");
    shortcodeDesc.innerHTML = `
      Configure the shortcode system for rapid content creation. 
      <br><small>Example: <code>h2+ul>li*3</code> creates a heading with a 3-item list.</small>
    `;
    shortcodeDesc.style.color = "var(--text-muted)";
    shortcodeDesc.style.marginBottom = "1em";
    new import_obsidian.Setting(containerEl).setName("Enable Shortcodes").setDesc("Enable the shortcode expansion system.").addToggle((toggle) => toggle.setValue(this.plugin.settings.shortcodeEnabled).onChange(async (value) => {
      this.plugin.settings.shortcodeEnabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Trigger Key").setDesc("Key to trigger shortcode expansion.").addDropdown((dropdown) => dropdown.addOption("Tab", "Tab").addOption("Enter", "Enter").addOption("Space", "Space").setValue(this.plugin.settings.shortcodeTriggerKey).onChange(async (value) => {
      this.plugin.settings.shortcodeTriggerKey = value;
      await this.plugin.saveSettings();
    }));
    const builtinContainer = containerEl.createDiv();
    builtinContainer.createEl("h4", { text: "Built-in Shortcodes" });
    const builtinShortcodes = ShortcodeSettings.getBuiltinShortcodes();
    const shortcodeList = builtinContainer.createEl("ul");
    shortcodeList.style.fontSize = "0.9em";
    shortcodeList.style.color = "var(--text-muted)";
    Object.entries(builtinShortcodes).forEach(([pattern, description]) => {
      const item = shortcodeList.createEl("li");
      item.innerHTML = `<code>${pattern}</code> - ${description}`;
    });
    containerEl.createEl("h4", { text: "Custom Shortcodes" });
    containerEl.createEl("p", {
      text: "Add your own shortcode patterns. Format: pattern \u2192 expansion",
      attr: { style: "color: var(--text-muted); font-size: 0.9em; margin-bottom: 1em;" }
    });
    new import_obsidian.Setting(containerEl).setName("Add Custom Shortcode").setDesc("Create a new custom shortcode pattern.").addButton((button) => button.setButtonText("Add Shortcode").onClick(() => {
      this.showCustomShortcodeDialog();
    }));
    this.displayCustomShortcodes(containerEl);
  }
  addGeneralSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u2699\uFE0F General Settings" });
    const generalDesc = containerEl.createEl("p");
    generalDesc.textContent = "General plugin configuration and debugging options.";
    generalDesc.style.color = "var(--text-muted)";
    generalDesc.style.marginBottom = "1em";
    new import_obsidian.Setting(containerEl).setName("Debug Mode").setDesc("Enable detailed logging for troubleshooting. Check the developer console for debug messages.").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      await this.plugin.saveSettings();
      if (value) {
        console.log("[LinkPlugin] Debug mode enabled");
        console.log("[LinkPlugin] Current settings:", this.plugin.settings);
        console.log("[LinkPlugin] DateService info:", DateService.getDebugInfo());
      }
    }));
  }
  addAdvancedSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F527} Advanced" });
    const advancedDesc = containerEl.createEl("p");
    advancedDesc.textContent = "Advanced settings and maintenance tools.";
    advancedDesc.style.color = "var(--text-muted)";
    advancedDesc.style.marginBottom = "1em";
    new import_obsidian.Setting(containerEl).setName("Validate Settings").setDesc("Check current settings for any issues or conflicts.").addButton((button) => button.setButtonText("Validate").onClick(() => {
      var _a, _b;
      const validation = validateSettingsWithDetails(this.plugin.settings);
      const resultEl = document.createElement("div");
      resultEl.style.marginTop = "10px";
      resultEl.style.padding = "10px";
      resultEl.style.borderRadius = "4px";
      resultEl.style.border = "1px solid var(--background-modifier-border)";
      if (validation.isValid) {
        resultEl.style.backgroundColor = "var(--background-modifier-success)";
        resultEl.innerHTML = "<strong>\u2705 All settings are valid!</strong>";
      } else {
        resultEl.style.backgroundColor = "var(--background-modifier-error)";
        let content = "<strong>\u274C Settings validation failed:</strong><ul>";
        validation.errors.forEach((error) => {
          content += `<li>${error}</li>`;
        });
        content += "</ul>";
        if (validation.warnings.length > 0) {
          content += "<strong>\u26A0\uFE0F Warnings:</strong><ul>";
          validation.warnings.forEach((warning) => {
            content += `<li>${warning}</li>`;
          });
          content += "</ul>";
        }
        resultEl.innerHTML = content;
      }
      const existing = (_a = button.buttonEl.parentElement) == null ? void 0 : _a.querySelector(".validation-result");
      if (existing)
        existing.remove();
      resultEl.classList.add("validation-result");
      (_b = button.buttonEl.parentElement) == null ? void 0 : _b.appendChild(resultEl);
      setTimeout(() => resultEl.remove(), 1e4);
    }));
    new import_obsidian.Setting(containerEl).setName("Reset to Defaults").setDesc("\u26A0\uFE0F Reset all settings to their default values. This cannot be undone.").addButton((button) => button.setButtonText("Reset").setWarning().onClick(async () => {
      var _a;
      const confirmed = confirm("Are you sure you want to reset all settings to defaults? This cannot be undone.");
      if (confirmed) {
        const { DEFAULT_SETTINGS: DEFAULT_SETTINGS3 } = await Promise.resolve().then(() => (init_settings(), settings_exports));
        this.plugin.settings = { ...DEFAULT_SETTINGS3 };
        await this.plugin.saveSettings();
        this.display();
        const notice = document.createElement("div");
        notice.textContent = "\u2705 Settings reset to defaults successfully!";
        notice.style.color = "var(--text-success)";
        notice.style.fontWeight = "bold";
        notice.style.marginTop = "10px";
        (_a = button.buttonEl.parentElement) == null ? void 0 : _a.appendChild(notice);
        setTimeout(() => notice.remove(), 3e3);
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Export Settings").setDesc("Export current settings as JSON for backup or sharing.").addButton((button) => button.setButtonText("Export").onClick(() => {
      const settingsJson = JSON.stringify(this.plugin.settings, null, 2);
      navigator.clipboard.writeText(settingsJson).then(() => {
        var _a;
        const notice = document.createElement("div");
        notice.textContent = "\u2705 Settings copied to clipboard!";
        notice.style.color = "var(--text-success)";
        notice.style.fontWeight = "bold";
        notice.style.marginTop = "10px";
        (_a = button.buttonEl.parentElement) == null ? void 0 : _a.appendChild(notice);
        setTimeout(() => notice.remove(), 3e3);
      });
    }));
  }
  showValidationMessage(inputEl, message, type) {
    var _a, _b;
    const existing = (_a = inputEl.parentElement) == null ? void 0 : _a.querySelector(".validation-message");
    if (existing)
      existing.remove();
    const messageEl = document.createElement("div");
    messageEl.classList.add("validation-message");
    messageEl.textContent = message;
    messageEl.style.fontSize = "0.8em";
    messageEl.style.marginTop = "4px";
    messageEl.style.color = type === "success" ? "var(--text-success)" : "var(--text-error)";
    (_b = inputEl.parentElement) == null ? void 0 : _b.appendChild(messageEl);
    setTimeout(() => messageEl.remove(), 3e3);
  }
  displayCustomShortcodes(containerEl) {
    const customShortcodes = this.plugin.settings.customShortcodes;
    if (Object.keys(customShortcodes).length === 0) {
      const emptyEl = containerEl.createEl("p");
      emptyEl.textContent = "No custom shortcodes defined.";
      emptyEl.style.color = "var(--text-muted)";
      emptyEl.style.fontStyle = "italic";
      return;
    }
    Object.entries(customShortcodes).forEach(([pattern, expansion]) => {
      new import_obsidian.Setting(containerEl).setName(pattern).setDesc(expansion.length > 50 ? expansion.substring(0, 50) + "..." : expansion).addButton((button) => button.setButtonText("Delete").setTooltip("Delete this custom shortcode").onClick(async () => {
        delete this.plugin.settings.customShortcodes[pattern];
        await this.plugin.saveSettings();
        this.display();
      }));
    });
  }
  showCustomShortcodeDialog() {
    const modal = document.createElement("div");
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;
    `;
    const dialog = document.createElement("div");
    dialog.style.cssText = `
      background: var(--background-primary); padding: 20px; border-radius: 8px; max-width: 500px; width: 90%;
      border: 1px solid var(--background-modifier-border);
    `;
    dialog.innerHTML = `
      <h3>Add Custom Shortcode</h3>
      <div style="margin: 15px 0;">
        <label>Pattern:</label>
        <input type="text" id="shortcode-pattern" placeholder="e.g., mylist" style="width: 100%; margin-top: 5px; padding: 8px;">
      </div>
      <div style="margin: 15px 0;">
        <label>Expansion:</label>
        <textarea id="shortcode-expansion" placeholder="e.g., - [ ] Item 1&#10;- [ ] Item 2" style="width: 100%; height: 100px; margin-top: 5px; padding: 8px;"></textarea>
      </div>
      <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
        <button id="cancel-btn">Cancel</button>
        <button id="save-btn" style="background: var(--interactive-accent); color: var(--text-on-accent);">Save</button>
      </div>
    `;
    modal.appendChild(dialog);
    document.body.appendChild(modal);
    const patternInput = dialog.querySelector("#shortcode-pattern");
    const expansionInput = dialog.querySelector("#shortcode-expansion");
    const cancelBtn = dialog.querySelector("#cancel-btn");
    const saveBtn = dialog.querySelector("#save-btn");
    const closeModal = () => document.body.removeChild(modal);
    cancelBtn.onclick = closeModal;
    modal.onclick = (e) => e.target === modal && closeModal();
    saveBtn.onclick = async () => {
      const pattern = patternInput.value.trim();
      const expansion = expansionInput.value.trim();
      if (!pattern || !expansion) {
        alert("Both pattern and expansion are required.");
        return;
      }
      if (!ShortcodeSettings.isValidShortcodePattern(pattern)) {
        alert("Invalid shortcode pattern. Use alphanumeric characters and shortcode operators (+, >, *, {}, [], ()).");
        return;
      }
      this.plugin.settings.customShortcodes[pattern] = expansion;
      await this.plugin.saveSettings();
      closeModal();
      this.display();
    };
    patternInput.focus();
  }
};

// src/ui/ribbonManager.ts
var import_obsidian2 = require("obsidian");
init_constants();
var RibbonManager = class {
  constructor(plugin) {
    this.ribbonButtons = [];
    this.plugin = plugin;
  }
  /**
   * Initialize all ribbon buttons
   */
  initializeRibbon() {
    this.addTodayJournalButton();
    this.addCreateNoteButton();
    this.addMonthlyFoldersButton();
    this.addShortcodeHelpButton();
    this.addRebuildStructureButton();
    this.addSettingsButton();
    if (this.plugin.settings.debugMode) {
      console.log("[LinkPlugin] Ribbon initialized with", this.ribbonButtons.length, "buttons");
    }
  }
  /**
   * Clean up ribbon buttons on plugin unload
   */
  cleanup() {
    this.ribbonButtons.forEach((button) => {
      button.remove();
    });
    this.ribbonButtons = [];
  }
  /**
   * Add Today's Journal button
   */
  addTodayJournalButton() {
    const button = this.plugin.addRibbonIcon(
      RIBBON_BUTTONS.TODAY_JOURNAL.icon,
      RIBBON_BUTTONS.TODAY_JOURNAL.tooltip,
      async () => {
        try {
          await this.plugin.journalManager.openTodayJournal();
          this.showSuccess("Today's journal opened");
        } catch (error) {
          this.plugin.errorHandler.handleError(error, "Failed to open today's journal");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Add Create Linked Note button
   */
  addCreateNoteButton() {
    const button = this.plugin.addRibbonIcon(
      RIBBON_BUTTONS.CREATE_NOTE.icon,
      RIBBON_BUTTONS.CREATE_NOTE.tooltip,
      () => {
        try {
          const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
          if (!activeView) {
            new import_obsidian2.Notice("Please open a markdown note first");
            return;
          }
          const editor = activeView.editor;
          const selection = editor.getSelection();
          if (!selection) {
            new import_obsidian2.Notice("Please select text to create a linked note");
            return;
          }
          this.plugin.linkManager.createLinkedNote(selection, editor, activeView);
          this.showSuccess("Linked note created");
        } catch (error) {
          this.plugin.errorHandler.handleError(error, "Failed to create linked note");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Add Monthly Folders button
   */
  addMonthlyFoldersButton() {
    const button = this.plugin.addRibbonIcon(
      RIBBON_BUTTONS.MONTHLY_FOLDERS.icon,
      RIBBON_BUTTONS.MONTHLY_FOLDERS.tooltip,
      async () => {
        try {
          const startOfYear = DateService.startOfYear();
          const endOfYear = DateService.endOfYear();
          await this.plugin.journalManager.createMonthlyFoldersForRange(startOfYear, endOfYear);
          this.showSuccess("Monthly folders created for current year");
        } catch (error) {
          this.plugin.errorHandler.handleError(error, "Failed to create monthly folders");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Add Shortcode Help button
   */
  addShortcodeHelpButton() {
    const button = this.plugin.addRibbonIcon(
      RIBBON_BUTTONS.SHORTCODE_HELP.icon,
      RIBBON_BUTTONS.SHORTCODE_HELP.tooltip,
      () => {
        try {
          this.plugin.shortcodeManager.showHelpModal();
        } catch (error) {
          this.plugin.errorHandler.handleError(error, "Failed to show shortcode help");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Add Rebuild Directory Structure button
   */
  addRebuildStructureButton() {
    const button = this.plugin.addRibbonIcon(
      RIBBON_BUTTONS.REBUILD_STRUCTURE.icon,
      RIBBON_BUTTONS.REBUILD_STRUCTURE.tooltip,
      async () => {
        try {
          await this.plugin.directoryManager.rebuildDirectoryStructure();
          this.showSuccess("Directory structure rebuilt");
        } catch (error) {
          this.plugin.errorHandler.handleError(error, "Failed to rebuild directory structure");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Add Settings button
   */
  addSettingsButton() {
    const button = this.plugin.addRibbonIcon(
      RIBBON_BUTTONS.PLUGIN_SETTINGS.icon,
      RIBBON_BUTTONS.PLUGIN_SETTINGS.tooltip,
      () => {
        try {
          this.plugin.app.setting.open();
          this.plugin.app.setting.openTabById(this.plugin.manifest.id);
        } catch (error) {
          new import_obsidian2.Notice("Please open Settings manually and find the Link Plugin tab");
          this.plugin.errorHandler.handleError(error, "Failed to open settings automatically");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Show success message
   */
  showSuccess(message) {
    new import_obsidian2.Notice(`\u2705 ${message}`);
    if (this.plugin.settings.debugMode) {
      console.log(`[LinkPlugin] ${message}`);
    }
  }
  /**
   * Update ribbon button states based on settings
   */
  updateButtonStates() {
    if (this.plugin.settings.debugMode) {
      console.log("[LinkPlugin] Ribbon button states updated");
    }
  }
  /**
   * Get ribbon button count for debugging
   */
  getButtonCount() {
    return this.ribbonButtons.length;
  }
  /**
   * Add a custom ribbon button (for future extensibility)
   */
  addCustomButton(icon, tooltip, callback) {
    const button = this.plugin.addRibbonIcon(icon, tooltip, callback);
    this.ribbonButtons.push(button);
    return button;
  }
  /**
   * Remove a specific ribbon button
   */
  removeButton(button) {
    const index = this.ribbonButtons.indexOf(button);
    if (index > -1) {
      this.ribbonButtons.splice(index, 1);
      button.remove();
    }
  }
  /**
   * Show quick actions menu (future enhancement)
   */
  showQuickActionsMenu() {
    const message = `
Link Plugin Quick Actions:
\u2022 Today's Journal: ${RIBBON_BUTTONS.TODAY_JOURNAL.tooltip}
\u2022 Create Note: ${RIBBON_BUTTONS.CREATE_NOTE.tooltip}
\u2022 Monthly Folders: ${RIBBON_BUTTONS.MONTHLY_FOLDERS.tooltip}
\u2022 Shortcode Help: ${RIBBON_BUTTONS.SHORTCODE_HELP.tooltip}
\u2022 Rebuild Structure: ${RIBBON_BUTTONS.REBUILD_STRUCTURE.tooltip}
\u2022 Settings: ${RIBBON_BUTTONS.PLUGIN_SETTINGS.tooltip}
    `.trim();
    new import_obsidian2.Notice(message, 8e3);
  }
};

// src/managers/directoryManager.ts
var import_obsidian4 = require("obsidian");
init_constants();

// src/utils/pathUtils.ts
var import_obsidian3 = require("obsidian");
var PathUtils = class {
  static sanitizePath(path) {
    return (0, import_obsidian3.normalizePath)(path.replace(/[\/:*?"<>|]/g, "").trim());
  }
  static joinPath(...segments) {
    return (0, import_obsidian3.normalizePath)(segments.filter(Boolean).join("/"));
  }
};

// src/managers/directoryManager.ts
var DirectoryManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates the base directory structure according to settings
   * All directories are created under the configured baseFolder to prevent collisions
   */
  async rebuildDirectoryStructure() {
    const { vault } = this.plugin.app;
    const { baseFolder, directoryStructure } = this.plugin.settings;
    try {
      const basePath = (0, import_obsidian4.normalizePath)(baseFolder);
      await this.getOrCreateDirectory(basePath);
      console.log(`Created base directory: ${basePath}`);
      for (const dirName of directoryStructure || DEFAULT_DIRECTORIES) {
        const dirPath = PathUtils.joinPath(basePath, dirName);
        await this.getOrCreateDirectory(dirPath);
        console.log(`Created directory: ${dirPath}`);
      }
      await this.createJournalStructure(basePath);
      await this.createReferenceStructure(basePath);
    } catch (error) {
      throw new Error(`Failed to rebuild directory structure: ${error}`);
    }
  }
  /**
   * Creates the detailed journal structure as specified in README
   */
  async createJournalStructure(basePath) {
    const journalPath = PathUtils.joinPath(basePath, "journal");
    const journalSubdirs = [
      "Misc",
      "y_2025/January",
      "y_2025/February",
      "y_2025/March",
      "y_2025/April",
      "y_2025/May",
      "y_2025/June",
      "y_2025/Misc",
      "y_2025/Yearly List",
      "y_2025/Yearly Log",
      "z_Archives/y_2022",
      "z_Archives/y_2023",
      "z_Archives/y_2024"
    ];
    for (const subdir of journalSubdirs) {
      const fullPath = PathUtils.joinPath(journalPath, subdir);
      await this.getOrCreateDirectory(fullPath);
      console.log(`Created journal directory: ${fullPath}`);
    }
  }
  /**
   * Creates the reference file structure as specified in README
   */
  async createReferenceStructure(basePath) {
    const referencePath = PathUtils.joinPath(basePath, "reference");
    const fileTypes = ["images", "pdfs", "videos", "audio", "docs", "other"];
    for (const fileType of fileTypes) {
      const filePath = PathUtils.joinPath(referencePath, "files", fileType);
      await this.getOrCreateDirectory(filePath);
      console.log(`Created reference directory: ${filePath}`);
    }
  }
  /**
   * Creates optional complex structure directories
   */
  async createOptionalStructure(basePath) {
    for (const dirName of OPTIONAL_DIRECTORIES) {
      const dirPath = PathUtils.joinPath(basePath, dirName);
      await this.getOrCreateDirectory(dirPath);
      console.log(`Created optional directory: ${dirPath}`);
    }
  }
  /**
   * Gets a directory path, creating it if it doesn't exist
   * Handles both absolute paths and paths relative to the base folder
   */
  async getOrCreateDirectory(path) {
    const { vault } = this.plugin.app;
    const normalizedPath = (0, import_obsidian4.normalizePath)(path);
    const existingFolder = vault.getAbstractFileByPath(normalizedPath);
    if (existingFolder instanceof import_obsidian4.TFolder) {
      return existingFolder;
    }
    const pathParts = normalizedPath.split("/");
    let currentPath = "";
    for (const part of pathParts) {
      if (!part)
        continue;
      currentPath += (currentPath ? "/" : "") + part;
      const folder = vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await vault.createFolder(currentPath);
      } else if (!(folder instanceof import_obsidian4.TFolder)) {
        throw new Error(`Path ${currentPath} exists but is not a folder`);
      }
    }
    return vault.getAbstractFileByPath(normalizedPath);
  }
  /**
   * Gets the full path for a directory within the plugin's base folder
   */
  getPluginDirectoryPath(relativePath) {
    const { baseFolder } = this.plugin.settings;
    return PathUtils.joinPath(baseFolder, relativePath);
  }
  /**
   * Gets the journal directory path
   */
  getJournalPath() {
    const { baseFolder, journalRootFolder } = this.plugin.settings;
    return PathUtils.joinPath(baseFolder, journalRootFolder);
  }
  /**
   * Gets the workspace directory path  
   */
  getWorkspacePath() {
    const { baseFolder, documentDirectory } = this.plugin.settings;
    return PathUtils.joinPath(baseFolder, documentDirectory);
  }
  /**
   * Applies a directory template to create structured folders
   */
  async applyDirectoryTemplate(basePath, template) {
    for (const [key, value] of Object.entries(template)) {
      const dirPath = PathUtils.joinPath(basePath, key);
      await this.getOrCreateDirectory(dirPath);
      if (value && typeof value === "object") {
        await this.applyDirectoryTemplate(dirPath, value);
      }
    }
  }
  /**
   * Validates if a given path is within allowed directories
   */
  isValidPath(path) {
    const normalizedPath = (0, import_obsidian4.normalizePath)(path);
    const { restrictedDirectories } = this.plugin.settings;
    if (!restrictedDirectories || restrictedDirectories.length === 0) {
      return true;
    }
    return !restrictedDirectories.some((dir) => {
      const normalizedDir = (0, import_obsidian4.normalizePath)(dir);
      return normalizedPath === normalizedDir || normalizedPath.startsWith(normalizedDir + "/");
    });
  }
  /**
   * Lists all directories in the vault
   */
  getAllDirectories() {
    const { vault } = this.plugin.app;
    return vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian4.TFolder);
  }
  /**
   * Creates a directory with a specific template structure within the plugin's base folder
   */
  async createProjectDirectory(name, template) {
    const sanitizedName = PathUtils.sanitizePath(name);
    const workspacePath = this.getWorkspacePath();
    const projectPath = PathUtils.joinPath(workspacePath, sanitizedName);
    const projectFolder = await this.getOrCreateDirectory(projectPath);
    if (template) {
      await this.applyDirectoryTemplate(projectPath, template);
    }
    return projectFolder;
  }
};

// src/managers/journalManager.ts
var import_obsidian5 = require("obsidian");
var JournalManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates or opens a journal entry for the specified date
   * Automatically creates monthly folders as needed
   */
  async createOrOpenJournalEntry(date) {
    const { vault } = this.plugin.app;
    const { journalDateFormat, journalTemplate } = this.plugin.settings;
    await this.ensureMonthlyFolderExists(date);
    const monthlyFolderPath = this.getMonthlyFolderPath(date);
    const fileName = DateService.getJournalFilename(date, journalDateFormat);
    const filePath = (0, import_obsidian5.normalizePath)(`${monthlyFolderPath}/${fileName}.md`);
    let file = vault.getAbstractFileByPath(filePath);
    if (!file) {
      const content = await this.generateJournalContent(date);
      file = await vault.create(filePath, content);
      console.log(`Created daily note: ${filePath}`);
    }
    return file;
  }
  /**
   * Ensures the monthly folder exists for the given date
   * Creates the folder structure if it doesn't exist
   */
  async ensureMonthlyFolderExists(date) {
    const monthlyFolderPath = this.getMonthlyFolderPath(date);
    await this.plugin.directoryManager.getOrCreateDirectory(monthlyFolderPath);
    console.log(`Ensured monthly folder exists: ${monthlyFolderPath}`);
  }
  /**
   * Gets the monthly folder path for a given date
   * Uses the new base folder structure: LinkPlugin/journal/y_YYYY/MonthName/
   */
  getMonthlyFolderPath(date) {
    const journalBasePath = this.plugin.directoryManager.getJournalPath();
    return DateService.getMonthlyFolderPath(journalBasePath, date);
  }
  /**
   * Creates a daily note for today if it doesn't exist
   * Automatically handles monthly folder creation
   */
  async createTodayNote() {
    const today = DateService.now();
    return await this.createOrOpenJournalEntry(today);
  }
  /**
   * Creates a daily note for a future date
   * Automatically creates monthly folders as needed
   */
  async createFutureDailyNote(date) {
    const targetDate = DateService.from(date);
    return await this.createOrOpenJournalEntry(targetDate);
  }
  /**
   * Generate content for a journal entry
   */
  async generateJournalContent(date) {
    const { journalTemplate, journalDateFormat } = this.plugin.settings;
    const previousDay = DateService.previousDay(date);
    const nextDay = DateService.nextDay(date);
    const previousLink = `[[${DateService.format(previousDay, journalDateFormat)}]]`;
    const nextLink = `[[${DateService.format(nextDay, journalDateFormat)}]]`;
    const currentDate = DateService.format(date, "YYYY-MM-DD");
    const title = DateService.format(date, journalDateFormat);
    if (journalTemplate) {
      return journalTemplate.replace(/{{date}}/g, currentDate).replace(/{{title}}/g, title).replace(/{{previous}}/g, previousLink).replace(/{{next}}/g, nextLink);
    }
    return `---
date: ${currentDate}
previous: ${previousLink}
next: ${nextLink}
tags:
  - journal
---

# ${title}

## Daily Log

## Tasks
- [ ] 

## Notes

## Reflection

---
Previous: ${previousLink} | Next: ${nextLink}
`;
  }
  /**
   * Opens the journal entry for today
   * Creates monthly folder and daily note if they don't exist
   */
  async openTodayJournal() {
    const today = DateService.now();
    const file = await this.createOrOpenJournalEntry(today);
    const leaf = this.plugin.app.workspace.getLeaf();
    await leaf.openFile(file);
  }
  /**
   * Checks if we need to create a new monthly folder
   * Called when the plugin loads or when creating notes
   */
  async checkAndCreateCurrentMonthFolder() {
    const currentDate = DateService.now();
    await this.ensureMonthlyFolderExists(currentDate);
  }
  /**
   * Creates monthly folders for a range of dates
   * Useful for batch creation or setup
   */
  async createMonthlyFoldersForRange(startDate, endDate) {
    const current = DateService.startOfMonth(startDate);
    const end = DateService.endOfMonth(endDate);
    while (DateService.isSameOrBefore(current, end)) {
      await this.ensureMonthlyFolderExists(current);
      DateService.add(current, 1, "month");
    }
  }
  /**
   * Opens journal entry for a specific date
   */
  async openJournalForDate(date) {
    const momentDate = DateService.from(date);
    const file = await this.createOrOpenJournalEntry(momentDate);
    const leaf = this.plugin.app.workspace.getLeaf();
    await leaf.openFile(file);
  }
  /**
   * Updates links between journal entries
   */
  async updateJournalLinks(file) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    const fileDate = DateService.extractDateFromFilename(file.basename, journalDateFormat || "YYYY-MM-DD dddd");
    if (!fileDate)
      return;
    const content = await vault.read(file);
    const previousDay = DateService.previousDay(fileDate);
    const nextDay = DateService.nextDay(fileDate);
    const previousFileName = DateService.format(previousDay, journalDateFormat);
    const nextFileName = DateService.format(nextDay, journalDateFormat);
    const updatedContent = content.replace(/previous: '\[\[(.*?)\]\]'/g, `previous: '[[${previousFileName}]]'`).replace(/next: '\[\[(.*?)\]\]'/g, `next: '[[${nextFileName}]]'`);
    if (updatedContent !== content) {
      await vault.modify(file, updatedContent);
    }
  }
  /**
   * Get journal entries for a date range
   */
  async getJournalEntries(startDate, endDate) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    const entries = [];
    const current = DateService.from(startDate);
    while (DateService.isSameOrBefore(current, endDate)) {
      const filePath = DateService.getJournalFilePath(
        this.plugin.directoryManager.getJournalPath(),
        current,
        journalDateFormat
      );
      const file = vault.getAbstractFileByPath(filePath);
      if (file) {
        entries.push({
          date: DateService.format(current, "YYYY-MM-DD"),
          path: filePath,
          title: DateService.format(current, journalDateFormat),
          previous: DateService.format(DateService.previousDay(current), "YYYY-MM-DD"),
          next: DateService.format(DateService.nextDay(current), "YYYY-MM-DD")
        });
      }
      DateService.add(current, 1, "day");
    }
    return entries;
  }
};

// src/managers/linkManager.ts
var import_obsidian6 = require("obsidian");
init_constants();
var LinkManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Create a new note from selected text and link to it
   */
  async createLinkedNote(selection, editor, view) {
    const { vault } = this.plugin.app;
    const currentFile = view.file;
    if (!currentFile) {
      throw new Error("No active file found");
    }
    const fileName = this.sanitizeFileName(selection);
    const directoryPath = this.determineTargetDirectory(fileName);
    const filePath = (0, import_obsidian6.normalizePath)(`${directoryPath}/${fileName}.md`);
    let file = vault.getAbstractFileByPath(filePath);
    if (!file) {
      await this.plugin.directoryManager.getOrCreateDirectory(directoryPath);
      const content = this.generateNoteContent(selection, currentFile);
      file = await vault.create(filePath, content);
    }
    editor.replaceSelection(`[[${fileName}]]`);
    if (this.plugin.settings.openNewNote) {
      const leaf = this.plugin.app.workspace.splitActiveLeaf();
      await leaf.openFile(file);
    }
  }
  /**
   * Determine the appropriate directory for a new note
   */
  determineTargetDirectory(title) {
    const { documentDirectory } = this.plugin.settings;
    const keywords = title.toLowerCase();
    if (keywords.includes("project") || keywords.includes("work")) {
      return "Workspace";
    } else if (keywords.includes("reference") || keywords.includes("definition")) {
      return "References";
    } else if (keywords.includes("template")) {
      return "Templates";
    }
    return documentDirectory || "Documents";
  }
  /**
   * Generate content for a new linked note
   */
  generateNoteContent(title, sourceFile) {
    const { noteTemplate } = this.plugin.settings;
    const currentDate = new Date().toISOString().split("T")[0];
    if (noteTemplate) {
      return noteTemplate.replace(/{{title}}/g, title).replace(/{{date}}/g, currentDate).replace(/{{source}}/g, `[[${sourceFile.basename}]]`);
    }
    return `---
title: ${title}
created: ${currentDate}
source: [[${sourceFile.basename}]]
tags: []
---

# ${title}

`;
  }
  /**
   * Sanitize a string for use as a filename
   */
  sanitizeFileName(input) {
    return input.replace(REGEX_PATTERNS.INVALID_FILENAME_CHARS, "").replace(/\s+/g, " ").trim().substring(0, 100);
  }
  /**
   * Find all links in a file
   */
  async findLinksInFile(file) {
    const { vault } = this.plugin.app;
    const content = await vault.read(file);
    const links = [];
    let match;
    while ((match = REGEX_PATTERNS.WIKI_LINK.exec(content)) !== null) {
      links.push(match[1]);
    }
    return links;
  }
  /**
   * Find all backlinks to a file
   */
  async findBacklinks(file) {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const backlinks = [];
    for (const potentialSource of files) {
      if (potentialSource.path === file.path)
        continue;
      const links = await this.findLinksInFile(potentialSource);
      if (links.includes(file.basename)) {
        backlinks.push(potentialSource);
      }
    }
    return backlinks;
  }
  /**
   * Find broken links in the vault
   */
  async findBrokenLinks() {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const brokenLinksData = [];
    for (const file of files) {
      const links = await this.findLinksInFile(file);
      const brokenLinks = [];
      for (const link of links) {
        const linkedFile = vault.getAbstractFileByPath(`${link}.md`) || vault.getAbstractFileByPath(link);
        if (!linkedFile) {
          brokenLinks.push(link);
        }
      }
      if (brokenLinks.length > 0) {
        brokenLinksData.push({ file, brokenLinks });
      }
    }
    return brokenLinksData;
  }
  /**
   * Find orphaned notes (notes with no backlinks)
   */
  async findOrphanedNotes() {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const orphanedNotes = [];
    for (const file of files) {
      const backlinks = await this.findBacklinks(file);
      if (backlinks.length === 0) {
        orphanedNotes.push(file);
      }
    }
    return orphanedNotes;
  }
  /**
   * Generate link suggestions based on content similarity
   */
  async generateLinkSuggestions(file, limit = 5) {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const suggestions = [];
    const currentContent = await vault.read(file);
    const currentWords = this.extractWords(currentContent);
    for (const otherFile of files) {
      if (otherFile.path === file.path)
        continue;
      const otherContent = await vault.read(otherFile);
      const otherWords = this.extractWords(otherContent);
      const relevance = this.calculateRelevance(currentWords, otherWords);
      if (relevance > 0.1) {
        suggestions.push({
          title: otherFile.basename,
          path: otherFile.path,
          relevance,
          type: "existing"
        });
      }
    }
    return suggestions.sort((a, b) => b.relevance - a.relevance).slice(0, limit);
  }
  /**
   * Extract meaningful words from content
   */
  extractWords(content) {
    const words = /* @__PURE__ */ new Set();
    const text = content.replace(/[#*`\[\]()]/g, "").toLowerCase().split(/\s+/);
    for (const word of text) {
      if (word.length > 3 && !this.isStopWord(word)) {
        words.add(word);
      }
    }
    return words;
  }
  /**
   * Calculate relevance between two sets of words
   */
  calculateRelevance(words1, words2) {
    const intersection = new Set([...words1].filter((word) => words2.has(word)));
    const union = /* @__PURE__ */ new Set([...words1, ...words2]);
    return intersection.size / union.size;
  }
  /**
   * Check if a word is a stop word
   */
  isStopWord(word) {
    const stopWords = /* @__PURE__ */ new Set([
      "the",
      "a",
      "an",
      "and",
      "or",
      "but",
      "in",
      "on",
      "at",
      "to",
      "for",
      "of",
      "with",
      "by",
      "is",
      "are",
      "was",
      "were",
      "be",
      "been",
      "have",
      "has",
      "had",
      "do",
      "does",
      "did",
      "will",
      "would",
      "could",
      "should",
      "may",
      "might",
      "must",
      "can",
      "this",
      "that",
      "these",
      "those"
    ]);
    return stopWords.has(word);
  }
};

// src/shortcodes/tokenizer.ts
var Tokenizer = class {
  /**
   * Tokenize an Emmet-like shortcode string
   */
  tokenize(input) {
    const tokens = [];
    let currentPos = 0;
    while (currentPos < input.length) {
      const char = input[currentPos];
      if (this.isNameChar(char)) {
        const { token, newPos } = this.tokenizeElement(input, currentPos);
        tokens.push(token);
        currentPos = newPos;
        continue;
      }
      if (this.isOperator(char)) {
        tokens.push({
          type: "operator",
          value: char
        });
        currentPos++;
        continue;
      }
      if (char === "{") {
        const { token, newPos } = this.tokenizeContent(input, currentPos);
        tokens.push(token);
        currentPos = newPos;
        continue;
      }
      if (char === "[") {
        const { token, newPos } = this.tokenizeAttribute(input, currentPos);
        tokens.push(token);
        currentPos = newPos;
        continue;
      }
      if (char === "(") {
        const { token, newPos } = this.tokenizeGroup(input, currentPos);
        tokens.push(token);
        currentPos = newPos;
        continue;
      }
      if (char === " " || char === "	" || char === "\n") {
        currentPos++;
        continue;
      }
      throw new Error(`Unexpected character: ${char} at position ${currentPos}`);
    }
    return tokens;
  }
  tokenizeElement(input, startPos) {
    let endPos = startPos;
    while (endPos < input.length && this.isNameChar(input[endPos])) {
      endPos++;
    }
    if (endPos < input.length && input[endPos] === "*") {
      const elementName = input.substring(startPos, endPos);
      endPos++;
      const numberStartPos = endPos;
      while (endPos < input.length && /\d/.test(input[endPos])) {
        endPos++;
      }
      const multiplier = parseInt(input.substring(numberStartPos, endPos), 10);
      return {
        token: {
          type: "element",
          value: elementName,
          children: [{
            type: "multiplier",
            value: multiplier.toString()
          }]
        },
        newPos: endPos
      };
    }
    return {
      token: {
        type: "element",
        value: input.substring(startPos, endPos)
      },
      newPos: endPos
    };
  }
  tokenizeContent(input, startPos) {
    let endPos = startPos + 1;
    let depth = 1;
    while (endPos < input.length && depth > 0) {
      if (input[endPos] === "{")
        depth++;
      if (input[endPos] === "}")
        depth--;
      endPos++;
    }
    if (depth !== 0) {
      throw new Error("Unclosed content braces");
    }
    return {
      token: {
        type: "content",
        value: input.substring(startPos + 1, endPos - 1)
      },
      newPos: endPos
    };
  }
  tokenizeAttribute(input, startPos) {
    let endPos = startPos + 1;
    let depth = 1;
    while (endPos < input.length && depth > 0) {
      if (input[endPos] === "[")
        depth++;
      if (input[endPos] === "]")
        depth--;
      endPos++;
    }
    if (depth !== 0) {
      throw new Error("Unclosed attribute brackets");
    }
    return {
      token: {
        type: "attribute",
        value: input.substring(startPos + 1, endPos - 1)
      },
      newPos: endPos
    };
  }
  tokenizeGroup(input, startPos) {
    let endPos = startPos + 1;
    let depth = 1;
    while (endPos < input.length && depth > 0) {
      if (input[endPos] === "(")
        depth++;
      if (input[endPos] === ")")
        depth--;
      endPos++;
    }
    if (depth !== 0) {
      throw new Error("Unclosed group parentheses");
    }
    const groupContent = input.substring(startPos + 1, endPos - 1);
    const childTokens = new Tokenizer().tokenize(groupContent);
    return {
      token: {
        type: "group",
        value: groupContent,
        children: childTokens
      },
      newPos: endPos
    };
  }
  isNameChar(char) {
    return /[a-zA-Z0-9_-]/.test(char);
  }
  isOperator(char) {
    return char === ">" || char === "+" || char === "*";
  }
};

// src/shortcodes/parser.ts
var Parser = class {
  /**
   * Parse tokens into an Abstract Syntax Tree
   */
  parse(tokens) {
    const ast = [];
    let currentNode = null;
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      switch (token.type) {
        case "element":
          currentNode = {
            type: "element",
            name: token.value,
            children: []
          };
          if (token.children && token.children.length > 0) {
            const multiplier = token.children.find((child) => child.type === "multiplier");
            if (multiplier) {
              currentNode.repeat = parseInt(multiplier.value, 10);
            }
          }
          ast.push(currentNode);
          break;
        case "content":
          if (currentNode) {
            currentNode.content = token.value;
          }
          break;
        case "attribute":
          if (currentNode) {
            currentNode.attributes = this.parseAttributes(token.value);
          }
          break;
        case "operator":
          if (token.value === ">" && i + 1 < tokens.length) {
            const childTokens = [tokens[++i]];
            const childNodes = this.parse(childTokens);
            if (currentNode && childNodes.length > 0) {
              currentNode.children = currentNode.children || [];
              currentNode.children.push(...childNodes);
              childNodes.forEach((child) => child.parent = currentNode.name);
            }
          } else if (token.value === "+") {
            continue;
          }
          break;
        case "group":
          if (token.children) {
            const groupNodes = this.parse(token.children);
            ast.push(...groupNodes);
          }
          break;
      }
    }
    return ast;
  }
  parseAttributes(attrString) {
    const attributes = {};
    if (attrString.includes("=")) {
      const pairs = attrString.split(/\s+/);
      for (const pair of pairs) {
        const [key, value] = pair.split("=");
        if (key && value) {
          attributes[key] = value.replace(/["']/g, "");
        }
      }
    } else {
      attributes.value = attrString;
    }
    return attributes;
  }
  /**
   * Validate the AST structure
   */
  validate(ast) {
    for (const node of ast) {
      if (!node.name && node.type === "element") {
        return false;
      }
      if (node.children && node.children.length > 0) {
        if (!this.validate(node.children)) {
          return false;
        }
      }
    }
    return true;
  }
};

// src/shortcodes/transformer.ts
var Transformer = class {
  transform(ast) {
    return ast.map((node) => node.content || "").join("\n");
  }
};

// src/shortcodes/registry.ts
var ShortcodeManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.tokenizer = new Tokenizer();
    this.parser = new Parser();
    this.transformer = new Transformer();
  }
  checkForShortcodes(editor) {
  }
  showHelpModal() {
  }
};

// src/utils/errorHandler.ts
var import_obsidian7 = require("obsidian");
var ErrorHandler = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  handleError(error, context) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`${context}: ${message}`);
    new import_obsidian7.Notice(`${context}: ${message}`);
  }
  showNotice(message, duration) {
    new import_obsidian7.Notice(message, duration);
  }
  showSuccess(message) {
    new import_obsidian7.Notice(message, 3e3);
  }
  showWarning(message) {
    new import_obsidian7.Notice(`\u26A0\uFE0F ${message}`, 5e3);
  }
};

// src/main.ts
init_constants();
var LinkPlugin = class extends import_obsidian8.Plugin {
  async onload() {
    console.log("Loading Link Plugin...");
    try {
      DateService.initialize();
      await this.loadSettings();
      this.errorHandler = new ErrorHandler(this);
      this.directoryManager = new DirectoryManager(this);
      this.journalManager = new JournalManager(this);
      this.linkManager = new LinkManager(this);
      this.shortcodeManager = new ShortcodeManager(this);
      this.ribbonManager = new RibbonManager(this);
      this.addSettingTab(new SettingsTab(this.app, this));
      this.ribbonManager.initializeRibbon();
      this.registerCommands();
      this.registerEventHandlers();
      await this.directoryManager.rebuildDirectoryStructure();
      await this.journalManager.checkAndCreateCurrentMonthFolder();
      console.log("Link Plugin loaded successfully");
    } catch (error) {
      console.error("Failed to load Link Plugin:", error);
      if (this.errorHandler) {
        this.errorHandler.handleError(error, "Plugin initialization failed");
      }
    }
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = validateSettings(loadedData || {});
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.ribbonManager) {
      this.ribbonManager.updateButtonStates();
    }
  }
  registerCommands() {
    this.addCommand({
      id: COMMAND_IDS.CREATE_LINKED_NOTE,
      name: "Create Linked Note from Selection",
      editorCallback: (editor, view) => {
        try {
          const selection = editor.getSelection();
          if (selection) {
            if ("previewMode" in view) {
              this.linkManager.createLinkedNote(selection, editor, view);
            } else {
              this.errorHandler.handleError(new Error("Invalid view type"), "Please use this command in a markdown view");
            }
          } else {
            this.errorHandler.handleError(new Error("No text selected"), "Please select text to create a linked note");
          }
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create linked note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.REBUILD_DIRECTORY,
      name: "Rebuild Directory Structure",
      callback: () => {
        try {
          this.directoryManager.rebuildDirectoryStructure();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to rebuild directory structure");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.OPEN_TODAY_JOURNAL,
      name: "Open Today's Journal",
      callback: () => {
        try {
          this.journalManager.openTodayJournal();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to open today's journal");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_TODAY_NOTE,
      name: "Create Today's Daily Note",
      callback: async () => {
        try {
          const file = await this.journalManager.createTodayNote();
          const leaf = this.app.workspace.getLeaf();
          await leaf.openFile(file);
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create today's note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_MONTHLY_FOLDERS,
      name: "Create Monthly Folders for Current Year",
      callback: async () => {
        try {
          const startOfYear = DateService.startOfYear();
          const endOfYear = DateService.endOfYear();
          await this.journalManager.createMonthlyFoldersForRange(startOfYear, endOfYear);
          this.errorHandler.showNotice("Monthly folders created for current year");
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create monthly folders");
        }
      }
    });
    this.addCommand({
      id: "show-shortcode-help",
      name: "Show Shortcode Help",
      callback: () => {
        try {
          this.shortcodeManager.showHelpModal();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to show shortcode help");
        }
      }
    });
    this.addCommand({
      id: "show-ribbon-actions",
      name: "Show Ribbon Quick Actions",
      callback: () => {
        try {
          this.ribbonManager.showQuickActionsMenu();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to show ribbon actions");
        }
      }
    });
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.workspace.on("editor-change", (editor) => {
        if (this.settings.shortcodeEnabled) {
          this.shortcodeManager.checkForShortcodes(editor);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if ("stat" in file && "basename" in file && "extension" in file && file.path.includes(this.settings.journalRootFolder)) {
          this.journalManager.updateJournalLinks(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (this.settings.debugMode) {
          console.log("File modified:", file.path);
        }
      })
    );
  }
  onunload() {
    console.log("Link Plugin unloaded");
    if (this.ribbonManager) {
      this.ribbonManager.cleanup();
    }
  }
};
