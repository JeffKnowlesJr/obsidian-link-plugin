/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinkPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/constants.ts
var DEFAULT_BASE_FOLDER = "Link";
var DEFAULT_DIRECTORIES = [
  "journal"
];
var DEFAULT_TEMPLATES_PATH = "templates";
var DAILY_NOTES_TEMPLATE_NAME = "Daily Notes Template.md";
var COMMAND_IDS = {
  CREATE_LINKED_NOTE: "create-linked-note",
  REBUILD_DIRECTORY: "rebuild-directory-structure",
  OPEN_TODAY_JOURNAL: "open-today-journal",
  CREATE_TODAY_NOTE: "create-today-note",
  CREATE_FUTURE_NOTE: "create-future-note",
  CREATE_MONTHLY_FOLDERS: "create-monthly-folders",
  EXPAND_SHORTCODE: "expand-shortcode",
  SHOW_LINK_SUGGESTIONS: "show-link-suggestions"
};
var DATE_FORMATS = {
  DEFAULT_JOURNAL: "YYYY-MM-DD dddd",
  ISO_DATE: "YYYY-MM-DD",
  FOLDER_FORMAT: "YYYY/MM"
};
var DEFAULT_TEMPLATES = {
  JOURNAL: `# {{date}}

## Daily Log

## Tasks
- [ ] 

## Notes

## Reflection

---
Previous: {{previous}}
Next: {{next}}
`,
  NOTE: `---
title: {{title}}
created: {{date}}
source: {{source}}
tags: []
---

# {{title}}

`
};
var REGEX_PATTERNS = {
  WIKI_LINK: /\[\[(.*?)\]\]/g,
  SHORTCODE: /[\w>+*{}\[\]()]+$/,
  DATE_FILENAME: /\d{4}-\d{2}-\d{2}/,
  INVALID_FILENAME_CHARS: /[\\/:*?"<>|]/g
};

// src/settings/directorySettings.ts
var DirectorySettings = class {
  static getDefaults() {
    return {
      baseFolder: DEFAULT_BASE_FOLDER,
      // Creates all directories under 'Link/' by default
      directoryStructure: DEFAULT_DIRECTORIES,
      restrictedDirectories: [],
      documentDirectory: "journal",
      // Simplified to journal only
      journalRootFolder: "journal"
      // Updated to match README structure
    };
  }
  static validate(settings) {
    const validated = {};
    if (settings.baseFolder !== void 0 && typeof settings.baseFolder === "string") {
      const trimmed = settings.baseFolder.trim();
      validated.baseFolder = trimmed === "" ? "" : trimmed;
    }
    if (settings.directoryStructure && Array.isArray(settings.directoryStructure)) {
      validated.directoryStructure = settings.directoryStructure;
    }
    if (settings.restrictedDirectories && Array.isArray(settings.restrictedDirectories)) {
      validated.restrictedDirectories = settings.restrictedDirectories;
    }
    if (settings.documentDirectory && typeof settings.documentDirectory === "string") {
      validated.documentDirectory = settings.documentDirectory;
    }
    if (settings.journalRootFolder && typeof settings.journalRootFolder === "string") {
      validated.journalRootFolder = settings.journalRootFolder;
    }
    return validated;
  }
};

// src/settings/journalSettings.ts
var JournalSettings = class {
  static getDefaults() {
    return {
      journalDateFormat: "YYYY-MM-DD dddd",
      journalFolderFormat: DATE_FORMATS.FOLDER_FORMAT,
      journalYearFormat: "YYYY",
      journalMonthFormat: "MM-MMMM",
      // Changed to MM-MMMM for "07-July" format
      journalTemplate: DEFAULT_TEMPLATES.JOURNAL,
      simpleJournalMode: false
      // Default to dynamic monthly folders
    };
  }
  static validate(settings) {
    const validated = {};
    if (settings.journalDateFormat && typeof settings.journalDateFormat === "string") {
      validated.journalDateFormat = settings.journalDateFormat;
    }
    if (settings.journalFolderFormat && typeof settings.journalFolderFormat === "string") {
      validated.journalFolderFormat = settings.journalFolderFormat;
    }
    if (settings.journalTemplate && typeof settings.journalTemplate === "string") {
      validated.journalTemplate = settings.journalTemplate;
    }
    if (typeof settings.simpleJournalMode === "boolean") {
      validated.simpleJournalMode = settings.simpleJournalMode;
    }
    return validated;
  }
  static isValidDateFormat(format) {
    try {
      const validTokens = ["YYYY", "MM", "DD", "dddd", "MMM", "MMMM"];
      return validTokens.some((token) => format.includes(token));
    } catch (e) {
      return false;
    }
  }
};

// src/settings/noteSettings.ts
var NoteSettings = class {
  static getDefaults() {
    return {
      noteTemplate: DEFAULT_TEMPLATES.NOTE
    };
  }
  static validate(settings) {
    const validated = {};
    if (settings.noteTemplate && typeof settings.noteTemplate === "string") {
      validated.noteTemplate = settings.noteTemplate;
    }
    return validated;
  }
  static validateTemplate(template) {
    const errors = [];
    const requiredVars = ["{{title}}"];
    const missingVars = requiredVars.filter((varName) => !template.includes(varName));
    if (missingVars.length > 0) {
      errors.push(`Missing required template variables: ${missingVars.join(", ")}`);
    }
    const templateVarPattern = /\{\{[^}]*\}\}/g;
    const matches = template.match(templateVarPattern);
    if (matches) {
      matches.forEach((match) => {
        if (!match.endsWith("}}")) {
          errors.push(`Malformed template variable: ${match}`);
        }
      });
    }
    return {
      isValid: errors.length === 0,
      errors
    };
  }
};

// src/settings/generalSettings.ts
var GeneralSettings = class {
  static getDefaults() {
    return {
      debugMode: false,
      fileSorting: {
        enableAutoSorting: false,
        sortOnFileCreate: false,
        sortOnFileModify: false
      }
    };
  }
  static validate(settings) {
    const validated = {};
    if (typeof settings.debugMode === "boolean") {
      validated.debugMode = settings.debugMode;
    }
    return validated;
  }
  static getDebugInfo() {
    return {
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      language: navigator.language
    };
  }
};

// src/settings/settingsValidator.ts
function validateSettings(settings) {
  const validatedSettings = {
    ...DirectorySettings.getDefaults(),
    ...JournalSettings.getDefaults(),
    ...NoteSettings.getDefaults(),
    // ...ShortcodeSettings.getDefaults(), // Deprecated - moved to quarantine
    ...GeneralSettings.getDefaults()
  };
  const directoryValidation = DirectorySettings.validate(settings);
  const journalValidation = JournalSettings.validate(settings);
  const noteValidation = NoteSettings.validate(settings);
  const generalValidation = GeneralSettings.validate(settings);
  Object.assign(
    validatedSettings,
    directoryValidation,
    journalValidation,
    noteValidation,
    // shortcodeValidation, // Deprecated - moved to quarantine
    generalValidation
  );
  return validatedSettings;
}

// src/settings/defaultSettings.ts
var DEFAULT_SETTINGS = {
  ...DirectorySettings.getDefaults(),
  ...JournalSettings.getDefaults(),
  ...NoteSettings.getDefaults(),
  // ...ShortcodeSettings.getDefaults(), // Deprecated - moved to quarantine
  ...GeneralSettings.getDefaults()
};

// src/managers/directoryManager.ts
var import_obsidian2 = require("obsidian");

// src/utils/pathUtils.ts
var import_obsidian = require("obsidian");
var PathUtils = class {
  static sanitizePath(path) {
    return (0, import_obsidian.normalizePath)(path.replace(/[\/:*?"<>|]/g, "").trim());
  }
  static joinPath(...segments) {
    return (0, import_obsidian.normalizePath)(segments.filter(Boolean).join("/"));
  }
};

// src/services/dateService.ts
var DateService = class {
  /**
   * Initialize the date service with Obsidian's moment instance
   * This should be called once when the plugin loads
   */
  static initialize() {
    this.moment = window.moment;
    if (!this.moment) {
      throw new Error("Obsidian moment.js not available");
    }
  }
  /**
   * Get current date/time
   */
  static now() {
    return this.moment();
  }
  /**
   * Create moment from date input
   */
  static from(input) {
    return this.moment(input);
  }
  /**
   * Create moment from date string with format
   */
  static fromFormat(input, format, strict = true) {
    return this.moment(input, format, strict);
  }
  /**
   * Format a date using the specified format
   */
  static format(date, format = "YYYY-MM-DD") {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.format(format);
  }
  /**
   * Get today's date formatted
   */
  static today(format = "YYYY-MM-DD") {
    return this.moment().format(format);
  }
  /**
   * Get current year
   */
  static currentYear() {
    return this.moment().format("YYYY");
  }
  /**
   * Get current month name
   */
  static currentMonth() {
    return this.moment().format("MMMM");
  }
  /**
   * Get start of year for given date
   */
  static startOfYear(date) {
    return (date ? this.moment(date) : this.moment()).startOf("year");
  }
  /**
   * End of year for given date
   */
  static endOfYear(date) {
    return (date ? this.moment(date) : this.moment()).endOf("year");
  }
  /**
   * Start of month for given date
   */
  static startOfMonth(date) {
    return (date ? this.moment(date) : this.moment()).startOf("month");
  }
  /**
   * End of month for given date
   */
  static endOfMonth(date) {
    return (date ? this.moment(date) : this.moment()).endOf("month");
  }
  /**
   * Add time to a date
   */
  static add(date, amount, unit) {
    return this.moment(date).add(amount, unit);
  }
  /**
   * Subtract time from a date
   */
  static subtract(date, amount, unit) {
    return this.moment(date).subtract(amount, unit);
  }
  /**
   * Check if date is valid
   */
  static isValid(date) {
    return this.moment(date).isValid();
  }
  /**
   * Check if date is same or before another date
   */
  static isSameOrBefore(date1, date2) {
    return this.moment(date1).isSameOrBefore(date2);
  }
  /**
   * Extract date from filename using format
   */
  static extractDateFromFilename(filename, format) {
    try {
      const date = this.moment(filename, format, true);
      return date.isValid() ? date : null;
    } catch (error) {
      return null;
    }
  }
  /**
   * Get journal path components for a date with custom formats
   */
  static getJournalPathComponents(date, yearFormat, monthFormat) {
    const momentDate = date ? this.moment(date) : this.moment();
    const year = momentDate.format("YYYY");
    const monthName = momentDate.format("MMMM");
    const monthNumber = momentDate.format("MM");
    const yearFolderFormat = yearFormat && yearFormat !== "y_YYYY" ? yearFormat : "YYYY";
    const monthFolderFormat = monthFormat || "MM-MMMM";
    let cleanMonthFormat = monthFolderFormat;
    if (monthFolderFormat === "MMmmmm" || monthFolderFormat === "MMMMM" || monthFolderFormat === "MMMM") {
      cleanMonthFormat = "MM-MMMM";
    }
    return {
      year,
      monthName,
      monthNumber,
      yearFolder: momentDate.format(yearFolderFormat),
      monthFolder: momentDate.format(cleanMonthFormat)
    };
  }
  /**
   * Get formatted filename for journal entry
   */
  static getJournalFilename(date, format = "YYYY-MM-DD dddd") {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.format(format);
  }
  /**
   * Get previous day
   */
  static previousDay(date) {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.subtract(1, "day");
  }
  /**
   * Get next day
   */
  static nextDay(date) {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.add(1, "day");
  }
  /**
   * Create date range iterator
   */
  static *dateRange(startDate, endDate, unit = "day") {
    const current = this.moment(startDate);
    const end = this.moment(endDate);
    while (current.isSameOrBefore(end)) {
      yield this.moment(current);
      current.add(1, unit);
    }
  }
  /**
   * Get monthly folder path for a date with custom formats
   */
  static getMonthlyFolderPath(basePath, date, yearFormat, monthFormat) {
    const components = this.getJournalPathComponents(date, yearFormat, monthFormat);
    return `${basePath}/${components.yearFolder}/${components.monthFolder}`;
  }
  /**
   * Get full journal file path
   */
  static getJournalFilePath(basePath, date, format = "YYYY-MM-DD dddd") {
    const monthlyPath = this.getMonthlyFolderPath(basePath, date);
    const filename = this.getJournalFilename(date, format);
    return `${monthlyPath}/${filename}.md`;
  }
  /**
   * Validate date format string
   */
  static isValidFormat(format) {
    try {
      const testDate = this.moment();
      testDate.format(format);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Get debug information about the moment instance
   */
  static getDebugInfo() {
    var _a;
    return {
      available: !!this.moment,
      version: ((_a = this.moment) == null ? void 0 : _a.version) || "unknown",
      type: typeof this.moment
    };
  }
};

// src/managers/directoryManager.ts
var DirectoryManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates the base directory structure according to settings
   * All directories are created under the configured baseFolder to prevent collisions
   */
  async rebuildDirectoryStructure() {
    const { vault } = this.plugin.app;
    const { baseFolder, directoryStructure } = this.plugin.settings;
    try {
      const basePath = baseFolder ? (0, import_obsidian2.normalizePath)(baseFolder) : "";
      if (basePath) {
        await this.getOrCreateDirectory(basePath);
        console.log(`Created base directory: ${basePath}`);
      } else {
        console.log("Using vault root as base directory");
      }
      for (const dirName of directoryStructure || DEFAULT_DIRECTORIES) {
        const dirPath = basePath ? PathUtils.joinPath(basePath, dirName) : dirName;
        await this.getOrCreateDirectory(dirPath);
        console.log(`Created directory: ${dirPath}`);
      }
      await this.createJournalStructure(basePath);
    } catch (error) {
      throw new Error(`Failed to rebuild directory structure: ${error}`);
    }
  }
  /**
   * Creates journal structure - simple or dynamic based on single setting
   */
  async createJournalStructure(basePath) {
    const journalPath = PathUtils.joinPath(basePath, "journal");
    await this.getOrCreateDirectory(journalPath);
    console.log(`Created journal directory: ${journalPath}`);
    if (!this.plugin.settings.simpleJournalMode) {
      const currentDate = DateService.now();
      const currentYear = DateService.format(currentDate, "YYYY");
      const currentMonth = DateService.format(currentDate, "MM-MMMM");
      const currentYearPath = PathUtils.joinPath(journalPath, currentYear);
      const currentMonthPath = PathUtils.joinPath(currentYearPath, currentMonth);
      await this.getOrCreateDirectory(currentYearPath);
      await this.getOrCreateDirectory(currentMonthPath);
      console.log(`Created current month directory: ${currentMonthPath}`);
      console.log("Current month journal structure created");
    }
  }
  /**
   * Creates templates directory and copies the daily notes template when enabled
   */
  async setupTemplates() {
    try {
      const { baseFolder } = this.plugin.settings;
      const templatesPath = baseFolder ? PathUtils.joinPath(baseFolder, DEFAULT_TEMPLATES_PATH) : DEFAULT_TEMPLATES_PATH;
      await this.getOrCreateDirectory(templatesPath);
      console.log(`Created templates directory: ${templatesPath}`);
      const templateFilePath = PathUtils.joinPath(templatesPath, DAILY_NOTES_TEMPLATE_NAME);
      const { vault } = this.plugin.app;
      if (!vault.getAbstractFileByPath(templateFilePath)) {
        const templateContent = await this.getDailyNotesTemplateContent();
        await vault.create(templateFilePath, templateContent);
        console.log(`Created template file: ${templateFilePath}`);
      } else {
        console.log(`Template already exists: ${templateFilePath}`);
      }
    } catch (error) {
      throw new Error(`Failed to setup templates: ${error}`);
    }
  }
  /**
   * Gets the daily notes template content from the plugin assets
   */
  async getDailyNotesTemplateContent() {
    return `---
previous: '[[<% tp.date.now("YYYY-MM-DD dddd", -1) %>]]'
next: '[[<% tp.date.now("YYYY-MM-DD dddd", 1) %>]]'
tags:
  - \u2600\uFE0F
resources: []
stakeholders:
---
---
## Log

### Routine Checklist

- [ ] Open Daily Note
- [ ] **Daily Checks**
	- [ ] Bed and Clothes \u{1F6CF}\uFE0F\u{1F9FA}
		- [ ] Self Care\u{1F6C0}\u{1F9F4}
	- [ ] Clean Kitchen
		- [ ] Make Breakfast \u{1F37D}\u2728
	- [ ] Pet Care \u{1F415}\u{1F6B6}\u{1F3FB}\u200D\u2642\uFE0F
		- [ ] Wear Watch \u231A\uFE0F
	- [ ] Get Focused \u{1F5A5}\uFE0F\u{1F48A}
		- [ ] Put [Calendar](https://calendar.google.com) \u{1F4C6}
	- [ ] Check [Mail](https://mail.google.com) \u2709\uFE0F 
		- [ ] Reviews [[Yearly List]] \u2705
	- [ ] Review [July Log](Yearly%20Log.md#July) \u{1F5D3}\uFE0F

---`;
  }
  /**
   * Gets a directory path, creating it if it doesn't exist
   * Handles both absolute paths and paths relative to the base folder
   */
  async getOrCreateDirectory(path) {
    const { vault } = this.plugin.app;
    const normalizedPath = (0, import_obsidian2.normalizePath)(path);
    const existingFolder = vault.getAbstractFileByPath(normalizedPath);
    if (existingFolder instanceof import_obsidian2.TFolder) {
      return existingFolder;
    }
    const pathParts = normalizedPath.split("/");
    let currentPath = "";
    for (const part of pathParts) {
      if (!part)
        continue;
      currentPath += (currentPath ? "/" : "") + part;
      const folder = vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await vault.createFolder(currentPath);
      } else if (!(folder instanceof import_obsidian2.TFolder)) {
        throw new Error(`Path ${currentPath} exists but is not a folder`);
      }
    }
    return vault.getAbstractFileByPath(normalizedPath);
  }
  /**
   * Gets the full path for a directory within the plugin's base folder
   */
  getPluginDirectoryPath(relativePath) {
    const { baseFolder } = this.plugin.settings;
    return baseFolder ? PathUtils.joinPath(baseFolder, relativePath) : relativePath;
  }
  /**
   * Gets the journal directory path
   */
  getJournalPath() {
    const { baseFolder, journalRootFolder } = this.plugin.settings;
    return baseFolder ? PathUtils.joinPath(baseFolder, journalRootFolder) : journalRootFolder;
  }
  /**
   * Applies a directory template to create structured folders
   */
  async applyDirectoryTemplate(basePath, template) {
    for (const [key, value] of Object.entries(template)) {
      const dirPath = PathUtils.joinPath(basePath, key);
      await this.getOrCreateDirectory(dirPath);
      if (value && typeof value === "object") {
        await this.applyDirectoryTemplate(dirPath, value);
      }
    }
  }
  /**
   * Validates if a given path is within allowed directories
   */
  isValidPath(path) {
    const normalizedPath = (0, import_obsidian2.normalizePath)(path);
    const { restrictedDirectories } = this.plugin.settings;
    if (!restrictedDirectories || restrictedDirectories.length === 0) {
      return true;
    }
    return !restrictedDirectories.some((dir) => {
      const normalizedDir = (0, import_obsidian2.normalizePath)(dir);
      return normalizedPath === normalizedDir || normalizedPath.startsWith(normalizedDir + "/");
    });
  }
  /**
   * Lists all directories in the vault
   */
  getAllDirectories() {
    const { vault } = this.plugin.app;
    return vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian2.TFolder);
  }
};

// src/managers/journalManager.ts
var import_obsidian3 = require("obsidian");
var JournalManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates or opens a journal entry for the specified date
   * Automatically creates monthly folders as needed
   */
  async createOrOpenJournalEntry(date) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    await this.ensureMonthlyFolderExists(date);
    const monthlyFolderPath = this.getMonthlyFolderPath(date);
    const fileName = DateService.getJournalFilename(date, journalDateFormat);
    const filePath = (0, import_obsidian3.normalizePath)(`${monthlyFolderPath}/${fileName}.md`);
    let file = vault.getAbstractFileByPath(filePath);
    if (!file) {
      file = await vault.create(filePath, "");
      console.log(`Created daily note: ${filePath}`);
    }
    return file;
  }
  /**
   * Ensures the monthly folder exists for the given date
   * Creates the folder structure if it doesn't exist
   */
  async ensureMonthlyFolderExists(date) {
    const monthlyFolderPath = this.getMonthlyFolderPath(date);
    const monthName = DateService.format(date, "MMMM YYYY");
    const folderExists = await this.plugin.app.vault.adapter.exists(monthlyFolderPath);
    if (!folderExists) {
      await this.plugin.directoryManager.getOrCreateDirectory(monthlyFolderPath);
      console.log(`\u2705 Created monthly folder for ${monthName}: ${monthlyFolderPath}`);
    } else {
      console.log(`Monthly folder for ${monthName} already exists: ${monthlyFolderPath}`);
    }
  }
  /**
   * Gets the monthly folder path for a given date
   * Uses simple mode OR dynamic folders based on single setting
   */
  getMonthlyFolderPath(date) {
    const journalBasePath = this.plugin.directoryManager.getJournalPath();
    if (this.plugin.settings.simpleJournalMode) {
      return journalBasePath;
    }
    return DateService.getMonthlyFolderPath(
      journalBasePath,
      date,
      this.plugin.settings.journalYearFormat,
      this.plugin.settings.journalMonthFormat
    );
  }
  /**
   * Creates a daily note for today if it doesn't exist
   * Automatically handles monthly folder creation
   */
  async createTodayNote() {
    const today = DateService.now();
    return await this.createOrOpenJournalEntry(today);
  }
  /**
   * Creates a daily note for a future date
   * Automatically creates monthly folders as needed
   */
  async createFutureDailyNote(date) {
    const targetDate = DateService.from(date);
    console.log(`Creating future daily note for: ${DateService.format(targetDate, "YYYY-MM-DD")}`);
    const file = await this.createOrOpenJournalEntry(targetDate);
    const monthlyPath = this.getMonthlyFolderPath(targetDate);
    console.log(`Future note created in: ${monthlyPath}`);
    return file;
  }
  /**
   * Generate content for a journal entry
   */
  async generateJournalContent(date) {
    const { journalTemplate, journalDateFormat } = this.plugin.settings;
    const previousDay = DateService.previousDay(date);
    const nextDay = DateService.nextDay(date);
    const previousLink = `[[${DateService.format(previousDay, journalDateFormat)}]]`;
    const nextLink = `[[${DateService.format(nextDay, journalDateFormat)}]]`;
    const currentDate = DateService.format(date, "YYYY-MM-DD");
    const title = DateService.format(date, journalDateFormat);
    if (journalTemplate) {
      return journalTemplate.replace(/{{date}}/g, currentDate).replace(/{{title}}/g, title).replace(/{{previous}}/g, previousLink).replace(/{{next}}/g, nextLink);
    }
    return `---
date: ${currentDate}
previous: ${previousLink}
next: ${nextLink}
tags:
  - journal
---

# ${title}

## Daily Log

## Tasks
- [ ] 

## Notes

## Reflection

---
Previous: ${previousLink} | Next: ${nextLink}
`;
  }
  /**
   * Opens the journal entry for today
   * Creates monthly folder and daily note if they don't exist
   */
  async openTodayJournal() {
    const today = DateService.now();
    const file = await this.createOrOpenJournalEntry(today);
    const leaf = this.plugin.app.workspace.getLeaf();
    await leaf.openFile(file);
  }
  /**
   * Checks if we need to create a new monthly folder
   * Called when the plugin loads, when creating notes, or when date changes
   */
  async checkAndCreateCurrentMonthFolder() {
    const currentDate = DateService.now();
    await this.ensureMonthlyFolderExists(currentDate);
    const daysUntilNextMonth = DateService.endOfMonth(currentDate).diff(currentDate, "days");
    if (daysUntilNextMonth <= 2) {
      const nextMonth = DateService.add(currentDate, 1, "month");
      await this.ensureMonthlyFolderExists(nextMonth);
      console.log("Pre-created next month folder (end of month detected)");
    }
  }
  /**
   * Creates monthly folders for a range of dates
   * Useful for batch creation or setup
   */
  async createMonthlyFoldersForRange(startDate, endDate) {
    let current = DateService.startOfMonth(startDate);
    const end = DateService.endOfMonth(endDate);
    while (DateService.isSameOrBefore(current, end)) {
      await this.ensureMonthlyFolderExists(current);
      current = DateService.add(current, 1, "month");
    }
  }
  /**
   * Opens journal entry for a specific date
   */
  async openJournalForDate(date) {
    const momentDate = DateService.from(date);
    const file = await this.createOrOpenJournalEntry(momentDate);
    const leaf = this.plugin.app.workspace.getLeaf();
    await leaf.openFile(file);
  }
  /**
   * Updates links between journal entries
   */
  async updateJournalLinks(file) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    const fileDate = DateService.extractDateFromFilename(file.basename, journalDateFormat || "YYYY-MM-DD dddd");
    if (!fileDate)
      return;
    const content = await vault.read(file);
    const previousDay = DateService.previousDay(fileDate);
    const nextDay = DateService.nextDay(fileDate);
    const previousFileName = DateService.format(previousDay, journalDateFormat);
    const nextFileName = DateService.format(nextDay, journalDateFormat);
    const updatedContent = content.replace(/previous: '\[\[(.*?)\]\]'/g, `previous: '[[${previousFileName}]]'`).replace(/next: '\[\[(.*?)\]\]'/g, `next: '[[${nextFileName}]]'`);
    if (updatedContent !== content) {
      await vault.modify(file, updatedContent);
    }
  }
  /**
   * Get journal entries for a date range
   */
  async getJournalEntries(startDate, endDate) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    const entries = [];
    let current = DateService.from(startDate);
    while (DateService.isSameOrBefore(current, endDate)) {
      const filePath = DateService.getJournalFilePath(
        this.plugin.directoryManager.getJournalPath(),
        current,
        journalDateFormat
      );
      const file = vault.getAbstractFileByPath(filePath);
      if (file) {
        entries.push({
          date: DateService.format(current, "YYYY-MM-DD"),
          path: filePath,
          title: DateService.format(current, journalDateFormat),
          previous: DateService.format(DateService.previousDay(current), "YYYY-MM-DD"),
          next: DateService.format(DateService.nextDay(current), "YYYY-MM-DD")
        });
      }
      current = DateService.add(current, 1, "day");
    }
    return entries;
  }
};

// src/managers/linkManager.ts
var import_obsidian4 = require("obsidian");
var CustomLinkSuggest = class extends import_obsidian4.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor) {
    const line = editor.getLine(cursor.line);
    const beforeCursor = line.substring(0, cursor.ch);
    const match = beforeCursor.match(/\[\[([^\]]*?)$/);
    if (match) {
      return {
        start: { line: cursor.line, ch: cursor.ch - match[1].length },
        end: cursor,
        query: match[1]
      };
    }
    return null;
  }
  async getSuggestions(context) {
    const query = context.query.toLowerCase();
    const suggestions = [];
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path.toLowerCase().includes(query) || file.basename.toLowerCase().includes(query)) {
        suggestions.push({
          path: file.path,
          displayText: file.path,
          isCreate: false
        });
      }
    }
    if (query.length > 0 && !suggestions.some((s) => s.path.toLowerCase() === query.toLowerCase() + ".md")) {
      const baseFolder = this.plugin.settings.baseFolder || "LinkPlugin";
      if (query.includes("/") || query.startsWith(baseFolder.toLowerCase())) {
        suggestions.unshift({
          path: query.endsWith(".md") ? query : query + ".md",
          displayText: `Create note: ${query}`,
          isCreate: true
        });
      }
    }
    return suggestions.slice(0, 10);
  }
  renderSuggestion(suggestion, el) {
    el.createEl("div", {
      text: suggestion.displayText,
      cls: suggestion.isCreate ? "link-suggest-create" : "link-suggest-existing"
    });
    if (suggestion.isCreate) {
      el.addClass("mod-complex");
      const icon = el.createEl("div", { cls: "suggestion-flair" });
      icon.createEl("span", { text: "+ Create", cls: "suggestion-note" });
    }
  }
  selectSuggestion(suggestion) {
    var _a;
    if (suggestion.isCreate) {
      this.createFileFromPath(suggestion.path);
    }
    const linkText = `[[${suggestion.path.replace(".md", "")}]]`;
    (_a = this.context) == null ? void 0 : _a.editor.replaceRange(linkText, this.context.start, this.context.end);
  }
  async createFileFromPath(path) {
    const { vault } = this.app;
    const normalizedPath = (0, import_obsidian4.normalizePath)(path);
    const dirPath = normalizedPath.substring(0, normalizedPath.lastIndexOf("/"));
    if (dirPath) {
      await this.plugin.directoryManager.getOrCreateDirectory(dirPath);
    }
    const existingFile = vault.getAbstractFileByPath(normalizedPath);
    if (!existingFile) {
      const fileName = normalizedPath.substring(normalizedPath.lastIndexOf("/") + 1).replace(".md", "");
      const content = this.generateNoteContent(fileName);
      await vault.create(normalizedPath, content);
    }
  }
  generateNoteContent(title) {
    const { noteTemplate } = this.plugin.settings;
    const currentDate = new Date().toISOString().split("T")[0];
    if (noteTemplate) {
      return noteTemplate.replace(/{{title}}/g, title).replace(/{{date}}/g, currentDate).replace(/{{source}}/g, "");
    }
    return `---
title: ${title}
created: ${currentDate}
tags: []
---

# ${title}

`;
  }
};
var LinkManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.linkSuggest = new CustomLinkSuggest(plugin);
  }
  /**
   * Initialize the link suggestion system
   */
  initialize() {
    if (this.plugin.settings.fileSorting.sortOnFileCreate) {
      this.plugin.registerEditorSuggest(this.linkSuggest);
    }
  }
  /**
   * Cleanup the link suggestion system
   */
  cleanup() {
  }
  /**
   * Create a new note from selected text and link to it
   */
  async createLinkedNote(selection, editor, view) {
    const { vault } = this.plugin.app;
    const currentFile = view.file;
    if (!currentFile) {
      throw new Error("No active file found");
    }
    const fileName = this.sanitizeFileName(selection);
    const directoryPath = this.determineTargetDirectory(fileName);
    const filePath = (0, import_obsidian4.normalizePath)(`${directoryPath}/${fileName}.md`);
    let file = vault.getAbstractFileByPath(filePath);
    if (!file) {
      await this.plugin.directoryManager.getOrCreateDirectory(directoryPath);
      const content = this.generateNoteContent(selection, currentFile);
      file = await vault.create(filePath, content);
    }
    const linkText = this.generateLinkText(fileName, directoryPath, currentFile);
    editor.replaceSelection(linkText);
    const leaf = this.plugin.app.workspace.activeLeaf;
    if (leaf) {
      await leaf.openFile(file);
    }
  }
  /**
   * Determine the appropriate directory for a new note
   */
  determineTargetDirectory(title) {
    const { documentDirectory } = this.plugin.settings;
    const keywords = title.toLowerCase();
    if (keywords.includes("project") || keywords.includes("work")) {
      return "Journal";
    }
    return documentDirectory || "Documents";
  }
  /**
   * Generate content for a new linked note
   */
  generateNoteContent(title, sourceFile) {
    const { noteTemplate } = this.plugin.settings;
    const currentDate = new Date().toISOString().split("T")[0];
    if (noteTemplate) {
      return noteTemplate.replace(/{{title}}/g, title).replace(/{{date}}/g, currentDate).replace(/{{source}}/g, `[[${sourceFile.basename}]]`);
    }
    return `---
title: ${title}
created: ${currentDate}
source: [[${sourceFile.basename}]]
tags: []
---

# ${title}

`;
  }
  /**
   * Generate appropriate link text based on directory structure
        * Supports directory-relative links like [[/journal/nesting]]
   */
  generateLinkText(fileName, targetDirectory, currentFile) {
    var _a;
    const currentFileDir = ((_a = currentFile.parent) == null ? void 0 : _a.path) || "";
    const baseFolder = this.plugin.settings.baseFolder || "LinkPlugin";
    if (targetDirectory !== currentFileDir) {
      if (targetDirectory.startsWith(baseFolder)) {
        const relativePath = targetDirectory.replace(baseFolder + "/", "");
        return `[[/${relativePath}/${fileName}]]`;
      } else {
        return `[[/${targetDirectory}/${fileName}]]`;
      }
    }
    return `[[${fileName}]]`;
  }
  /**
   * Sanitize a string for use as a filename
   */
  sanitizeFileName(input) {
    return input.replace(REGEX_PATTERNS.INVALID_FILENAME_CHARS, "").replace(/\s+/g, " ").trim().substring(0, 100);
  }
  /**
   * Find all links in a file
   */
  async findLinksInFile(file) {
    const { vault } = this.plugin.app;
    const content = await vault.read(file);
    const links = [];
    let match;
    while ((match = REGEX_PATTERNS.WIKI_LINK.exec(content)) !== null) {
      links.push(match[1]);
    }
    return links;
  }
  /**
   * Find all backlinks to a file
   */
  async findBacklinks(file) {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const backlinks = [];
    for (const potentialSource of files) {
      if (potentialSource.path === file.path)
        continue;
      const links = await this.findLinksInFile(potentialSource);
      if (links.includes(file.basename)) {
        backlinks.push(potentialSource);
      }
    }
    return backlinks;
  }
  /**
   * Find broken links in the vault
   */
  async findBrokenLinks() {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const brokenLinksData = [];
    for (const file of files) {
      const links = await this.findLinksInFile(file);
      const brokenLinks = [];
      for (const link of links) {
        const linkedFile = vault.getAbstractFileByPath(`${link}.md`) || vault.getAbstractFileByPath(link);
        if (!linkedFile) {
          brokenLinks.push(link);
        }
      }
      if (brokenLinks.length > 0) {
        brokenLinksData.push({ file, brokenLinks });
      }
    }
    return brokenLinksData;
  }
  /**
   * Find orphaned notes (notes with no backlinks)
   */
  async findOrphanedNotes() {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const orphanedNotes = [];
    for (const file of files) {
      const backlinks = await this.findBacklinks(file);
      if (backlinks.length === 0) {
        orphanedNotes.push(file);
      }
    }
    return orphanedNotes;
  }
  /**
   * Generate link suggestions based on content similarity
   */
  async generateLinkSuggestions(file, limit = 5) {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const suggestions = [];
    const currentContent = await vault.read(file);
    const currentWords = this.extractWords(currentContent);
    for (const otherFile of files) {
      if (otherFile.path === file.path)
        continue;
      const otherContent = await vault.read(otherFile);
      const otherWords = this.extractWords(otherContent);
      const relevance = this.calculateRelevance(currentWords, otherWords);
      if (relevance > 0.1) {
        suggestions.push({
          title: otherFile.basename,
          path: otherFile.path,
          relevance,
          type: "existing"
        });
      }
    }
    return suggestions.sort((a, b) => b.relevance - a.relevance).slice(0, limit);
  }
  /**
   * Extract meaningful words from content
   */
  extractWords(content) {
    const words = /* @__PURE__ */ new Set();
    const text = content.replace(/[#*`\[\]()]/g, "").toLowerCase().split(/\s+/);
    for (const word of text) {
      if (word.length > 3 && !this.isStopWord(word)) {
        words.add(word);
      }
    }
    return words;
  }
  /**
   * Calculate relevance between two sets of words
   */
  calculateRelevance(words1, words2) {
    const intersection = new Set([...words1].filter((word) => words2.has(word)));
    const union = /* @__PURE__ */ new Set([...words1, ...words2]);
    return intersection.size / union.size;
  }
  /**
   * Check if a word is a stop word
   */
  isStopWord(word) {
    const stopWords = /* @__PURE__ */ new Set([
      "the",
      "a",
      "an",
      "and",
      "or",
      "but",
      "in",
      "on",
      "at",
      "to",
      "for",
      "of",
      "with",
      "by",
      "is",
      "are",
      "was",
      "were",
      "be",
      "been",
      "have",
      "has",
      "had",
      "do",
      "does",
      "did",
      "will",
      "would",
      "could",
      "should",
      "may",
      "might",
      "must",
      "can",
      "this",
      "that",
      "these",
      "those"
    ]);
    return stopWords.has(word);
  }
};

// src/utils/errorHandler.ts
var import_obsidian5 = require("obsidian");
var ErrorHandler = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  handleError(error, context) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`${context}: ${message}`);
    new import_obsidian5.Notice(`${context}: ${message}`);
  }
  showNotice(message, duration) {
    new import_obsidian5.Notice(message, duration);
  }
  showSuccess(message) {
    new import_obsidian5.Notice(message, 3e3);
  }
  showWarning(message) {
    new import_obsidian5.Notice(`\u26A0\uFE0F ${message}`, 5e3);
  }
};

// src/ui/ribbonManager.ts
var import_obsidian6 = require("obsidian");
var RibbonManager = class {
  constructor(plugin) {
    this.ribbonButtons = [];
    this.plugin = plugin;
  }
  /**
   * Initialize ribbon with core journal functionality only
   */
  initializeRibbon() {
    this.clearRibbon();
    this.addCreateFutureNoteButton();
    this.addSettingsButton();
    console.log("Ribbon initialized - Core journal functionality enabled");
  }
  /**
   * Add Create Future Note button - CORE FEATURE with date picker
   */
  addCreateFutureNoteButton() {
    const button = this.plugin.addRibbonIcon(
      "calendar-plus",
      "Create Future Note - Select date to create note",
      async () => {
        try {
          const selectedDate = await this.showDatePicker();
          if (selectedDate) {
            const file = await this.plugin.journalManager.createFutureDailyNote(selectedDate);
            const leaf = this.plugin.app.workspace.getLeaf();
            await leaf.openFile(file);
            const formattedDate = DateService.format(DateService.from(selectedDate), "YYYY-MM-DD");
            this.showSuccess(`Created future note for ${formattedDate}`);
          }
        } catch (error) {
          this.plugin.errorHandler.handleError(error, "Failed to create future note");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Show date picker modal for future note creation - FIXED MODAL API
   */
  async showDatePicker() {
    return new Promise((resolve) => {
      const modal = new import_obsidian6.Modal(this.plugin.app);
      modal.setTitle("Create Future Daily Note");
      const { contentEl } = modal;
      const instructions = contentEl.createEl("p");
      instructions.textContent = "Select a date to create a daily note. This will automatically create the required monthly folders.";
      instructions.style.marginBottom = "1em";
      instructions.style.color = "var(--text-muted)";
      const dateInput = contentEl.createEl("input");
      dateInput.type = "date";
      dateInput.style.width = "100%";
      dateInput.style.padding = "8px";
      dateInput.style.marginBottom = "1em";
      dateInput.style.border = "1px solid var(--background-modifier-border)";
      dateInput.style.borderRadius = "4px";
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      dateInput.value = tomorrow.toISOString().split("T")[0];
      const buttonContainer = contentEl.createDiv();
      buttonContainer.style.display = "flex";
      buttonContainer.style.gap = "8px";
      buttonContainer.style.justifyContent = "flex-end";
      const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
      cancelButton.onclick = () => {
        modal.close();
        resolve(null);
      };
      const createButton = buttonContainer.createEl("button", {
        text: "Create Note",
        cls: "mod-cta"
      });
      createButton.onclick = () => {
        const selectedDate = dateInput.value;
        if (selectedDate) {
          modal.close();
          resolve(selectedDate);
        }
      };
      dateInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          const selectedDate = dateInput.value;
          if (selectedDate) {
            modal.close();
            resolve(selectedDate);
          }
        }
      });
      modal.scope.register([], "Escape", () => {
        modal.close();
        resolve(null);
      });
      modal.open();
      setTimeout(() => dateInput.focus(), 100);
    });
  }
  /**
   * Add Settings button
   */
  addSettingsButton() {
    const button = this.plugin.addRibbonIcon(
      "link",
      "Open Obsidian Link Journal Settings",
      () => {
        try {
          this.plugin.app.setting.open();
          this.plugin.app.setting.openTabById(this.plugin.manifest.id);
        } catch (error) {
          this.plugin.errorHandler.showNotice("Please open Settings \u2192 Community Plugins \u2192 Obsidian Link Journal to configure");
          this.plugin.errorHandler.handleError(error, "Failed to open settings automatically");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Clear all ribbon buttons
   */
  clearRibbon() {
    this.ribbonButtons.forEach((button) => button.remove());
    this.ribbonButtons = [];
  }
  /**
   * Cleanup method for plugin unload
   */
  cleanup() {
    this.clearRibbon();
  }
  /**
   * Update button states based on settings
   */
  updateButtonStates() {
    console.log("Ribbon buttons updated");
  }
  /**
   * Show quick actions menu
   */
  showQuickActionsMenu() {
    const message = `Obsidian Link Journal Quick Actions:
\u2022 Create Today's Note: Open or create today's journal
\u2022 Create Monthly Folders: Set up folder structure
\u2022 Settings: Configure journal management`;
    this.plugin.errorHandler.showNotice(message);
  }
  /**
   * Show success message
   */
  showSuccess(message) {
    this.plugin.errorHandler.showNotice(message);
  }
};

// src/ui/settingsTab.ts
var import_obsidian7 = require("obsidian");
var SettingsTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Link Plugin Settings" });
    containerEl.createEl("p", {
      text: "Simple journal management settings",
      cls: "setting-item-description"
    });
    this.addCoreSettings(containerEl);
    this.addJournalSettings(containerEl);
  }
  addCoreSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F4C1} Core Settings" });
    new import_obsidian7.Setting(containerEl).setName("Base Folder").setDesc("Root folder for journal content (empty = vault root)").addText((text) => text.setPlaceholder("Link").setValue(this.plugin.settings.baseFolder).onChange(async (value) => {
      this.plugin.settings.baseFolder = value.trim();
      await this.plugin.saveSettings();
    })).then((setting) => {
      const textComponent = setting.components[0];
      if (textComponent && textComponent.inputEl) {
        const input = textComponent.inputEl;
        const wrapper = input.parentElement;
        if (wrapper) {
          const prefix = wrapper.createSpan({ text: "/", cls: "path-prefix" });
          wrapper.insertBefore(prefix, input);
          prefix.style.marginRight = "2px";
          prefix.style.opacity = "0.6";
        }
      }
    });
    new import_obsidian7.Setting(containerEl).setName("Rebuild Journal Structure").setDesc("Recreate the journal folder structure").addButton((button) => button.setButtonText("Rebuild").onClick(async () => {
      try {
        await this.plugin.directoryManager.rebuildDirectoryStructure();
        alert("\u2705 Journal structure rebuilt successfully!\n\nJournal folder structure has been recreated in: " + this.plugin.settings.baseFolder);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        alert("\u274C Failed to rebuild journal structure.\n\nError: " + errorMessage);
        this.plugin.errorHandler.handleError(error, "Failed to rebuild journal structure");
      }
    }));
    new import_obsidian7.Setting(containerEl).setName("Setup Templates").setDesc("Create templates directory and copy Daily Notes template").addButton((button) => button.setButtonText("Setup Templates").onClick(async () => {
      try {
        await this.plugin.directoryManager.setupTemplates();
        const templatesPath = this.plugin.settings.baseFolder ? `${this.plugin.settings.baseFolder}/templates` : "templates";
        alert("\u2705 Templates setup successfully!\n\nTemplates directory and Daily Notes template created in: " + templatesPath);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        alert("\u274C Failed to setup templates.\n\nError: " + errorMessage);
        this.plugin.errorHandler.handleError(error, "Failed to setup templates");
      }
    }));
  }
  addJournalSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F4C5} Journal Settings" });
    new import_obsidian7.Setting(containerEl).setName("Simple Journal Mode").setDesc("Enable: Single journal folder | Disable: Dynamic monthly folders (2025/January/)").addToggle((toggle) => toggle.setValue(this.plugin.settings.simpleJournalMode).onChange(async (value) => {
      this.plugin.settings.simpleJournalMode = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (!this.plugin.settings.simpleJournalMode) {
      new import_obsidian7.Setting(containerEl).setName("Year Folder Format").setDesc('Format for year folders (YYYY creates "2025")').addText((text) => text.setPlaceholder("YYYY").setValue(this.plugin.settings.journalYearFormat).onChange(async (value) => {
        if (value.trim()) {
          this.plugin.settings.journalYearFormat = value.trim();
          await this.plugin.saveSettings();
        }
      }));
      new import_obsidian7.Setting(containerEl).setName("Month Folder Format").setDesc('Format for month folders (MM-MMMM creates "07-July")').addText((text) => text.setPlaceholder("MM-MMMM").setValue(this.plugin.settings.journalMonthFormat).onChange(async (value) => {
        if (value.trim()) {
          this.plugin.settings.journalMonthFormat = value.trim();
          await this.plugin.saveSettings();
        }
      }));
    }
    new import_obsidian7.Setting(containerEl).setName("Daily Note Format").setDesc("Format for daily note filenames").addText((text) => text.setPlaceholder("YYYY-MM-DD dddd").setValue(this.plugin.settings.journalDateFormat).onChange(async (value) => {
      if (value.trim()) {
        this.plugin.settings.journalDateFormat = value.trim();
        await this.plugin.saveSettings();
      }
    }));
  }
};

// src/main.ts
var LinkPlugin = class extends import_obsidian8.Plugin {
  async onload() {
    console.log("Loading Obsidian Link Journal v2.2.0 - Pure Journal Management...");
    try {
      DateService.initialize();
      await this.loadSettings();
      this.errorHandler = new ErrorHandler(this);
      this.directoryManager = new DirectoryManager(this);
      this.journalManager = new JournalManager(this);
      this.linkManager = new LinkManager(this);
      this.ribbonManager = new RibbonManager(this);
      this.addSettingTab(new SettingsTab(this.app, this));
      this.ribbonManager.initializeRibbon();
      this.linkManager.initialize();
      this.registerCommands();
      this.registerEventHandlers();
      await this.directoryManager.rebuildDirectoryStructure();
      await this.journalManager.checkAndCreateCurrentMonthFolder();
      await this.updateDailyNotesSettings();
      this.startDateChangeMonitoring();
      const debugInfo = DateService.getDebugInfo();
      console.log("DateService initialized:", debugInfo);
      console.log("Today:", DateService.today());
      console.log("Current month:", DateService.currentMonth());
      this.errorHandler.showNotice("Obsidian Link Journal loaded - Pure journal management ready!");
      console.log("Obsidian Link Journal loaded successfully - Core journal functionality enabled");
    } catch (error) {
      console.error("Failed to load Link Plugin:", error);
      if (this.errorHandler) {
        this.errorHandler.handleError(error, "Plugin initialization failed");
      }
    }
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = validateSettings(loadedData || {});
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.ribbonManager) {
      this.ribbonManager.updateButtonStates();
    }
  }
  registerCommands() {
    this.addCommand({
      id: COMMAND_IDS.CREATE_LINKED_NOTE,
      name: "Create Linked Note from Selection",
      editorCallback: (editor, view) => {
        try {
          const selection = editor.getSelection();
          if (selection) {
            if ("previewMode" in view) {
              this.linkManager.createLinkedNote(selection, editor, view);
            } else {
              this.errorHandler.handleError(new Error("Invalid view type"), "Please use this command in a markdown view");
            }
          } else {
            this.errorHandler.handleError(new Error("No text selected"), "Please select text to create a linked note");
          }
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create linked note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.REBUILD_DIRECTORY,
      name: "Rebuild Directory Structure",
      callback: () => {
        try {
          this.directoryManager.rebuildDirectoryStructure();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to rebuild directory structure");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.OPEN_TODAY_JOURNAL,
      name: "Open Today's Journal",
      callback: () => {
        try {
          this.journalManager.openTodayJournal();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to open today's journal");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_TODAY_NOTE,
      name: "Create Today's Daily Note",
      callback: async () => {
        try {
          const file = await this.journalManager.createTodayNote();
          const leaf = this.app.workspace.getLeaf();
          await leaf.openFile(file);
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create today's note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_FUTURE_NOTE,
      name: "Create Future Daily Note",
      callback: async () => {
        try {
          const dateInput = await this.promptForDate();
          if (dateInput) {
            const file = await this.journalManager.createFutureDailyNote(dateInput);
            const leaf = this.app.workspace.getLeaf();
            await leaf.openFile(file);
            this.errorHandler.showNotice(`Created future note for ${DateService.format(DateService.from(dateInput), "YYYY-MM-DD")}`);
          }
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create future note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_MONTHLY_FOLDERS,
      name: "Create Monthly Folders for Current Year",
      callback: async () => {
        try {
          const startOfYear = DateService.startOfYear();
          const endOfYear = DateService.endOfYear();
          await this.journalManager.createMonthlyFoldersForRange(startOfYear, endOfYear);
          this.errorHandler.showNotice("Monthly folders created for current year");
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create monthly folders");
        }
      }
    });
    this.addCommand({
      id: "show-ribbon-actions",
      name: "Show Ribbon Quick Actions",
      callback: () => {
        try {
          this.ribbonManager.showQuickActionsMenu();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to show ribbon actions");
        }
      }
    });
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if ("stat" in file && "basename" in file && "extension" in file && file.path.includes(this.settings.journalRootFolder)) {
          this.journalManager.updateJournalLinks(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (this.settings.debugMode && file.path.includes(this.settings.journalRootFolder)) {
          console.log("Journal file modified:", file.path);
        }
      })
    );
  }
  /**
   * Prompt user for a date input
   */
  async promptForDate() {
    return new Promise((resolve) => {
      const modal = new import_obsidian8.Modal(this.app);
      modal.setTitle("Create Future Daily Note");
      const { contentEl } = modal;
      contentEl.createEl("p", {
        text: "Select a date to create a daily note. This will automatically create the required monthly folders.",
        cls: "modal-description"
      });
      const inputContainer = contentEl.createDiv({ cls: "date-input-container" });
      const input = inputContainer.createEl("input", {
        type: "date",
        value: DateService.today(),
        cls: "date-input"
      });
      contentEl.createDiv({ cls: "date-picker-spacer" });
      const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
      const createButton = buttonContainer.createEl("button", {
        text: "Create Note",
        cls: "mod-cta"
      });
      const cancelButton = buttonContainer.createEl("button", {
        text: "Cancel"
      });
      const style = document.createElement("style");
      style.textContent = `
        .date-input-container {
          margin: 16px 0;
          position: relative;
          z-index: 1;
        }
        .date-input {
          width: 100%;
          padding: 8px 12px;
          border: 1px solid var(--background-modifier-border);
          border-radius: 4px;
          background: var(--background-primary);
          color: var(--text-normal);
          font-size: 14px;
        }
        .date-picker-spacer {
          height: 40px;
        }
        .modal-button-container {
          display: flex;
          gap: 8px;
          justify-content: flex-end;
          margin-top: 20px;
        }
        .modal-description {
          margin-bottom: 16px;
          color: var(--text-muted);
        }
      `;
      contentEl.appendChild(style);
      setTimeout(() => input.focus(), 100);
      createButton.onclick = () => {
        const dateValue = input.value;
        if (dateValue) {
          modal.close();
          resolve(dateValue);
        }
      };
      cancelButton.onclick = () => {
        modal.close();
        resolve(null);
      };
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          createButton.click();
        } else if (e.key === "Escape") {
          cancelButton.click();
        }
      });
      modal.open();
    });
  }
  /**
   * Start monitoring for date changes to automatically create new monthly folders
   */
  startDateChangeMonitoring() {
    let lastCheckedMonth = DateService.format(DateService.now(), "YYYY-MM");
    this.registerInterval(
      window.setInterval(async () => {
        try {
          const currentMonth = DateService.format(DateService.now(), "YYYY-MM");
          if (currentMonth !== lastCheckedMonth) {
            console.log(`Month changed from ${lastCheckedMonth} to ${currentMonth} - creating new monthly folder`);
            await this.journalManager.checkAndCreateCurrentMonthFolder();
            await this.updateDailyNotesSettings();
            lastCheckedMonth = currentMonth;
            const monthName = DateService.format(DateService.now(), "MMMM YYYY");
            this.errorHandler.showNotice(`\u{1F4C5} New month detected: ${monthName} folder created`);
          }
        } catch (error) {
          console.error("Error in date change monitoring:", error);
        }
      }, 60 * 60 * 1e3)
      // Check every hour
    );
    console.log("Date change monitoring started - will auto-create monthly folders");
  }
  /**
   * Update Obsidian's Daily Notes plugin settings to use our folder structure
   */
  async updateDailyNotesSettings() {
    var _a, _b, _c, _d;
    try {
      const dailyNotesPlugin = (_b = (_a = this.app.internalPlugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["daily-notes"];
      if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        const currentDate = DateService.now();
        const monthlyFolderPath = this.journalManager.getMonthlyFolderPath(currentDate);
        const dailyNotesSettings = dailyNotesPlugin.instance.options;
        dailyNotesSettings.folder = monthlyFolderPath;
        dailyNotesSettings.format = this.settings.journalDateFormat;
        console.log(`Updated Daily Notes plugin folder to: ${monthlyFolderPath}`);
        this.errorHandler.showNotice(`\u2705 Daily Notes location updated to: ${monthlyFolderPath}`);
      } else {
        const communityDailyNotes = (_d = (_c = this.app.plugins) == null ? void 0 : _c.plugins) == null ? void 0 : _d["daily-notes"];
        if (communityDailyNotes) {
          const currentDate = DateService.now();
          const monthlyFolderPath = this.journalManager.getMonthlyFolderPath(currentDate);
          communityDailyNotes.settings.folder = monthlyFolderPath;
          communityDailyNotes.settings.format = this.settings.journalDateFormat;
          await communityDailyNotes.saveSettings();
          console.log(`Updated Community Daily Notes plugin folder to: ${monthlyFolderPath}`);
          this.errorHandler.showNotice(`\u2705 Daily Notes location updated to: ${monthlyFolderPath}`);
        } else {
          console.log("Daily Notes plugin not found or not enabled - using plugin folder structure only");
          this.errorHandler.showNotice("\u26A0\uFE0F Daily Notes plugin not found - notes created in plugin folder only");
        }
      }
    } catch (error) {
      console.log("Daily Notes integration skipped:", error instanceof Error ? error.message : String(error));
    }
  }
  onunload() {
    console.log("Obsidian Link Journal unloaded");
    if (this.linkManager) {
      this.linkManager.cleanup();
    }
    if (this.ribbonManager) {
      this.ribbonManager.cleanup();
    }
  }
};
