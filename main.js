/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinkPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/constants.ts
var DEFAULT_BASE_FOLDER = "Link";
var DEFAULT_DIRECTORIES = [
  "journal",
  "templates",
  "reference"
];
var DEFAULT_TEMPLATES_PATH = "templates";
var DAILY_NOTES_TEMPLATE_NAME = "Daily Notes Template.md";
var COMMAND_IDS = {
  CREATE_LINKED_NOTE: "create-linked-note",
  REBUILD_DIRECTORY: "rebuild-directory-structure",
  OPEN_TODAY_JOURNAL: "open-today-journal",
  CREATE_TODAY_NOTE: "create-today-note",
  CREATE_FUTURE_NOTE: "create-future-note",
  CREATE_MONTHLY_FOLDERS: "create-monthly-folders",
  EXPAND_SHORTCODE: "expand-shortcode",
  SHOW_LINK_SUGGESTIONS: "show-link-suggestions"
};
var DATE_FORMATS = {
  DEFAULT_JOURNAL: "YYYY-MM-DD dddd",
  ISO_DATE: "YYYY-MM-DD",
  FOLDER_FORMAT: "YYYY/MM"
};
var DEFAULT_TEMPLATES = {
  JOURNAL: `# {{date}}

## Daily Log

## Tasks
- [ ] 

## Notes

## Reflection

---
Previous: {{previous}}
Next: {{next}}
`,
  NOTE: `---
title: {{title}}
created: {{date}}
source: {{source}}
tags: []
---

# {{title}}

`
};
var REGEX_PATTERNS = {
  WIKI_LINK: /\[\[(.*?)\]\]/g,
  SHORTCODE: /[\w>+*{}\[\]()]+$/,
  DATE_FILENAME: /\d{4}-\d{2}-\d{2}/,
  INVALID_FILENAME_CHARS: /[\\/:*?"<>|]/g
};

// src/settings/directorySettings.ts
var DirectorySettings = class {
  static getDefaults() {
    return {
      baseFolder: DEFAULT_BASE_FOLDER,
      // Creates all directories under 'Link/' by default
      directoryStructure: DEFAULT_DIRECTORIES,
      restrictedDirectories: [],
      documentDirectory: "journal",
      // Simplified to journal only
      journalRootFolder: "journal"
      // Updated to match README structure
    };
  }
  static validate(settings) {
    const validated = {};
    if (settings.baseFolder !== void 0 && typeof settings.baseFolder === "string") {
      const trimmed = settings.baseFolder.trim();
      if (trimmed === "" || /^\/*$/.test(trimmed)) {
        validated.baseFolder = "";
      } else {
        validated.baseFolder = trimmed;
      }
    }
    if (settings.directoryStructure && Array.isArray(settings.directoryStructure)) {
      validated.directoryStructure = settings.directoryStructure;
    }
    if (settings.restrictedDirectories && Array.isArray(settings.restrictedDirectories)) {
      validated.restrictedDirectories = settings.restrictedDirectories;
    }
    if (settings.documentDirectory && typeof settings.documentDirectory === "string") {
      validated.documentDirectory = settings.documentDirectory;
    }
    if (settings.journalRootFolder && typeof settings.journalRootFolder === "string") {
      validated.journalRootFolder = settings.journalRootFolder;
    }
    return validated;
  }
};

// src/settings/journalSettings.ts
var JournalSettings = class {
  static getDefaults() {
    return {
      journalDateFormat: "YYYY-MM-DD dddd",
      journalFolderFormat: DATE_FORMATS.FOLDER_FORMAT,
      journalYearFormat: "YYYY",
      journalMonthFormat: "MM-MMMM",
      // Changed to MM-MMMM for "07-July" format
      journalTemplate: DEFAULT_TEMPLATES.JOURNAL,
      simpleJournalMode: false
      // Default to dynamic monthly folders
    };
  }
  static validate(settings) {
    const validated = {};
    if (settings.journalDateFormat && typeof settings.journalDateFormat === "string") {
      validated.journalDateFormat = settings.journalDateFormat;
    }
    if (settings.journalFolderFormat && typeof settings.journalFolderFormat === "string") {
      validated.journalFolderFormat = settings.journalFolderFormat;
    }
    if (settings.journalTemplate && typeof settings.journalTemplate === "string") {
      validated.journalTemplate = settings.journalTemplate;
    }
    if (typeof settings.simpleJournalMode === "boolean") {
      validated.simpleJournalMode = settings.simpleJournalMode;
    }
    return validated;
  }
  static isValidDateFormat(format) {
    try {
      const validTokens = ["YYYY", "MM", "DD", "dddd", "MMM", "MMMM"];
      return validTokens.some((token) => format.includes(token));
    } catch (e) {
      return false;
    }
  }
};

// src/settings/noteSettings.ts
var NoteSettings = class {
  static getDefaults() {
    return {
      noteTemplate: DEFAULT_TEMPLATES.NOTE
    };
  }
  static validate(settings) {
    const validated = {};
    if (settings.noteTemplate && typeof settings.noteTemplate === "string") {
      validated.noteTemplate = settings.noteTemplate;
    }
    return validated;
  }
  static validateTemplate(template) {
    const errors = [];
    const requiredVars = ["{{title}}"];
    const missingVars = requiredVars.filter((varName) => !template.includes(varName));
    if (missingVars.length > 0) {
      errors.push(`Missing required template variables: ${missingVars.join(", ")}`);
    }
    const templateVarPattern = /\{\{[^}]*\}\}/g;
    const matches = template.match(templateVarPattern);
    if (matches) {
      matches.forEach((match) => {
        if (!match.endsWith("}}")) {
          errors.push(`Malformed template variable: ${match}`);
        }
      });
    }
    return {
      isValid: errors.length === 0,
      errors
    };
  }
};

// src/settings/dailyNotesSettings.ts
var DailyNotesSettings = class {
  static getDefaults() {
    return {
      dailyNotesIntegration: {
        enabled: false,
        backup: null
      }
    };
  }
  static validate(settings) {
    const defaults = this.getDefaults();
    if (!settings.dailyNotesIntegration) {
      return defaults;
    }
    const integration = settings.dailyNotesIntegration;
    return {
      dailyNotesIntegration: {
        enabled: typeof integration.enabled === "boolean" ? integration.enabled : defaults.dailyNotesIntegration.enabled,
        backup: integration.backup || null
      }
    };
  }
};

// src/settings/generalSettings.ts
var GeneralSettings = class {
  static getDefaults() {
    return {
      debugMode: false,
      fileSorting: {
        enableAutoSorting: false,
        sortOnFileCreate: false,
        sortOnFileModify: false
      }
    };
  }
  static validate(settings) {
    const validated = {};
    if (typeof settings.debugMode === "boolean") {
      validated.debugMode = settings.debugMode;
    }
    return validated;
  }
  static getDebugInfo() {
    return {
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      language: navigator.language
    };
  }
};

// src/settings/settingsValidator.ts
function validateSettings(settings) {
  const validatedSettings = {
    ...DirectorySettings.getDefaults(),
    ...JournalSettings.getDefaults(),
    ...NoteSettings.getDefaults(),
    ...DailyNotesSettings.getDefaults(),
    // ...ShortcodeSettings.getDefaults(), // Deprecated - moved to quarantine
    ...GeneralSettings.getDefaults()
  };
  const directoryValidation = DirectorySettings.validate(settings);
  const journalValidation = JournalSettings.validate(settings);
  const noteValidation = NoteSettings.validate(settings);
  const dailyNotesValidation = DailyNotesSettings.validate(settings);
  const generalValidation = GeneralSettings.validate(settings);
  Object.assign(
    validatedSettings,
    directoryValidation,
    journalValidation,
    noteValidation,
    dailyNotesValidation,
    // shortcodeValidation, // Deprecated - moved to quarantine
    generalValidation
  );
  if (typeof settings.customTemplateLocation === "string") {
    validatedSettings.customTemplateLocation = settings.customTemplateLocation.trim();
  } else {
    validatedSettings.customTemplateLocation = void 0;
  }
  return validatedSettings;
}

// src/settings/defaultSettings.ts
var DEFAULT_SETTINGS = {
  ...DirectorySettings.getDefaults(),
  ...JournalSettings.getDefaults(),
  ...NoteSettings.getDefaults(),
  ...DailyNotesSettings.getDefaults(),
  // ...ShortcodeSettings.getDefaults(), // Deprecated - moved to quarantine
  ...GeneralSettings.getDefaults(),
  customTemplateLocation: void 0
};

// src/managers/directoryManager.ts
var import_obsidian2 = require("obsidian");

// src/utils/pathUtils.ts
var import_obsidian = require("obsidian");
var PathUtils = class {
  static sanitizePath(path) {
    return (0, import_obsidian.normalizePath)(path.replace(/[\/:*?"<>|]/g, "").trim());
  }
  static joinPath(...segments) {
    return (0, import_obsidian.normalizePath)(segments.filter(Boolean).join("/"));
  }
};

// src/services/dateService.ts
var DateService = class {
  /**
   * Initialize the date service with Obsidian's moment instance
   * This should be called once when the plugin loads
   */
  static initialize() {
    this.moment = window.moment;
    if (!this.moment) {
      throw new Error("Obsidian moment.js not available");
    }
  }
  /**
   * Get current date/time
   */
  static now() {
    return this.moment();
  }
  /**
   * Create moment from date input
   */
  static from(input) {
    return this.moment(input);
  }
  /**
   * Create moment from date string with format
   */
  static fromFormat(input, format, strict = true) {
    return this.moment(input, format, strict);
  }
  /**
   * Format a date using the specified format
   */
  static format(date, format = "YYYY-MM-DD") {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.format(format);
  }
  /**
   * Get today's date formatted
   */
  static today(format = "YYYY-MM-DD") {
    return this.moment().format(format);
  }
  /**
   * Get current year
   */
  static currentYear() {
    return this.moment().format("YYYY");
  }
  /**
   * Get current month name
   */
  static currentMonth() {
    return this.moment().format("MMMM");
  }
  /**
   * Get start of year for given date
   */
  static startOfYear(date) {
    return (date ? this.moment(date) : this.moment()).startOf("year");
  }
  /**
   * End of year for given date
   */
  static endOfYear(date) {
    return (date ? this.moment(date) : this.moment()).endOf("year");
  }
  /**
   * Start of month for given date
   */
  static startOfMonth(date) {
    return (date ? this.moment(date) : this.moment()).startOf("month");
  }
  /**
   * End of month for given date
   */
  static endOfMonth(date) {
    return (date ? this.moment(date) : this.moment()).endOf("month");
  }
  /**
   * Add time to a date
   */
  static add(date, amount, unit) {
    return this.moment(date).add(amount, unit);
  }
  /**
   * Subtract time from a date
   */
  static subtract(date, amount, unit) {
    return this.moment(date).subtract(amount, unit);
  }
  /**
   * Adds days to a date and returns a new moment object
   */
  static addDays(date, days) {
    return this.add(date, days, "days");
  }
  /**
   * Check if date is valid
   */
  static isValid(date) {
    return this.moment(date).isValid();
  }
  /**
   * Check if date is same or before another date
   */
  static isSameOrBefore(date1, date2) {
    return this.moment(date1).isSameOrBefore(date2);
  }
  /**
   * Extract date from filename using format
   */
  static extractDateFromFilename(filename, format) {
    try {
      const date = this.moment(filename, format, true);
      return date.isValid() ? date : null;
    } catch (error) {
      return null;
    }
  }
  /**
   * Get journal path components for a date with custom formats
   */
  static getJournalPathComponents(date, yearFormat, monthFormat) {
    const momentDate = date ? this.moment(date) : this.moment();
    const year = momentDate.format("YYYY");
    const monthName = momentDate.format("MMMM");
    const monthNumber = momentDate.format("MM");
    const yearFolderFormat = yearFormat && yearFormat !== "y_YYYY" ? yearFormat : "YYYY";
    const monthFolderFormat = monthFormat || "MM-MMMM";
    let cleanMonthFormat = monthFolderFormat;
    if (monthFolderFormat === "MMmmmm" || monthFolderFormat === "MMMMM" || monthFolderFormat === "MMMM") {
      cleanMonthFormat = "MM-MMMM";
    }
    return {
      year,
      monthName,
      monthNumber,
      yearFolder: momentDate.format(yearFolderFormat),
      monthFolder: momentDate.format(cleanMonthFormat)
    };
  }
  /**
   * Get formatted filename for journal entry
   */
  static getJournalFilename(date, format = "YYYY-MM-DD dddd") {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.format(format);
  }
  /**
   * Get previous day
   */
  static previousDay(date) {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.subtract(1, "day");
  }
  /**
   * Get next day
   */
  static nextDay(date) {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.add(1, "day");
  }
  /**
   * Create date range iterator
   */
  static *dateRange(startDate, endDate, unit = "day") {
    const current = this.moment(startDate);
    const end = this.moment(endDate);
    while (current.isSameOrBefore(end)) {
      yield this.moment(current);
      current.add(1, unit);
    }
  }
  /**
   * Get monthly folder path for a date with custom formats
   */
  static getMonthlyFolderPath(basePath, date, yearFormat, monthFormat) {
    const components = this.getJournalPathComponents(date, yearFormat, monthFormat);
    return `${basePath}/${components.yearFolder}/${components.monthFolder}`;
  }
  /**
   * Get full journal file path
   */
  static getJournalFilePath(basePath, date, format = "YYYY-MM-DD dddd") {
    const monthlyPath = this.getMonthlyFolderPath(basePath, date);
    const filename = this.getJournalFilename(date, format);
    return `${monthlyPath}/${filename}.md`;
  }
  /**
   * Validate date format string
   */
  static isValidFormat(format) {
    try {
      const testDate = this.moment();
      testDate.format(format);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Get debug information about the moment instance
   */
  static getDebugInfo() {
    var _a;
    return {
      available: !!this.moment,
      version: ((_a = this.moment) == null ? void 0 : _a.version) || "unknown",
      type: typeof this.moment
    };
  }
};

// src/managers/directoryManager.ts
var DirectoryManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates the base directory structure according to settings
   * All directories are created under the configured baseFolder to prevent collisions
   */
  async rebuildDirectoryStructure() {
    const { vault } = this.plugin.app;
    const { baseFolder, directoryStructure } = this.plugin.settings;
    try {
      const basePath = baseFolder ? (0, import_obsidian2.normalizePath)(baseFolder) : "";
      if (basePath) {
        await this.getOrCreateDirectory(basePath);
        console.log(`Created base directory: ${basePath}`);
      } else {
        console.log("Using vault root as base directory");
      }
      for (const dirName of directoryStructure || DEFAULT_DIRECTORIES) {
        const dirPath = basePath ? PathUtils.joinPath(basePath, dirName) : dirName;
        await this.getOrCreateDirectory(dirPath);
        console.log(`Created directory: ${dirPath}`);
      }
      await this.createJournalStructure(basePath);
      await this.createReferenceStructure(basePath);
    } catch (error) {
      throw new Error(`Failed to rebuild directory structure: ${error}`);
    }
  }
  /**
   * Creates journal structure - simple or dynamic based on single setting
   */
  async createJournalStructure(basePath) {
    const journalPath = PathUtils.joinPath(basePath, "journal");
    await this.getOrCreateDirectory(journalPath);
    console.log(`Created journal directory: ${journalPath}`);
    if (!this.plugin.settings.simpleJournalMode) {
      const currentDate = DateService.now();
      const currentYear = DateService.format(currentDate, "YYYY");
      const currentMonth = DateService.format(currentDate, "MM-MMMM");
      const currentYearPath = PathUtils.joinPath(journalPath, currentYear);
      const currentMonthPath = PathUtils.joinPath(currentYearPath, currentMonth);
      await this.getOrCreateDirectory(currentYearPath);
      await this.getOrCreateDirectory(currentMonthPath);
      console.log(`Created current month directory: ${currentMonthPath}`);
      console.log("Current month journal structure created");
    }
  }
  /**
   * Creates templates directory and copies the daily notes template when enabled
   * Templates are siblings to journal structure for proper organization
   */
  async setupTemplates() {
    try {
      const { baseFolder } = this.plugin.settings;
      const templatesPath = baseFolder ? PathUtils.joinPath(baseFolder, DEFAULT_TEMPLATES_PATH) : DEFAULT_TEMPLATES_PATH;
      await this.getOrCreateDirectory(templatesPath);
      console.log(`Created templates directory: ${templatesPath}`);
      const templateFilePath = PathUtils.joinPath(templatesPath, DAILY_NOTES_TEMPLATE_NAME);
      const { vault } = this.plugin.app;
      if (!vault.getAbstractFileByPath(templateFilePath)) {
        const templateContent = await this.getDailyNotesTemplateContent();
        await vault.create(templateFilePath, templateContent);
        console.log(`Created template file: ${templateFilePath}`);
      } else {
        console.log(`Template already exists: ${templateFilePath}`);
      }
    } catch (error) {
      throw new Error(`Failed to setup templates: ${error}`);
    }
  }
  /**
   * Gets the daily notes template content from the plugin assets
   * Always returns the raw template with Templater syntax to avoid conflicts
   */
  async getDailyNotesTemplateContent() {
    return `---
previous: '[[<% tp.date.now("YYYY-MM-DD dddd", -1) %>]]'
next: '[[<% tp.date.now("YYYY-MM-DD dddd", 1) %>]]'
tags:
  - \u2600\uFE0F
resources: []
stakeholders:
---
---
## Log

### Routine Checklist

- [ ] Open Daily Note
- [ ] **Daily Checks**
	- [ ] Bed and Clothes \u{1F6CF}\uFE0F\u{1F9FA}
		- [ ] Self Care\u{1F6C0}\u{1F9F4}
	- [ ] Clean Kitchen
		- [ ] Make Breakfast \u{1F37D}\u2728
	- [ ] Pet Care \u{1F415}\u{1F6B6}\u{1F3FB}\u200D\u2642\uFE0F
		- [ ] Wear Watch \u231A\uFE0F
	- [ ] Get Focused \u{1F5A5}\uFE0F\u{1F48A}
		- [ ] Put [Calendar](https://calendar.google.com) \u{1F4C6}
	- [ ] Check [Mail](https://mail.google.com) \u2709\uFE0F 
		- [ ] Reviews [[Yearly List]] \u2705
	- [ ] Review [July Log](Yearly%20Log.md#July) \u{1F5D3}\uFE0F

---`;
  }
  /**
   * Creates reference directory structure and knowledge base documentation
   */
  async createReferenceStructure(basePath) {
    const referencePath = basePath ? PathUtils.joinPath(basePath, "reference") : "reference";
    await this.getOrCreateDirectory(referencePath);
    console.log(`Created reference directory: ${referencePath}`);
    await this.createArchitectureDocumentation(referencePath);
    await this.createPatternsDocumentation(referencePath);
    await this.createIntegrationDocumentation(referencePath);
    await this.createTroubleshootingLessons(referencePath);
    console.log("Reference knowledge base created");
  }
  /**
   * Creates architecture documentation explaining key design decisions
   */
  async createArchitectureDocumentation(referencePath) {
    const { vault } = this.plugin.app;
    const filePath = PathUtils.joinPath(referencePath, "Architecture Decisions.md");
    if (!vault.getAbstractFileByPath(filePath)) {
      const content = `# Architecture Decisions

## Directory Structure Logic

### Core Principle: Siblings vs Nested
**Decision**: Templates, Journal, and Reference are siblings under Link/
**Reasoning**: 
- Templates are **tools to create** content, not content themselves
- Each serves different purposes and should be logically separated
- Prevents deep nesting that makes navigation difficult
- Follows standard file organization principles

### Structure:
\`\`\`
Link/
\u251C\u2500\u2500 journal/           # Time-based content
\u2502   \u2514\u2500\u2500 YYYY/MM-Month/ # Organized by date
\u251C\u2500\u2500 templates/         # Content creation tools
\u2502   \u2514\u2500\u2500 *.md          # Template files
\u2514\u2500\u2500 reference/         # Knowledge base & documentation
    \u2514\u2500\u2500 *.md          # Reference materials
\`\`\`

## Collision Avoidance Strategy

### Problem
Plugin needs to create directories without conflicting with existing vault structure.

### Solution: Base Folder Approach
- All plugin content contained within configurable base folder (default: "Link")
- User can change base folder to avoid conflicts
- Plugin never creates directories at vault root level

### Benefits
- \u2705 No conflicts with existing user structure
- \u2705 Easy to relocate entire plugin structure
- \u2705 Clear separation of plugin vs user content
- \u2705 Easy to backup/sync plugin content separately

## Template System Design

### Problem
Need to provide templates without interfering with existing template systems (Templater).

### Solution: Coexistence Pattern
1. **No Interference**: Always provide raw template with original syntax
2. **Detection Only**: Check for Templater presence for user feedback only
3. **No Overrides**: Never replace or modify Templater functionality
4. **Standard Location**: Place templates in predictable, discoverable location

### Benefits  
- \u2705 Works with or without Templater
- \u2705 No plugin conflicts
- \u2705 User can modify templates freely
- \u2705 Templater handles its own syntax processing

## Error Handling Philosophy

### Principle: Graceful Degradation
- Plugin should work even if some features fail
- Non-critical features fail silently with logging
- Critical features show user-friendly error messages
- Always provide fallback functionality

### Implementation
- Try-catch blocks around all major operations
- Detailed logging for debugging
- User notifications for actionable errors only
- Fallback behaviors when integrations fail
`;
      await vault.create(filePath, content);
      console.log(`Created architecture documentation: ${filePath}`);
    }
  }
  /**
   * Creates patterns documentation for common plugin development patterns
   */
  async createPatternsDocumentation(referencePath) {
    const { vault } = this.plugin.app;
    const filePath = PathUtils.joinPath(referencePath, "Development Patterns.md");
    if (!vault.getAbstractFileByPath(filePath)) {
      const content = `# Development Patterns

## Directory Management Pattern

### Pattern: Defensive Directory Creation
\`\`\`typescript
async getOrCreateDirectory(path: string): Promise<TFolder> {
  const existingFolder = vault.getAbstractFileByPath(path);
  if (existingFolder instanceof TFolder) {
    return existingFolder; // Already exists
  }
  
  // Create parent directories recursively
  const pathParts = path.split('/');
  for (const part of pathParts) {
    // Incremental path building and validation
  }
  
  return vault.getAbstractFileByPath(path) as TFolder;
}
\`\`\`

**Why This Works:**
- Handles existing directories gracefully
- Creates parent directories as needed
- Validates each step of path creation
- Returns consistent TFolder interface

## Settings Management Pattern

### Pattern: Layered Configuration
1. **Default Settings**: Hard-coded fallbacks
2. **User Settings**: Persisted overrides  
3. **Runtime Settings**: Temporary modifications

### Implementation Strategy
\`\`\`typescript
class SettingsManager {
  defaults = DEFAULT_SETTINGS;
  user = loadUserSettings();
  
  get(key: string) {
    return this.user[key] ?? this.defaults[key];
  }
}
\`\`\`

**Benefits:**
- Always has working configuration
- User can override any setting
- Runtime changes don't affect persistence
- Easy to reset to defaults

## Plugin Integration Pattern

### Pattern: Detection and Graceful Coexistence

**Problem**: Need to work with other plugins without conflicts

**Solution**: 
1. **Detect**: Check if other plugin exists and is enabled
2. **Respect**: Don't override other plugin functionality
3. **Complement**: Provide value alongside, not instead of
4. **Fallback**: Work independently if other plugin not available

### Example: Templater Integration
\`\`\`typescript
private isTemplaterAvailable(): boolean {
  const templaterPlugin = this.app.plugins?.plugins?.['templater-obsidian'];
  return templaterPlugin && templaterPlugin._loaded;
}

private getTemplateContent(): string {
  // Always return raw template - let Templater handle processing
  return rawTemplateWithTemplaterSyntax;
}
\`\`\`

**Key Principles:**
- \u2705 Check availability for user feedback only
- \u2705 Never modify other plugin's functionality  
- \u2705 Provide complementary, not competing features
- \u2705 Maintain functionality without dependencies

## Error Boundaries Pattern

### Pattern: Contextual Error Handling
\`\`\`typescript
class ErrorHandler {
  handleError(error: Error, context: string, userFacing = false) {
    console.error(\`[\${context}]\`, error);
    
    if (userFacing) {
      this.showNotice(\`\${context}: \${error.message}\`);
    }
    
    // Log to file for debugging
    this.logError(context, error);
  }
}
\`\`\`

**Benefits:**
- Contextual information for debugging
- User sees only actionable errors
- Complete error history preserved
- Consistent error handling across plugin

## Date Service Pattern

### Pattern: Centralized Date Logic
Instead of using Date() directly throughout codebase:

\`\`\`typescript
class DateService {
  static now() { return moment(); }
  static format(date, format) { return moment(date).format(format); }
  static add(date, amount, unit) { return moment(date).add(amount, unit); }
}
\`\`\`

**Benefits:**
- Consistent date handling
- Easy to mock for testing
- Single place to change date library
- Handles timezone/locale consistently

## Command Registration Pattern

### Pattern: Centralized Command Management
\`\`\`typescript
registerCommands() {
  const commands = [
    { id: 'create-note', name: 'Create Note', handler: this.createNote },
    { id: 'open-journal', name: 'Open Journal', handler: this.openJournal }
  ];
  
  commands.forEach(cmd => this.addCommand(cmd));
}
\`\`\`

**Benefits:**
- Easy to see all available commands
- Consistent command structure
- Easy to add/remove commands
- Centralized command logic
`;
      await vault.create(filePath, content);
      console.log(`Created patterns documentation: ${filePath}`);
    }
  }
  /**
   * Creates integration documentation for working with Obsidian ecosystem
   */
  async createIntegrationDocumentation(referencePath) {
    const { vault } = this.plugin.app;
    const filePath = PathUtils.joinPath(referencePath, "Integration Guide.md");
    if (!vault.getAbstractFileByPath(filePath)) {
      const content = `# Integration Guide

## Working with Obsidian Ecosystem

### Core Principle: Be a Good Citizen
- Complement existing functionality, don't replace it
- Follow Obsidian's conventions and patterns
- Integrate with popular community plugins
- Provide value without causing conflicts

## Daily Notes Integration

### Challenge
Update Obsidian's Daily Notes plugin to use our folder structure.

### Solution: Settings Synchronization
\`\`\`typescript
async updateDailyNotesSettings(): Promise<void> {
  // Try core plugin first
  const corePlugin = this.app.internalPlugins?.plugins?.['daily-notes'];
  if (corePlugin?.enabled) {
    corePlugin.instance.options.folder = ourFolderPath;
    return;
  }
  
  // Fallback to community plugin
  const communityPlugin = this.app.plugins?.plugins?.['daily-notes'];
  if (communityPlugin) {
    communityPlugin.settings.folder = ourFolderPath;
    await communityPlugin.saveSettings();
  }
}
\`\`\`

**Key Insights:**
- Core plugins accessed via \`internalPlugins\`
- Community plugins via \`plugins.plugins\`
- Always check if plugin exists and is enabled
- Settings structures may differ between core/community versions

## Templater Integration

### Challenge
Provide templates without breaking Templater functionality.

### Solution: Raw Template Strategy
1. **Always provide raw template** with Templater syntax
2. **Never process Templater syntax** ourselves
3. **Let Templater handle its own processing**
4. **Detect Templater only for user feedback**

### Anti-Pattern (Don't Do This)
\`\`\`typescript
// \u274C BAD: Processing Templater syntax ourselves
if (this.isTemplaterAvailable()) {
  return rawTemplate;
} else {
  return this.processTemplaterSyntax(rawTemplate); // DON'T DO THIS
}
\`\`\`

### Correct Pattern
\`\`\`typescript  
// \u2705 GOOD: Always return raw template
private getTemplateContent(): string {
  return rawTemplateWithTemplaterSyntax; // Let Templater handle it
}
\`\`\`

**Why This Works:**
- No conflicts with Templater processing
- Template works with or without Templater
- User can modify template syntax freely
- Templater maintains full control of its features

## File System Integration

### Challenge
Create files and folders without conflicts.

### Solution: Vault API + Path Normalization
\`\`\`typescript
// Always normalize paths
const normalizedPath = normalizePath(userPath);

// Check if exists before creating
const existing = vault.getAbstractFileByPath(normalizedPath);
if (!existing) {
  await vault.create(normalizedPath, content);
}

// Handle both files and folders
if (existing instanceof TFolder) {
  // It's a folder
} else if (existing instanceof TFile) {
  // It's a file
}
\`\`\`

**Best Practices:**
- Always use \`normalizePath()\` for cross-platform compatibility
- Check existence before creating
- Use appropriate Vault API methods
- Handle edge cases (file vs folder conflicts)

## Settings Integration

### Challenge
Provide settings UI that integrates with Obsidian's settings.

### Solution: PluginSettingTab Extension
\`\`\`typescript
export class SettingsTab extends PluginSettingTab {
  display(): void {
    const { containerEl } = this;
    containerEl.empty();
    
    // Group related settings
    this.addGeneralSettings(containerEl);
    this.addJournalSettings(containerEl);
    this.addAdvancedSettings(containerEl);
  }
  
  private addGeneralSettings(containerEl: HTMLElement): void {
    containerEl.createEl('h2', { text: 'General Settings' });
    
    new Setting(containerEl)
      .setName('Setting Name')
      .setDesc('Clear description of what this does')
      .addText(text => text
        .setValue(this.plugin.settings.value)
        .onChange(async (value) => {
          this.plugin.settings.value = value;
          await this.plugin.saveSettings();
        }));
  }
}
\`\`\`

**UI Best Practices:**
- Group related settings with headers
- Provide clear names and descriptions
- Auto-save changes immediately
- Use appropriate input types
- Provide validation feedback

## Command Palette Integration

### Challenge
Make plugin features discoverable and accessible.

### Solution: Comprehensive Command Registration
\`\`\`typescript
registerCommands() {
  this.addCommand({
    id: 'action-id',
    name: 'User-Friendly Action Name',
    icon: 'calendar', // Lucide icon name
    callback: () => this.performAction(),
    hotkeys: [{ modifiers: ['Mod'], key: 'j' }] // Optional
  });
}
\`\`\`

**Command Design Principles:**
- Use clear, action-oriented names
- Provide appropriate icons
- Consider default hotkeys for common actions
- Group related commands with similar naming
- Make commands context-aware when possible

## Ribbon Integration

### Challenge
Provide quick access to common features.

### Solution: Contextual Ribbon Buttons
\`\`\`typescript
addRibbonIcon('calendar-days', 'Open Today\\'s Journal', () => {
  this.openTodayJournal();
});
\`\`\`

**Ribbon Best Practices:**
- Use only for most common actions
- Choose clear, recognizable icons
- Provide helpful tooltips
- Don't overcrowd the ribbon
- Consider user's workflow patterns
`;
      await vault.create(filePath, content);
      console.log(`Created integration documentation: ${filePath}`);
    }
  }
  /**
   * Creates troubleshooting lessons learned from development process
   */
  async createTroubleshootingLessons(referencePath) {
    const { vault } = this.plugin.app;
    const filePath = PathUtils.joinPath(referencePath, "Troubleshooting Lessons.md");
    if (!vault.getAbstractFileByPath(filePath)) {
      const content = `# Troubleshooting Lessons Learned

## Template System Issues

### Problem: Templates Not Syncing
**Symptoms**: Templates created but application can't find them
**Root Cause**: Template directory not properly integrated with base folder structure
**Solution**: Ensure templates are created as siblings to journal, not nested within

### Problem: Templater Conflicts  
**Symptoms**: Templates render incorrectly or cause errors
**Root Cause**: Plugin trying to process Templater syntax instead of leaving it alone
**Solution**: Always return raw template with original syntax - let Templater handle processing

**Key Insight**: **Don't compete with existing plugins - complement them**

## Directory Structure Issues

### Problem: File/Folder Collisions
**Symptoms**: Plugin creates directories that conflict with existing vault structure
**Root Cause**: Creating directories at vault root level
**Solution**: Base folder approach - contain all plugin content within configurable folder

### Problem: Inconsistent Directory Creation
**Symptoms**: Some directories created, others missing
**Root Cause**: Directory creation logic scattered across multiple methods
**Solution**: Centralize directory creation in single method with proper ordering

**Key Insight**: **Defensive programming - always check if directory exists before creating**

## Plugin Integration Issues

### Problem: Daily Notes Plugin Not Updated
**Symptoms**: Daily notes created in wrong location despite plugin folder structure
**Root Cause**: Incorrect API usage - wrong plugin reference path
**Solution**: 
- Core plugins: \`internalPlugins.plugins['plugin-name']\`
- Community plugins: \`plugins.plugins['plugin-name']\`

### Problem: Settings Not Persisting
**Symptoms**: Plugin settings reset after restart
**Root Cause**: Not calling \`saveSettings()\` after changes
**Solution**: Always call \`await this.plugin.saveSettings()\` after setting changes

**Key Insight**: **Obsidian has different APIs for core vs community plugins**

## Error Handling Lessons

### Problem: Silent Failures
**Symptoms**: Features don't work but no error messages
**Root Cause**: Try-catch blocks swallowing errors without logging
**Solution**: Always log errors, show user messages for actionable issues

### Problem: Modal Constructor Errors
**Symptoms**: \`this.plugin.app.Modal is not a constructor\`
**Root Cause**: Incorrect Modal import/usage
**Solution**: Import Modal from 'obsidian' and use \`new Modal(this.app)\`

**Key Insight**: **Make errors visible during development - silent failures waste time**

## Date Handling Lessons

### Problem: Date Format Inconsistencies
**Symptoms**: Files created with wrong date formats or in wrong folders
**Root Cause**: Using different date libraries/formats throughout codebase
**Solution**: Centralized DateService with consistent formatting

### Problem: Month Change Detection
**Symptoms**: Monthly folders not created when month changes
**Root Cause**: No monitoring for date changes
**Solution**: Interval-based monitoring with month comparison

**Key Insight**: **Date handling is complex - centralize it in a service class**

## Settings UI Lessons

### Problem: Settings Not User-Friendly
**Symptoms**: Users confused by settings options
**Root Cause**: Poor organization and lack of descriptions
**Solution**: Group settings logically, provide clear descriptions and examples

### Problem: No Immediate Feedback
**Symptoms**: Users don't know if settings saved or took effect
**Root Cause**: No visual feedback after changes
**Solution**: Show confirmations, update UI immediately after changes

**Key Insight**: **Good UX requires immediate feedback and clear organization**

## Build and Development Lessons

### Problem: Linter Errors After Refactoring
**Symptoms**: TypeScript errors about missing methods/properties
**Root Cause**: Method signatures changed but calls not updated
**Solution**: Use IDE refactoring tools, check all references when changing APIs

### Problem: Inconsistent Code Style
**Symptoms**: Mix of different patterns and conventions
**Root Cause**: Adding features without following established patterns
**Solution**: Document patterns, use consistent code organization

**Key Insight**: **Consistency is more important than perfection**

## Architecture Evolution Lessons

### What We Started With:
- Complex nested directory structures
- Multiple competing template systems
- Scattered error handling
- Plugin conflicts

### What We Learned:
1. **Simplicity wins** - Remove features that don't add clear value
2. **Separation of concerns** - Each directory serves one purpose
3. **Integration over replacement** - Work with existing plugins, don't compete
4. **Defensive programming** - Always handle edge cases and errors
5. **User feedback** - Make the system's behavior visible and understandable

### Final Architecture Principles:
- **Base folder containment** - All plugin content in configurable folder
- **Sibling directory structure** - Templates, journal, reference as equals
- **Graceful coexistence** - Detect and complement other plugins
- **Centralized services** - Date, error handling, settings in dedicated classes
- **Comprehensive documentation** - Document decisions and patterns for future

## Key Realizations

### Template Organization Logic:
**Question**: Should templates be nested inside journal or siblings?
**Answer**: Siblings - templates are **tools to create** content, not content themselves

### Plugin Integration Strategy:
**Question**: Should we override other plugin functionality?
**Answer**: No - detect, complement, provide fallbacks, but never replace

### Error Handling Philosophy:
**Question**: When should users see error messages?
**Answer**: Only for actionable errors - log everything, show only what users can fix

### Directory Structure Logic:
**Question**: How deep should directory nesting go?
**Answer**: Keep it shallow - complex nesting makes organization harder, not easier

## Development Process Insights

### Effective Debugging Approach:
1. **Reproduce the issue** consistently
2. **Isolate the root cause** - don't fix symptoms
3. **Understand the why** - learn from the problem
4. **Fix comprehensively** - address root cause and related issues
5. **Document the lesson** - prevent future similar issues

### Code Review Questions:
- Does this follow established patterns?
- Will this conflict with other plugins?
- Is the error handling comprehensive?
- Are the directory structures logical?
- Is the user experience clear and immediate?

### Architecture Review Questions:
- Does each component have a single responsibility?
- Are dependencies clearly defined and minimal?
- Is the code organized consistently?
- Are edge cases handled gracefully?
- Is the system extensible without breaking changes?

---

**Final Wisdom**: The best architecture emerges from understanding both the technical constraints and the user's mental model. Build systems that make sense to users while being maintainable for developers.
`;
      await vault.create(filePath, content);
      console.log(`Created troubleshooting lessons: ${filePath}`);
    }
  }
  /**
   * Checks if Templater plugin is available and enabled
   * Used only for user feedback, not for template processing
   */
  isTemplaterAvailable() {
    var _a, _b;
    const templaterPlugin = (_b = (_a = this.plugin.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["templater-obsidian"];
    return templaterPlugin && templaterPlugin._loaded;
  }
  /**
   * Gets a directory path, creating it if it doesn't exist
   * Handles both absolute paths and paths relative to the base folder
   */
  async getOrCreateDirectory(path) {
    const { vault } = this.plugin.app;
    const normalizedPath = (0, import_obsidian2.normalizePath)(path);
    const existingFolder = vault.getAbstractFileByPath(normalizedPath);
    if (existingFolder instanceof import_obsidian2.TFolder) {
      return existingFolder;
    }
    const pathParts = normalizedPath.split("/");
    let currentPath = "";
    for (const part of pathParts) {
      if (!part)
        continue;
      currentPath += (currentPath ? "/" : "") + part;
      const folder = vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await vault.createFolder(currentPath);
      } else if (!(folder instanceof import_obsidian2.TFolder)) {
        throw new Error(`Path ${currentPath} exists but is not a folder`);
      }
    }
    return vault.getAbstractFileByPath(normalizedPath);
  }
  /**
   * Gets the full path for a directory within the plugin's base folder
   */
  getPluginDirectoryPath(relativePath) {
    const { baseFolder } = this.plugin.settings;
    return baseFolder ? PathUtils.joinPath(baseFolder, relativePath) : relativePath;
  }
  /**
   * Gets the journal directory path
   */
  getJournalPath() {
    const { baseFolder, journalRootFolder } = this.plugin.settings;
    return baseFolder ? PathUtils.joinPath(baseFolder, journalRootFolder) : journalRootFolder;
  }
  /**
   * Applies a directory template to create structured folders
   */
  async applyDirectoryTemplate(basePath, template) {
    for (const [key, value] of Object.entries(template)) {
      const dirPath = PathUtils.joinPath(basePath, key);
      await this.getOrCreateDirectory(dirPath);
      if (value && typeof value === "object") {
        await this.applyDirectoryTemplate(dirPath, value);
      }
    }
  }
  /**
   * Validates if a given path is within allowed directories
   */
  isValidPath(path) {
    const normalizedPath = (0, import_obsidian2.normalizePath)(path);
    const { restrictedDirectories } = this.plugin.settings;
    if (!restrictedDirectories || restrictedDirectories.length === 0) {
      return true;
    }
    return !restrictedDirectories.some((dir) => {
      const normalizedDir = (0, import_obsidian2.normalizePath)(dir);
      return normalizedPath === normalizedDir || normalizedPath.startsWith(normalizedDir + "/");
    });
  }
  /**
   * Lists all directories in the vault
   */
  getAllDirectories() {
    const { vault } = this.plugin.app;
    return vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian2.TFolder);
  }
};

// src/managers/journalManager.ts
var import_obsidian3 = require("obsidian");
var JournalManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates or opens a journal entry for the specified date
   * Automatically creates monthly folders as needed
   */
  async createOrOpenJournalEntry(date) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    await this.ensureMonthlyFolderExists(date);
    const monthlyFolderPath = this.getMonthlyFolderPath(date);
    const fileName = DateService.getJournalFilename(date, journalDateFormat);
    const filePath = (0, import_obsidian3.normalizePath)(`${monthlyFolderPath}/${fileName}.md`);
    let file = vault.getAbstractFileByPath(filePath);
    if (!file) {
      file = await vault.create(filePath, "");
      console.log(`Created daily note: ${filePath}`);
    }
    return file;
  }
  /**
   * Ensures the monthly folder exists for the given date
   * Creates the folder structure if it doesn't exist
   */
  async ensureMonthlyFolderExists(date) {
    const monthlyFolderPath = this.getMonthlyFolderPath(date);
    const monthName = DateService.format(date, "MMMM YYYY");
    const folderExists = await this.plugin.app.vault.adapter.exists(monthlyFolderPath);
    if (!folderExists) {
      await this.plugin.directoryManager.getOrCreateDirectory(monthlyFolderPath);
      console.log(`\u2705 Created monthly folder for ${monthName}: ${monthlyFolderPath}`);
    } else {
      console.log(`Monthly folder for ${monthName} already exists: ${monthlyFolderPath}`);
    }
  }
  /**
   * Gets the monthly folder path for a given date
   * Uses simple mode OR dynamic folders based on single setting
   */
  getMonthlyFolderPath(date) {
    const journalBasePath = this.plugin.directoryManager.getJournalPath();
    if (this.plugin.settings.simpleJournalMode) {
      return journalBasePath;
    }
    return DateService.getMonthlyFolderPath(
      journalBasePath,
      date,
      this.plugin.settings.journalYearFormat,
      this.plugin.settings.journalMonthFormat
    );
  }
  /**
   * Creates a daily note for today if it doesn't exist
   * Automatically handles monthly folder creation
   */
  async createTodayNote() {
    const today = DateService.now();
    return await this.createOrOpenJournalEntry(today);
  }
  /**
   * Creates a daily note for a future date
   * Automatically creates monthly folders as needed
   */
  async createFutureDailyNote(date) {
    const targetDate = DateService.from(date);
    console.log(`Creating future daily note for: ${DateService.format(targetDate, "YYYY-MM-DD")}`);
    const file = await this.createOrOpenJournalEntry(targetDate);
    const monthlyPath = this.getMonthlyFolderPath(targetDate);
    console.log(`Future note created in: ${monthlyPath}`);
    return file;
  }
  /**
   * Generate content for a journal entry
   */
  async generateJournalContent(date) {
    const { journalTemplate, journalDateFormat } = this.plugin.settings;
    const previousDay = DateService.previousDay(date);
    const nextDay = DateService.nextDay(date);
    const previousLink = `[[${DateService.format(previousDay, journalDateFormat)}]]`;
    const nextLink = `[[${DateService.format(nextDay, journalDateFormat)}]]`;
    const currentDate = DateService.format(date, "YYYY-MM-DD");
    const title = DateService.format(date, journalDateFormat);
    if (journalTemplate) {
      return journalTemplate.replace(/{{date}}/g, currentDate).replace(/{{title}}/g, title).replace(/{{previous}}/g, previousLink).replace(/{{next}}/g, nextLink);
    }
    return `---
date: ${currentDate}
previous: ${previousLink}
next: ${nextLink}
tags:
  - journal
---

# ${title}

## Daily Log

## Tasks
- [ ] 

## Notes

## Reflection

---
Previous: ${previousLink} | Next: ${nextLink}
`;
  }
  /**
   * Opens the journal entry for today
   * Creates monthly folder and daily note if they don't exist
   */
  async openTodayJournal() {
    const today = DateService.now();
    const file = await this.createOrOpenJournalEntry(today);
    const leaf = this.plugin.app.workspace.getLeaf();
    await leaf.openFile(file);
  }
  /**
   * Checks if we need to create a new monthly folder
   * Called when the plugin loads, when creating notes, or when date changes
   */
  async checkAndCreateCurrentMonthFolder() {
    const currentDate = DateService.now();
    await this.ensureMonthlyFolderExists(currentDate);
    const daysUntilNextMonth = DateService.endOfMonth(currentDate).diff(currentDate, "days");
    if (daysUntilNextMonth <= 2) {
      const nextMonth = DateService.add(currentDate, 1, "month");
      await this.ensureMonthlyFolderExists(nextMonth);
      console.log("Pre-created next month folder (end of month detected)");
    }
  }
  /**
   * Creates monthly folders for a range of dates
   * Useful for batch creation or setup
   */
  async createMonthlyFoldersForRange(startDate, endDate) {
    let current = DateService.startOfMonth(startDate);
    const end = DateService.endOfMonth(endDate);
    while (DateService.isSameOrBefore(current, end)) {
      await this.ensureMonthlyFolderExists(current);
      current = DateService.add(current, 1, "month");
    }
  }
  /**
   * Opens journal entry for a specific date
   */
  async openJournalForDate(date) {
    const momentDate = DateService.from(date);
    const file = await this.createOrOpenJournalEntry(momentDate);
    const leaf = this.plugin.app.workspace.getLeaf();
    await leaf.openFile(file);
  }
  /**
   * Updates links between journal entries
   */
  async updateJournalLinks(file) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    const fileDate = DateService.extractDateFromFilename(file.basename, journalDateFormat || "YYYY-MM-DD dddd");
    if (!fileDate)
      return;
    const content = await vault.read(file);
    const previousDay = DateService.previousDay(fileDate);
    const nextDay = DateService.nextDay(fileDate);
    const previousFileName = DateService.format(previousDay, journalDateFormat);
    const nextFileName = DateService.format(nextDay, journalDateFormat);
    const updatedContent = content.replace(/previous: '\[\[(.*?)\]\]'/g, `previous: '[[${previousFileName}]]'`).replace(/next: '\[\[(.*?)\]\]'/g, `next: '[[${nextFileName}]]'`);
    if (updatedContent !== content) {
      await vault.modify(file, updatedContent);
    }
  }
  /**
   * Get journal entries for a date range
   */
  async getJournalEntries(startDate, endDate) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    const entries = [];
    let current = DateService.from(startDate);
    while (DateService.isSameOrBefore(current, endDate)) {
      const filePath = DateService.getJournalFilePath(
        this.plugin.directoryManager.getJournalPath(),
        current,
        journalDateFormat
      );
      const file = vault.getAbstractFileByPath(filePath);
      if (file) {
        entries.push({
          date: DateService.format(current, "YYYY-MM-DD"),
          path: filePath,
          title: DateService.format(current, journalDateFormat),
          previous: DateService.format(DateService.previousDay(current), "YYYY-MM-DD"),
          next: DateService.format(DateService.nextDay(current), "YYYY-MM-DD")
        });
      }
      current = DateService.add(current, 1, "day");
    }
    return entries;
  }
};

// src/managers/linkManager.ts
var import_obsidian4 = require("obsidian");
var CustomLinkSuggest = class extends import_obsidian4.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor) {
    const line = editor.getLine(cursor.line);
    const beforeCursor = line.substring(0, cursor.ch);
    const match = beforeCursor.match(/\[\[([^\]]*?)$/);
    if (match) {
      return {
        start: { line: cursor.line, ch: cursor.ch - match[1].length },
        end: cursor,
        query: match[1]
      };
    }
    return null;
  }
  async getSuggestions(context) {
    const query = context.query.toLowerCase();
    const suggestions = [];
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path.toLowerCase().includes(query) || file.basename.toLowerCase().includes(query)) {
        suggestions.push({
          path: file.path,
          displayText: file.path,
          isCreate: false
        });
      }
    }
    if (query.length > 0 && !suggestions.some((s) => s.path.toLowerCase() === query.toLowerCase() + ".md")) {
      const baseFolder = this.plugin.settings.baseFolder || "LinkPlugin";
      if (query.includes("/") || query.startsWith(baseFolder.toLowerCase())) {
        suggestions.unshift({
          path: query.endsWith(".md") ? query : query + ".md",
          displayText: `Create note: ${query}`,
          isCreate: true
        });
      }
    }
    return suggestions.slice(0, 10);
  }
  renderSuggestion(suggestion, el) {
    el.createEl("div", {
      text: suggestion.displayText,
      cls: suggestion.isCreate ? "link-suggest-create" : "link-suggest-existing"
    });
    if (suggestion.isCreate) {
      el.addClass("mod-complex");
      const icon = el.createEl("div", { cls: "suggestion-flair" });
      icon.createEl("span", { text: "+ Create", cls: "suggestion-note" });
    }
  }
  selectSuggestion(suggestion) {
    var _a;
    if (suggestion.isCreate) {
      this.createFileFromPath(suggestion.path);
    }
    const linkText = `[[${suggestion.path.replace(".md", "")}]]`;
    (_a = this.context) == null ? void 0 : _a.editor.replaceRange(linkText, this.context.start, this.context.end);
  }
  async createFileFromPath(path) {
    const { vault } = this.app;
    const normalizedPath = (0, import_obsidian4.normalizePath)(path);
    const dirPath = normalizedPath.substring(0, normalizedPath.lastIndexOf("/"));
    if (dirPath) {
      await this.plugin.directoryManager.getOrCreateDirectory(dirPath);
    }
    const existingFile = vault.getAbstractFileByPath(normalizedPath);
    if (!existingFile) {
      const fileName = normalizedPath.substring(normalizedPath.lastIndexOf("/") + 1).replace(".md", "");
      const content = this.generateNoteContent(fileName);
      await vault.create(normalizedPath, content);
    }
  }
  generateNoteContent(title) {
    const { noteTemplate } = this.plugin.settings;
    const currentDate = new Date().toISOString().split("T")[0];
    if (noteTemplate) {
      return noteTemplate.replace(/{{title}}/g, title).replace(/{{date}}/g, currentDate).replace(/{{source}}/g, "");
    }
    return `---
title: ${title}
created: ${currentDate}
tags: []
---

# ${title}

`;
  }
};
var LinkManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.linkSuggest = new CustomLinkSuggest(plugin);
  }
  /**
   * Initialize the link suggestion system
   */
  initialize() {
    if (this.plugin.settings.fileSorting.sortOnFileCreate) {
      this.plugin.registerEditorSuggest(this.linkSuggest);
    }
  }
  /**
   * Cleanup the link suggestion system
   */
  cleanup() {
  }
  /**
   * Create a new note from selected text and link to it
   */
  async createLinkedNote(selection, editor, view) {
    const { vault } = this.plugin.app;
    const currentFile = view.file;
    if (!currentFile) {
      throw new Error("No active file found");
    }
    const fileName = this.sanitizeFileName(selection);
    const directoryPath = this.determineTargetDirectory(fileName);
    const filePath = (0, import_obsidian4.normalizePath)(`${directoryPath}/${fileName}.md`);
    let file = vault.getAbstractFileByPath(filePath);
    if (!file) {
      await this.plugin.directoryManager.getOrCreateDirectory(directoryPath);
      const content = this.generateNoteContent(selection, currentFile);
      file = await vault.create(filePath, content);
    }
    const linkText = this.generateLinkText(fileName, directoryPath, currentFile);
    editor.replaceSelection(linkText);
    const leaf = this.plugin.app.workspace.activeLeaf;
    if (leaf) {
      await leaf.openFile(file);
    }
  }
  /**
   * Determine the appropriate directory for a new note
   */
  determineTargetDirectory(title) {
    const { documentDirectory } = this.plugin.settings;
    const keywords = title.toLowerCase();
    if (keywords.includes("project") || keywords.includes("work")) {
      return "Journal";
    }
    return documentDirectory || "Documents";
  }
  /**
   * Generate content for a new linked note
   */
  generateNoteContent(title, sourceFile) {
    const { noteTemplate } = this.plugin.settings;
    const currentDate = new Date().toISOString().split("T")[0];
    if (noteTemplate) {
      return noteTemplate.replace(/{{title}}/g, title).replace(/{{date}}/g, currentDate).replace(/{{source}}/g, `[[${sourceFile.basename}]]`);
    }
    return `---
title: ${title}
created: ${currentDate}
source: [[${sourceFile.basename}]]
tags: []
---

# ${title}

`;
  }
  /**
   * Generate appropriate link text based on directory structure
        * Supports directory-relative links like [[/journal/nesting]]
   */
  generateLinkText(fileName, targetDirectory, currentFile) {
    var _a;
    const currentFileDir = ((_a = currentFile.parent) == null ? void 0 : _a.path) || "";
    const baseFolder = this.plugin.settings.baseFolder || "LinkPlugin";
    if (targetDirectory !== currentFileDir) {
      if (targetDirectory.startsWith(baseFolder)) {
        const relativePath = targetDirectory.replace(baseFolder + "/", "");
        return `[[/${relativePath}/${fileName}]]`;
      } else {
        return `[[/${targetDirectory}/${fileName}]]`;
      }
    }
    return `[[${fileName}]]`;
  }
  /**
   * Sanitize a string for use as a filename
   */
  sanitizeFileName(input) {
    return input.replace(REGEX_PATTERNS.INVALID_FILENAME_CHARS, "").replace(/\s+/g, " ").trim().substring(0, 100);
  }
  /**
   * Find all links in a file
   */
  async findLinksInFile(file) {
    const { vault } = this.plugin.app;
    const content = await vault.read(file);
    const links = [];
    let match;
    while ((match = REGEX_PATTERNS.WIKI_LINK.exec(content)) !== null) {
      links.push(match[1]);
    }
    return links;
  }
  /**
   * Find all backlinks to a file
   */
  async findBacklinks(file) {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const backlinks = [];
    for (const potentialSource of files) {
      if (potentialSource.path === file.path)
        continue;
      const links = await this.findLinksInFile(potentialSource);
      if (links.includes(file.basename)) {
        backlinks.push(potentialSource);
      }
    }
    return backlinks;
  }
  /**
   * Find broken links in the vault
   */
  async findBrokenLinks() {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const brokenLinksData = [];
    for (const file of files) {
      const links = await this.findLinksInFile(file);
      const brokenLinks = [];
      for (const link of links) {
        const linkedFile = vault.getAbstractFileByPath(`${link}.md`) || vault.getAbstractFileByPath(link);
        if (!linkedFile) {
          brokenLinks.push(link);
        }
      }
      if (brokenLinks.length > 0) {
        brokenLinksData.push({ file, brokenLinks });
      }
    }
    return brokenLinksData;
  }
  /**
   * Find orphaned notes (notes with no backlinks)
   */
  async findOrphanedNotes() {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const orphanedNotes = [];
    for (const file of files) {
      const backlinks = await this.findBacklinks(file);
      if (backlinks.length === 0) {
        orphanedNotes.push(file);
      }
    }
    return orphanedNotes;
  }
  /**
   * Generate link suggestions based on content similarity
   */
  async generateLinkSuggestions(file, limit = 5) {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const suggestions = [];
    const currentContent = await vault.read(file);
    const currentWords = this.extractWords(currentContent);
    for (const otherFile of files) {
      if (otherFile.path === file.path)
        continue;
      const otherContent = await vault.read(otherFile);
      const otherWords = this.extractWords(otherContent);
      const relevance = this.calculateRelevance(currentWords, otherWords);
      if (relevance > 0.1) {
        suggestions.push({
          title: otherFile.basename,
          path: otherFile.path,
          relevance,
          type: "existing"
        });
      }
    }
    return suggestions.sort((a, b) => b.relevance - a.relevance).slice(0, limit);
  }
  /**
   * Extract meaningful words from content
   */
  extractWords(content) {
    const words = /* @__PURE__ */ new Set();
    const text = content.replace(/[#*`\[\]()]/g, "").toLowerCase().split(/\s+/);
    for (const word of text) {
      if (word.length > 3 && !this.isStopWord(word)) {
        words.add(word);
      }
    }
    return words;
  }
  /**
   * Calculate relevance between two sets of words
   */
  calculateRelevance(words1, words2) {
    const intersection = new Set([...words1].filter((word) => words2.has(word)));
    const union = /* @__PURE__ */ new Set([...words1, ...words2]);
    return intersection.size / union.size;
  }
  /**
   * Check if a word is a stop word
   */
  isStopWord(word) {
    const stopWords = /* @__PURE__ */ new Set([
      "the",
      "a",
      "an",
      "and",
      "or",
      "but",
      "in",
      "on",
      "at",
      "to",
      "for",
      "of",
      "with",
      "by",
      "is",
      "are",
      "was",
      "were",
      "be",
      "been",
      "have",
      "has",
      "had",
      "do",
      "does",
      "did",
      "will",
      "would",
      "could",
      "should",
      "may",
      "might",
      "must",
      "can",
      "this",
      "that",
      "these",
      "those"
    ]);
    return stopWords.has(word);
  }
};

// src/utils/errorHandler.ts
var import_obsidian5 = require("obsidian");
var ErrorHandler = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  handleError(error, context) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`${context}: ${message}`);
    new import_obsidian5.Notice(`${context}: ${message}`);
  }
  showNotice(message, duration) {
    new import_obsidian5.Notice(message, duration);
  }
  showSuccess(message) {
    new import_obsidian5.Notice(message, 3e3);
  }
  showWarning(message) {
    new import_obsidian5.Notice(`\u26A0\uFE0F ${message}`, 5e3);
  }
};

// src/ui/ribbonManager.ts
var import_obsidian6 = require("obsidian");
var RibbonManager = class {
  constructor(plugin) {
    this.ribbonButtons = [];
    this.plugin = plugin;
  }
  /**
   * Initialize ribbon with core journal functionality only
   */
  initializeRibbon() {
    this.clearRibbon();
    this.addCreateFutureNoteButton();
    this.addSettingsButton();
    console.log("Ribbon initialized - Core journal functionality enabled");
  }
  /**
   * Add Create Future Note button - CORE FEATURE with date picker
   */
  addCreateFutureNoteButton() {
    const button = this.plugin.addRibbonIcon(
      "calendar-plus",
      "Create Future Note - Select date to create note",
      async () => {
        try {
          const selectedDate = await this.showDatePicker();
          if (selectedDate) {
            const file = await this.plugin.journalManager.createFutureDailyNote(selectedDate);
            const leaf = this.plugin.app.workspace.getLeaf();
            await leaf.openFile(file);
            const formattedDate = DateService.format(DateService.from(selectedDate), "YYYY-MM-DD");
            this.showSuccess(`Created future note for ${formattedDate}`);
          }
        } catch (error) {
          this.plugin.errorHandler.handleError(error, "Failed to create future note");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Show date picker modal for future note creation - FIXED MODAL API
   */
  async showDatePicker() {
    return new Promise((resolve) => {
      const modal = new import_obsidian6.Modal(this.plugin.app);
      modal.setTitle("Create Future Daily Note");
      const { contentEl } = modal;
      const instructions = contentEl.createEl("p");
      instructions.textContent = "Select a date to create a daily note. This will automatically create the required monthly folders.";
      instructions.style.marginBottom = "1em";
      instructions.style.color = "var(--text-muted)";
      const dateInput = contentEl.createEl("input");
      dateInput.type = "date";
      dateInput.style.width = "100%";
      dateInput.style.padding = "8px";
      dateInput.style.marginBottom = "1em";
      dateInput.style.border = "1px solid var(--background-modifier-border)";
      dateInput.style.borderRadius = "4px";
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      dateInput.value = tomorrow.toISOString().split("T")[0];
      const buttonContainer = contentEl.createDiv();
      buttonContainer.style.display = "flex";
      buttonContainer.style.gap = "8px";
      buttonContainer.style.justifyContent = "flex-end";
      const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
      cancelButton.onclick = () => {
        modal.close();
        resolve(null);
      };
      const createButton = buttonContainer.createEl("button", {
        text: "Create Note",
        cls: "mod-cta"
      });
      createButton.onclick = () => {
        const selectedDate = dateInput.value;
        if (selectedDate) {
          modal.close();
          resolve(selectedDate);
        }
      };
      dateInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          const selectedDate = dateInput.value;
          if (selectedDate) {
            modal.close();
            resolve(selectedDate);
          }
        }
      });
      modal.scope.register([], "Escape", () => {
        modal.close();
        resolve(null);
      });
      modal.open();
      setTimeout(() => dateInput.focus(), 100);
    });
  }
  /**
   * Add Settings button
   */
  addSettingsButton() {
    const button = this.plugin.addRibbonIcon(
      "link",
      "Open Obsidian Link Journal Settings",
      () => {
        try {
          this.plugin.app.setting.open();
          this.plugin.app.setting.openTabById(this.plugin.manifest.id);
        } catch (error) {
          this.plugin.errorHandler.showNotice("Please open Settings \u2192 Community Plugins \u2192 Obsidian Link Journal to configure");
          this.plugin.errorHandler.handleError(error, "Failed to open settings automatically");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Clear all ribbon buttons
   */
  clearRibbon() {
    this.ribbonButtons.forEach((button) => button.remove());
    this.ribbonButtons = [];
  }
  /**
   * Cleanup method for plugin unload
   */
  cleanup() {
    this.clearRibbon();
  }
  /**
   * Update button states based on settings
   */
  updateButtonStates() {
    console.log("Ribbon buttons updated");
  }
  /**
   * Show quick actions menu
   */
  showQuickActionsMenu() {
    const message = `Obsidian Link Journal Quick Actions:
\u2022 Create Today's Note: Open or create today's journal
\u2022 Create Monthly Folders: Set up folder structure
\u2022 Settings: Configure journal management`;
    this.plugin.errorHandler.showNotice(message);
  }
  /**
   * Show success message
   */
  showSuccess(message) {
    this.plugin.errorHandler.showNotice(message);
  }
};

// src/ui/settingsTab.ts
var import_obsidian7 = require("obsidian");
var SettingsTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Link Plugin Settings" });
    containerEl.createEl("p", {
      text: "Simple journal management settings",
      cls: "setting-item-description"
    });
    this.addCoreSettings(containerEl);
    this.addJournalSettings(containerEl);
  }
  addCoreSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F4C1} Core Settings" });
    new import_obsidian7.Setting(containerEl).setName("Base Folder").setDesc("Root folder for journal content (empty = vault root)").addText(
      (text) => text.setPlaceholder("Link").setValue(this.plugin.settings.baseFolder).onChange(async (value) => {
        this.plugin.settings.baseFolder = value.trim();
        await this.plugin.saveSettings();
      })
    ).then((setting) => {
      const textComponent = setting.components[0];
      if (textComponent && textComponent.inputEl) {
        const input = textComponent.inputEl;
        const wrapper = input.parentElement;
        if (wrapper) {
          const prefix = wrapper.createSpan({ text: "/", cls: "path-prefix" });
          wrapper.insertBefore(prefix, input);
          prefix.style.marginRight = "2px";
          prefix.style.opacity = "0.6";
        }
      }
    });
    new import_obsidian7.Setting(containerEl).setName("Custom Template Location").setDesc(
      'Override the default template path (e.g. "templates/Daily Notes Template.md")'
    ).addText(
      (text) => text.setPlaceholder("templates/Daily Notes Template.md").setValue(this.plugin.settings.customTemplateLocation || "").onChange(async (value) => {
        this.plugin.settings.customTemplateLocation = value.trim();
        await this.plugin.saveSettings();
      })
    );
    const info = containerEl.createDiv({ cls: "setting-item-info" });
    info.createEl("div", {
      text: "Suggested daily note template (YAML frontmatter):",
      cls: "setting-item-description"
    });
    const code = info.createEl("pre");
    code.innerText = `---
date: {{date}}
title: {{title}}
---
# {{title}}
`;
    info.createEl("div", {
      text: "You can copy and adapt this for your own templates. The {{date}} and {{title}} variables will be replaced automatically.",
      cls: "setting-item-description"
    });
    new import_obsidian7.Setting(containerEl).setName("Rebuild Journal Structure").setDesc("Recreate the journal folder structure").addButton(
      (button) => button.setButtonText("Rebuild").onClick(async () => {
        try {
          await this.plugin.directoryManager.rebuildDirectoryStructure();
          alert(
            "\u2705 Journal structure rebuilt successfully!\n\nJournal folder structure has been recreated in: " + this.plugin.settings.baseFolder
          );
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          alert(
            "\u274C Failed to rebuild journal structure.\n\nError: " + errorMessage
          );
          this.plugin.errorHandler.handleError(
            error,
            "Failed to rebuild journal structure"
          );
        }
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Setup Templates").setDesc(
      "Create templates directory alongside journal and copy Daily Notes template (works with Templater plugin)"
    ).addButton(
      (button) => button.setButtonText("Setup Templates").onClick(async () => {
        var _a, _b;
        try {
          await this.plugin.directoryManager.setupTemplates();
          const templatesPath = this.plugin.settings.baseFolder ? `${this.plugin.settings.baseFolder}/templates` : "templates";
          const templaterPlugin = (_b = (_a = this.plugin.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["templater-obsidian"];
          const hasTemplater = templaterPlugin && templaterPlugin._loaded;
          const templaterStatus = hasTemplater ? "\n\n\u2705 Templater plugin detected - Template will work with dynamic dates" : "\n\n\u26A0\uFE0F Templater plugin not detected - Template contains Templater syntax that may not render";
          alert(
            "\u2705 Templates setup successfully!\n\nTemplates directory created alongside journal at: " + templatesPath + templaterStatus
          );
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          alert("\u274C Failed to setup templates.\n\nError: " + errorMessage);
          this.plugin.errorHandler.handleError(
            error,
            "Failed to setup templates"
          );
        }
      })
    );
    this.addDailyNotesIntegrationSettings(containerEl);
  }
  addJournalSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F4C5} Journal Settings" });
    new import_obsidian7.Setting(containerEl).setName("Simple Journal Mode").setDesc(
      "Enable: Single journal folder | Disable: Dynamic monthly folders (2025/January/)"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.simpleJournalMode).onChange(async (value) => {
        this.plugin.settings.simpleJournalMode = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (!this.plugin.settings.simpleJournalMode) {
      new import_obsidian7.Setting(containerEl).setName("Year Folder Format").setDesc('Format for year folders (YYYY creates "2025")').addText(
        (text) => text.setPlaceholder("YYYY").setValue(this.plugin.settings.journalYearFormat).onChange(async (value) => {
          if (value.trim()) {
            this.plugin.settings.journalYearFormat = value.trim();
            await this.plugin.saveSettings();
          }
        })
      );
      new import_obsidian7.Setting(containerEl).setName("Month Folder Format").setDesc('Format for month folders (MM-MMMM creates "07-July")').addText(
        (text) => text.setPlaceholder("MM-MMMM").setValue(this.plugin.settings.journalMonthFormat).onChange(async (value) => {
          if (value.trim()) {
            this.plugin.settings.journalMonthFormat = value.trim();
            await this.plugin.saveSettings();
          }
        })
      );
    }
    new import_obsidian7.Setting(containerEl).setName("Daily Note Format").setDesc("Format for daily note filenames").addText(
      (text) => text.setPlaceholder("YYYY-MM-DD dddd").setValue(this.plugin.settings.journalDateFormat).onChange(async (value) => {
        if (value.trim()) {
          this.plugin.settings.journalDateFormat = value.trim();
          await this.plugin.saveSettings();
        }
      })
    );
  }
  /**
   * Adds Daily Notes integration settings with backup and restore functionality
   */
  addDailyNotesIntegrationSettings(containerEl) {
    containerEl.createEl("h2", { text: "Daily Notes Integration" });
    containerEl.createEl("p", {
      text: "Control how this plugin integrates with Obsidian's Daily Notes plugin. Your original settings will be backed up automatically.",
      cls: "setting-item-description"
    });
    new import_obsidian7.Setting(containerEl).setName("Enable Daily Notes Integration").setDesc(
      "Allow this plugin to update Daily Notes plugin settings to use our folder structure"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.dailyNotesIntegration.enabled).onChange(async (value) => {
        this.plugin.settings.dailyNotesIntegration.enabled = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.dailyNotesIntegration.enabled) {
      containerEl.createEl("hr");
      new import_obsidian7.Setting(containerEl).setName("Apply Integration Settings").setDesc(
        "Apply the integration to Daily Notes plugin (creates backup automatically)"
      ).addButton(
        (button) => button.setButtonText("Apply Now").onClick(async () => {
          try {
            await this.plugin.updateDailyNotesSettings();
            this.display();
            this.showStatus(
              containerEl,
              "\u2705 Daily Notes integration settings applied successfully! Your original settings have been backed up and can be restored at any time.",
              true
            );
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.showStatus(
              containerEl,
              "\u274C Failed to apply integration settings. " + errorMessage,
              false
            );
            this.plugin.errorHandler.handleError(
              error,
              "Failed to apply Daily Notes integration"
            );
          }
        })
      );
      const backup = this.plugin.settings.dailyNotesIntegration.backup;
      if (backup) {
        containerEl.createEl("hr");
        const backupDate = new Date(backup.timestamp).toLocaleString();
        new import_obsidian7.Setting(containerEl).setName("\u{1F4E6} Backup Information").setDesc(
          `Backup created: ${backupDate} (${backup.pluginType} plugin)`
        );
      }
    }
    if (this.plugin.settings.dailyNotesIntegration.backup) {
      containerEl.createEl("hr");
      containerEl.createEl("h3", {
        text: "\u26A0\uFE0F Danger Zone",
        cls: "danger-zone-header"
      });
      const dangerContainer = containerEl.createDiv({ cls: "danger-zone" });
      dangerContainer.createEl("p", {
        text: "\u26A0\uFE0F WARNING: This will restore your original Daily Notes settings and disable all integration. This action cannot be undone.",
        cls: "danger-warning"
      });
      new import_obsidian7.Setting(dangerContainer).setName("\u{1F504} Restore Original Settings").setDesc(
        "Restore Daily Notes plugin to your original settings and disable integration"
      ).addButton(
        (button) => button.setButtonText("Restore & Disable").setClass("mod-warning").onClick(async () => {
          const confirmed = confirm(
            "\u26A0\uFE0F CONFIRM RESTORE\n\nThis will:\n\u2022 Restore your original Daily Notes settings\n\u2022 Disable all integration\n\u2022 Delete the backup\n\nThis action cannot be undone. Continue?"
          );
          if (confirmed) {
            try {
              await this.plugin.restoreDailyNotesSettings();
              this.display();
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : String(error);
              alert(
                "\u274C Failed to restore settings.\n\nError: " + errorMessage
              );
            }
          }
        })
      );
      const style = document.createElement("style");
      style.textContent = `
        .danger-zone-header {
          color: var(--text-error);
          margin-top: 2em;
        }
        .danger-zone {
          border: 1px solid var(--background-modifier-error);
          border-radius: 6px;
          padding: 16px;
          background: var(--background-modifier-error-hover);
        }
        .danger-warning {
          color: var(--text-error);
          font-weight: 500;
          margin-bottom: 16px;
        }
      `;
      containerEl.appendChild(style);
    }
  }
  // Helper to show status/feedback message
  showStatus(containerEl, message, success) {
    const status = containerEl.createDiv({ cls: "setting-item-info" });
    status.style.marginTop = "12px";
    status.style.marginBottom = "12px";
    status.style.color = success ? "var(--text-success)" : "var(--text-error)";
    status.style.fontWeight = "bold";
    status.innerText = message;
  }
};

// src/main.ts
var LinkPlugin = class extends import_obsidian8.Plugin {
  async onload() {
    console.log(
      "Loading Obsidian Link Journal v2.2.0 - Pure Journal Management..."
    );
    try {
      DateService.initialize();
      await this.loadSettings();
      this.errorHandler = new ErrorHandler(this);
      this.directoryManager = new DirectoryManager(this);
      this.journalManager = new JournalManager(this);
      this.linkManager = new LinkManager(this);
      this.ribbonManager = new RibbonManager(this);
      this.addSettingTab(new SettingsTab(this.app, this));
      this.ribbonManager.initializeRibbon();
      this.linkManager.initialize();
      this.registerCommands();
      this.registerEventHandlers();
      await this.directoryManager.rebuildDirectoryStructure();
      await this.journalManager.checkAndCreateCurrentMonthFolder();
      await this.updateDailyNotesSettings();
      this.startDateChangeMonitoring();
      const debugInfo = DateService.getDebugInfo();
      console.log("DateService initialized:", debugInfo);
      console.log("Today:", DateService.today());
      console.log("Current month:", DateService.currentMonth());
      this.errorHandler.showNotice(
        "Obsidian Link Journal loaded - Pure journal management ready!"
      );
      console.log(
        "Obsidian Link Journal loaded successfully - Core journal functionality enabled"
      );
    } catch (error) {
      console.error("Failed to load Link Plugin:", error);
      if (this.errorHandler) {
        this.errorHandler.handleError(error, "Plugin initialization failed");
      }
    }
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = validateSettings(loadedData || {});
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.ribbonManager) {
      this.ribbonManager.updateButtonStates();
    }
  }
  registerCommands() {
    this.addCommand({
      id: COMMAND_IDS.CREATE_LINKED_NOTE,
      name: "Create Linked Note from Selection",
      editorCallback: (editor, view) => {
        try {
          const selection = editor.getSelection();
          if (selection) {
            if ("previewMode" in view) {
              this.linkManager.createLinkedNote(selection, editor, view);
            } else {
              this.errorHandler.handleError(
                new Error("Invalid view type"),
                "Please use this command in a markdown view"
              );
            }
          } else {
            this.errorHandler.handleError(
              new Error("No text selected"),
              "Please select text to create a linked note"
            );
          }
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create linked note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.REBUILD_DIRECTORY,
      name: "Rebuild Directory Structure",
      callback: () => {
        try {
          this.directoryManager.rebuildDirectoryStructure();
        } catch (error) {
          this.errorHandler.handleError(
            error,
            "Failed to rebuild directory structure"
          );
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.OPEN_TODAY_JOURNAL,
      name: "Open Today's Journal",
      callback: () => {
        try {
          this.journalManager.openTodayJournal();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to open today's journal");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_TODAY_NOTE,
      name: "Create Today's Daily Note",
      callback: async () => {
        try {
          const file = await this.journalManager.createTodayNote();
          const leaf = this.app.workspace.getLeaf();
          await leaf.openFile(file);
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create today's note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_FUTURE_NOTE,
      name: "Create Future Daily Note",
      callback: async () => {
        try {
          const dateInput = await this.promptForDate();
          if (dateInput) {
            const file = await this.journalManager.createFutureDailyNote(
              dateInput
            );
            const leaf = this.app.workspace.getLeaf();
            await leaf.openFile(file);
            this.errorHandler.showNotice(
              `Created future note for ${DateService.format(
                DateService.from(dateInput),
                "YYYY-MM-DD"
              )}`
            );
          }
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create future note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_MONTHLY_FOLDERS,
      name: "Create Monthly Folders for Current Year",
      callback: async () => {
        try {
          const startOfYear = DateService.startOfYear();
          const endOfYear = DateService.endOfYear();
          await this.journalManager.createMonthlyFoldersForRange(
            startOfYear,
            endOfYear
          );
          this.errorHandler.showNotice(
            "Monthly folders created for current year"
          );
        } catch (error) {
          this.errorHandler.handleError(
            error,
            "Failed to create monthly folders"
          );
        }
      }
    });
    this.addCommand({
      id: "show-ribbon-actions",
      name: "Show Ribbon Quick Actions",
      callback: () => {
        try {
          this.ribbonManager.showQuickActionsMenu();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to show ribbon actions");
        }
      }
    });
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if ("stat" in file && "basename" in file && "extension" in file && file.path.includes(this.settings.journalRootFolder)) {
          this.journalManager.updateJournalLinks(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (this.settings.debugMode && file.path.includes(this.settings.journalRootFolder)) {
          console.log("Journal file modified:", file.path);
        }
      })
    );
  }
  /**
   * Prompt user for a date input
   */
  async promptForDate() {
    return new Promise((resolve) => {
      const modal = new import_obsidian8.Modal(this.app);
      modal.setTitle("Create Future Daily Note");
      const { contentEl } = modal;
      contentEl.createEl("p", {
        text: "Select a date to create a daily note. This will automatically create the required monthly folders.",
        cls: "modal-description"
      });
      const inputContainer = contentEl.createDiv({
        cls: "date-input-container"
      });
      const input = inputContainer.createEl("input", {
        type: "date",
        value: DateService.today(),
        cls: "date-input"
      });
      contentEl.createDiv({ cls: "date-picker-spacer" });
      const buttonContainer = contentEl.createDiv({
        cls: "modal-button-container"
      });
      const createButton = buttonContainer.createEl("button", {
        text: "Create Note",
        cls: "mod-cta"
      });
      const cancelButton = buttonContainer.createEl("button", {
        text: "Cancel"
      });
      const style = document.createElement("style");
      style.textContent = `
        .date-input-container {
          margin: 16px 0;
          position: relative;
          z-index: 1;
        }
        .date-input {
          width: 100%;
          padding: 8px 12px;
          border: 1px solid var(--background-modifier-border);
          border-radius: 4px;
          background: var(--background-primary);
          color: var(--text-normal);
          font-size: 14px;
        }
        .date-picker-spacer {
          height: 40px;
        }
        .modal-button-container {
          display: flex;
          gap: 8px;
          justify-content: flex-end;
          margin-top: 20px;
        }
        .modal-description {
          margin-bottom: 16px;
          color: var(--text-muted);
        }
      `;
      contentEl.appendChild(style);
      setTimeout(() => input.focus(), 100);
      createButton.onclick = () => {
        const dateValue = input.value;
        if (dateValue) {
          modal.close();
          resolve(dateValue);
        }
      };
      cancelButton.onclick = () => {
        modal.close();
        resolve(null);
      };
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          createButton.click();
        } else if (e.key === "Escape") {
          cancelButton.click();
        }
      });
      modal.open();
    });
  }
  /**
   * Start monitoring for date changes to automatically create new monthly folders
   */
  startDateChangeMonitoring() {
    let lastCheckedMonth = DateService.format(DateService.now(), "YYYY-MM");
    this.registerInterval(
      window.setInterval(async () => {
        try {
          const currentMonth = DateService.format(DateService.now(), "YYYY-MM");
          if (currentMonth !== lastCheckedMonth) {
            console.log(
              `Month changed from ${lastCheckedMonth} to ${currentMonth} - creating new monthly folder`
            );
            await this.journalManager.checkAndCreateCurrentMonthFolder();
            await this.updateDailyNotesSettings();
            lastCheckedMonth = currentMonth;
            const monthName = DateService.format(DateService.now(), "MMMM YYYY");
            this.errorHandler.showNotice(
              `\u{1F4C5} New month detected: ${monthName} folder created`
            );
          }
        } catch (error) {
          console.error("Error in date change monitoring:", error);
        }
      }, 60 * 60 * 1e3)
      // Check every hour
    );
    console.log(
      "Date change monitoring started - will auto-create monthly folders"
    );
  }
  /**
   * Update Obsidian's Daily Notes plugin settings to use our folder structure
   * Only updates if integration is enabled and specific controls are enabled
   */
  async updateDailyNotesSettings() {
    var _a, _b, _c, _d;
    if (!this.settings.dailyNotesIntegration.enabled) {
      return;
    }
    try {
      const dailyNotesPlugin = (_b = (_a = this.app.internalPlugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["daily-notes"];
      if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        await this.updateCorePluginSettings(dailyNotesPlugin);
      } else {
        const communityDailyNotes = (_d = (_c = this.app.plugins) == null ? void 0 : _c.plugins) == null ? void 0 : _d["daily-notes"];
        if (communityDailyNotes) {
          await this.updateCommunityPluginSettings(communityDailyNotes);
        } else {
          console.log(
            "Daily Notes plugin not found or not enabled - using plugin folder structure only"
          );
        }
      }
    } catch (error) {
      console.log(
        "Daily Notes integration skipped:",
        error instanceof Error ? error.message : String(error)
      );
    }
  }
  /**
   * Updates core Daily Notes plugin settings with backup
   */
  async updateCorePluginSettings(dailyNotesPlugin) {
    const dailyNotesSettings = dailyNotesPlugin.instance.options;
    if (!this.settings.dailyNotesIntegration.backup) {
      await this.createDailyNotesBackup("core", dailyNotesSettings);
    }
    const currentDate = DateService.now();
    const monthlyFolderPath = this.journalManager.getMonthlyFolderPath(currentDate);
    dailyNotesSettings.folder = monthlyFolderPath;
    dailyNotesSettings.format = this.settings.journalDateFormat;
    const templatesPath = this.settings.customTemplateLocation ? this.settings.customTemplateLocation : this.settings.baseFolder ? `${this.settings.baseFolder}/templates/Daily Notes Template.md` : "templates/Daily Notes Template.md";
    dailyNotesSettings.template = templatesPath;
    console.log(`Updated Core Daily Notes plugin settings`);
    this.errorHandler.showNotice(`\u2705 Daily Notes settings updated`);
  }
  /**
   * Updates community Daily Notes plugin settings with backup
   */
  async updateCommunityPluginSettings(communityDailyNotes) {
    if (!this.settings.dailyNotesIntegration.backup) {
      await this.createDailyNotesBackup(
        "community",
        communityDailyNotes.settings
      );
    }
    const currentDate = DateService.now();
    const monthlyFolderPath = this.journalManager.getMonthlyFolderPath(currentDate);
    communityDailyNotes.settings.folder = monthlyFolderPath;
    communityDailyNotes.settings.format = this.settings.journalDateFormat;
    const templatesPath = this.settings.customTemplateLocation ? this.settings.customTemplateLocation : this.settings.baseFolder ? `${this.settings.baseFolder}/templates/Daily Notes Template.md` : "templates/Daily Notes Template.md";
    communityDailyNotes.settings.template = templatesPath;
    await communityDailyNotes.saveSettings();
    console.log(`Updated Community Daily Notes plugin settings`);
    this.errorHandler.showNotice(`\u2705 Daily Notes settings updated`);
  }
  /**
   * Creates a backup of current Daily Notes settings
   */
  async createDailyNotesBackup(pluginType, currentSettings) {
    this.settings.dailyNotesIntegration.backup = {
      timestamp: new Date().toISOString(),
      pluginType,
      originalSettings: { ...currentSettings }
    };
    await this.saveSettings();
    console.log(`Created Daily Notes backup for ${pluginType} plugin`);
  }
  /**
   * Restores Daily Notes settings from backup
   */
  async restoreDailyNotesSettings() {
    var _a, _b, _c, _d;
    const backup = this.settings.dailyNotesIntegration.backup;
    if (!backup) {
      this.errorHandler.showNotice("\u274C No backup found to restore");
      return;
    }
    try {
      if (backup.pluginType === "core") {
        const dailyNotesPlugin = (_b = (_a = this.app.internalPlugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["daily-notes"];
        if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
          Object.assign(
            dailyNotesPlugin.instance.options,
            backup.originalSettings
          );
          console.log("Restored Core Daily Notes settings from backup");
        }
      } else {
        const communityDailyNotes = (_d = (_c = this.app.plugins) == null ? void 0 : _c.plugins) == null ? void 0 : _d["daily-notes"];
        if (communityDailyNotes) {
          Object.assign(communityDailyNotes.settings, backup.originalSettings);
          await communityDailyNotes.saveSettings();
          console.log("Restored Community Daily Notes settings from backup");
        }
      }
      this.settings.dailyNotesIntegration.enabled = false;
      this.settings.dailyNotesIntegration.backup = null;
      await this.saveSettings();
      this.errorHandler.showNotice(
        "\u2705 Daily Notes settings restored from backup"
      );
    } catch (error) {
      this.errorHandler.handleError(
        error,
        "Failed to restore Daily Notes settings"
      );
    }
  }
  onunload() {
    console.log("Obsidian Link Journal unloaded");
    if (this.linkManager) {
      this.linkManager.cleanup();
    }
    if (this.ribbonManager) {
      this.ribbonManager.cleanup();
    }
  }
};
