/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/constants.ts
var DEFAULT_BASE_FOLDER, DEFAULT_DIRECTORIES, OPTIONAL_DIRECTORIES, COMMAND_IDS, RIBBON_BUTTONS, DATE_FORMATS, DEFAULT_TEMPLATES, REGEX_PATTERNS;
var init_constants = __esm({
  "src/constants.ts"() {
    "use strict";
    DEFAULT_BASE_FOLDER = "LinkPlugin";
    DEFAULT_DIRECTORIES = [
      "journal",
      "templates",
      "workspace",
      "reference"
    ];
    OPTIONAL_DIRECTORIES = [
      "context",
      "schema",
      "Projects"
    ];
    COMMAND_IDS = {
      CREATE_LINKED_NOTE: "create-linked-note",
      REBUILD_DIRECTORY: "rebuild-directory-structure",
      OPEN_TODAY_JOURNAL: "open-today-journal",
      CREATE_TODAY_NOTE: "create-today-note",
      CREATE_FUTURE_NOTE: "create-future-note",
      CREATE_MONTHLY_FOLDERS: "create-monthly-folders",
      EXPAND_SHORTCODE: "expand-shortcode",
      SHOW_LINK_SUGGESTIONS: "show-link-suggestions"
    };
    RIBBON_BUTTONS = {
      TODAY_JOURNAL: {
        icon: "calendar-days",
        title: "Open Today's Journal",
        tooltip: "Open or create today's journal entry"
      },
      CREATE_NOTE: {
        icon: "file-plus",
        title: "Create Linked Note",
        tooltip: "Create a new linked note from selected text"
      },
      MONTHLY_FOLDERS: {
        icon: "folder-plus",
        title: "Create Monthly Folders",
        tooltip: "Create monthly folders for the current year"
      },
      // SHORTCODE_HELP: {
      //   icon: 'zap',
      //   title: 'Shortcode Help',
      //   tooltip: 'Show available shortcodes and examples'
      // }, // Deprecated - moved to quarantine
      REBUILD_STRUCTURE: {
        icon: "folder-sync",
        title: "Rebuild Directory Structure",
        tooltip: "Rebuild the plugin's directory structure"
      },
      PLUGIN_SETTINGS: {
        icon: "settings",
        title: "Link Plugin Settings",
        tooltip: "Open Link Plugin settings"
      }
    };
    DATE_FORMATS = {
      DEFAULT_JOURNAL: "YYYY-MM-DD dddd",
      ISO_DATE: "YYYY-MM-DD",
      FOLDER_FORMAT: "YYYY/MM"
    };
    DEFAULT_TEMPLATES = {
      JOURNAL: `# {{date}}

## Daily Log

## Tasks
- [ ] 

## Notes

## Reflection

---
Previous: {{previous}}
Next: {{next}}
`,
      NOTE: `---
title: {{title}}
created: {{date}}
source: {{source}}
tags: []
---

# {{title}}

`
    };
    REGEX_PATTERNS = {
      WIKI_LINK: /\[\[(.*?)\]\]/g,
      SHORTCODE: /[\w>+*{}\[\]()]+$/,
      DATE_FILENAME: /\d{4}-\d{2}-\d{2}/,
      INVALID_FILENAME_CHARS: /[\\/:*?"<>|]/g
    };
  }
});

// src/settings/directorySettings.ts
var DirectorySettings;
var init_directorySettings = __esm({
  "src/settings/directorySettings.ts"() {
    "use strict";
    init_constants();
    DirectorySettings = class {
      static getDefaults() {
        return {
          baseFolder: DEFAULT_BASE_FOLDER,
          // Creates all directories under 'LinkPlugin/' by default
          directoryStructure: DEFAULT_DIRECTORIES,
          restrictedDirectories: [],
          documentDirectory: "workspace",
          // Updated to match README structure
          journalRootFolder: "journal"
          // Updated to match README structure
        };
      }
      static validate(settings) {
        const validated = {};
        if (settings.baseFolder && typeof settings.baseFolder === "string") {
          validated.baseFolder = settings.baseFolder.trim();
        }
        if (settings.directoryStructure && Array.isArray(settings.directoryStructure)) {
          validated.directoryStructure = settings.directoryStructure;
        }
        if (settings.restrictedDirectories && Array.isArray(settings.restrictedDirectories)) {
          validated.restrictedDirectories = settings.restrictedDirectories;
        }
        if (settings.documentDirectory && typeof settings.documentDirectory === "string") {
          validated.documentDirectory = settings.documentDirectory;
        }
        if (settings.journalRootFolder && typeof settings.journalRootFolder === "string") {
          validated.journalRootFolder = settings.journalRootFolder;
        }
        return validated;
      }
    };
  }
});

// src/settings/journalSettings.ts
var JournalSettings;
var init_journalSettings = __esm({
  "src/settings/journalSettings.ts"() {
    "use strict";
    init_constants();
    JournalSettings = class {
      static getDefaults() {
        return {
          journalDateFormat: DATE_FORMATS.DEFAULT_JOURNAL,
          journalFolderFormat: DATE_FORMATS.FOLDER_FORMAT,
          journalTemplate: DEFAULT_TEMPLATES.JOURNAL,
          enableDynamicFolders: false,
          // Disabled by default for MVP
          simpleJournalMode: true
          // Simple mode enabled by default
        };
      }
      static validate(settings) {
        const validated = {};
        if (settings.journalDateFormat && typeof settings.journalDateFormat === "string") {
          validated.journalDateFormat = settings.journalDateFormat;
        }
        if (settings.journalFolderFormat && typeof settings.journalFolderFormat === "string") {
          validated.journalFolderFormat = settings.journalFolderFormat;
        }
        if (settings.journalTemplate && typeof settings.journalTemplate === "string") {
          validated.journalTemplate = settings.journalTemplate;
        }
        return validated;
      }
      static isValidDateFormat(format) {
        try {
          const validTokens = ["YYYY", "MM", "DD", "dddd", "MMM", "MMMM"];
          return validTokens.some((token) => format.includes(token));
        } catch (e) {
          return false;
        }
      }
    };
  }
});

// src/settings/noteSettings.ts
var NoteSettings;
var init_noteSettings = __esm({
  "src/settings/noteSettings.ts"() {
    "use strict";
    init_constants();
    NoteSettings = class {
      static getDefaults() {
        return {
          noteTemplate: DEFAULT_TEMPLATES.NOTE,
          openNewNote: true
        };
      }
      static validate(settings) {
        const validated = {};
        if (settings.noteTemplate && typeof settings.noteTemplate === "string") {
          validated.noteTemplate = settings.noteTemplate;
        }
        if (typeof settings.openNewNote === "boolean") {
          validated.openNewNote = settings.openNewNote;
        }
        return validated;
      }
      static validateTemplate(template) {
        const errors = [];
        const requiredVars = ["{{title}}"];
        const missingVars = requiredVars.filter((varName) => !template.includes(varName));
        if (missingVars.length > 0) {
          errors.push(`Missing required template variables: ${missingVars.join(", ")}`);
        }
        const templateVarPattern = /\{\{[^}]*\}\}/g;
        const matches = template.match(templateVarPattern);
        if (matches) {
          matches.forEach((match) => {
            if (!match.endsWith("}}")) {
              errors.push(`Malformed template variable: ${match}`);
            }
          });
        }
        return {
          isValid: errors.length === 0,
          errors
        };
      }
    };
  }
});

// src/settings/generalSettings.ts
var GeneralSettings;
var init_generalSettings = __esm({
  "src/settings/generalSettings.ts"() {
    "use strict";
    GeneralSettings = class {
      static getDefaults() {
        return {
          debugMode: false,
          fileSorting: {
            enableAutoSorting: false,
            sortOnFileCreate: false,
            sortOnFileModify: false
          }
        };
      }
      static validate(settings) {
        const validated = {};
        if (typeof settings.debugMode === "boolean") {
          validated.debugMode = settings.debugMode;
        }
        return validated;
      }
      static getDebugInfo() {
        return {
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          language: navigator.language
        };
      }
    };
  }
});

// src/settings/settingsValidator.ts
function validateSettings(settings) {
  const validatedSettings = {
    ...DirectorySettings.getDefaults(),
    ...JournalSettings.getDefaults(),
    ...NoteSettings.getDefaults(),
    // ...ShortcodeSettings.getDefaults(), // Deprecated - moved to quarantine
    ...GeneralSettings.getDefaults()
  };
  const directoryValidation = DirectorySettings.validate(settings);
  const journalValidation = JournalSettings.validate(settings);
  const noteValidation = NoteSettings.validate(settings);
  const generalValidation = GeneralSettings.validate(settings);
  Object.assign(
    validatedSettings,
    directoryValidation,
    journalValidation,
    noteValidation,
    // shortcodeValidation, // Deprecated - moved to quarantine
    generalValidation
  );
  return validatedSettings;
}
function validateSettingsWithDetails(settings) {
  const errors = [];
  const warnings = [];
  if (settings.noteTemplate) {
    const templateValidation = NoteSettings.validateTemplate(settings.noteTemplate);
    if (!templateValidation.isValid) {
      errors.push(...templateValidation.errors);
    }
  }
  if (settings.journalDateFormat && !JournalSettings.isValidDateFormat(settings.journalDateFormat)) {
    warnings.push("Invalid journal date format provided, using default");
  }
  if (settings.directoryStructure && settings.directoryStructure.length === 0) {
    warnings.push("Empty directory structure provided, using defaults");
  }
  const validatedSettings = validateSettings(settings);
  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    validatedSettings
  };
}
var init_settingsValidator = __esm({
  "src/settings/settingsValidator.ts"() {
    "use strict";
    init_directorySettings();
    init_journalSettings();
    init_noteSettings();
    init_generalSettings();
  }
});

// src/settings/defaultSettings.ts
var DEFAULT_SETTINGS;
var init_defaultSettings = __esm({
  "src/settings/defaultSettings.ts"() {
    "use strict";
    init_directorySettings();
    init_journalSettings();
    init_noteSettings();
    init_generalSettings();
    DEFAULT_SETTINGS = {
      ...DirectorySettings.getDefaults(),
      ...JournalSettings.getDefaults(),
      ...NoteSettings.getDefaults(),
      // ...ShortcodeSettings.getDefaults(), // Deprecated - moved to quarantine
      ...GeneralSettings.getDefaults()
    };
  }
});

// src/settings.ts
var settings_exports = {};
__export(settings_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  DirectorySettings: () => DirectorySettings,
  GeneralSettings: () => GeneralSettings,
  JournalSettings: () => JournalSettings,
  NoteSettings: () => NoteSettings,
  validateSettings: () => validateSettings,
  validateSettingsWithDetails: () => validateSettingsWithDetails
});
var init_settings = __esm({
  "src/settings.ts"() {
    "use strict";
    init_settingsValidator();
    init_directorySettings();
    init_journalSettings();
    init_noteSettings();
    init_generalSettings();
    init_defaultSettings();
  }
});

// src/utils/errorHandler.ts
var import_obsidian, ErrorHandler;
var init_errorHandler = __esm({
  "src/utils/errorHandler.ts"() {
    "use strict";
    import_obsidian = require("obsidian");
    ErrorHandler = class {
      constructor(plugin) {
        this.plugin = plugin;
      }
      handleError(error, context) {
        const message = error instanceof Error ? error.message : String(error);
        console.error(`${context}: ${message}`);
        new import_obsidian.Notice(`${context}: ${message}`);
      }
      showNotice(message, duration) {
        new import_obsidian.Notice(message, duration);
      }
      showSuccess(message) {
        new import_obsidian.Notice(message, 3e3);
      }
      showWarning(message) {
        new import_obsidian.Notice(`\u26A0\uFE0F ${message}`, 5e3);
      }
    };
  }
});

// src/managers/fileSortingManager.ts
var fileSortingManager_exports = {};
__export(fileSortingManager_exports, {
  FileSortingManager: () => FileSortingManager
});
var FileSortingManager;
var init_fileSortingManager = __esm({
  "src/managers/fileSortingManager.ts"() {
    "use strict";
    init_errorHandler();
    FileSortingManager = class {
      constructor(vault, metadataCache, settings, directoryManager) {
        // File type mappings for media files
        this.FILE_TYPE_MAPPINGS = {
          images: [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".webp", ".ico"],
          videos: [".mp4", ".avi", ".mov", ".wmv", ".flv", ".webm", ".mkv", ".m4v"],
          pdfs: [".pdf"],
          audio: [".mp3", ".wav", ".flac", ".aac", ".ogg", ".wma", ".m4a"],
          docs: [".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx", ".rtf", ".odt"]
        };
        this.vault = vault;
        this.metadataCache = metadataCache;
        this.settings = settings;
        this.directoryManager = directoryManager;
        this.errorHandler = new ErrorHandler(null);
      }
      /**
       * Extract metadata from a file
       */
      async extractMetadata(file) {
        var _a, _b, _c;
        const frontmatter = (_a = this.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        const tags = ((_c = (_b = this.metadataCache.getFileCache(file)) == null ? void 0 : _b.tags) == null ? void 0 : _c.map((tag) => tag.tag)) || [];
        return {
          file,
          extension: file.extension.toLowerCase(),
          size: file.stat.size,
          createdDate: new Date(file.stat.ctime),
          modifiedDate: new Date(file.stat.mtime),
          frontmatter,
          tags,
          category: frontmatter == null ? void 0 : frontmatter.category,
          type: frontmatter == null ? void 0 : frontmatter.type,
          priority: frontmatter == null ? void 0 : frontmatter.priority
        };
      }
      /**
       * Determine target directory for a file based on sorting rules
       */
      determineTargetDirectory(metadata) {
        const baseDir = this.settings.baseFolder || "LinkPlugin";
        for (const rule of this.getCustomRules()) {
          if (rule.condition(metadata)) {
            return `${baseDir}/${rule.targetDirectory}`;
          }
        }
        const fileTypeDir = this.getFileTypeDirectory(metadata.extension);
        if (fileTypeDir) {
          return `${baseDir}/reference/files/${fileTypeDir}`;
        }
        if (metadata.extension === "md") {
          return this.getMarkdownTargetDirectory(metadata, baseDir);
        }
        return null;
      }
      /**
       * Get target directory for file types
       */
      getFileTypeDirectory(extension) {
        for (const [category, extensions] of Object.entries(this.FILE_TYPE_MAPPINGS)) {
          if (extensions.includes(`.${extension}`)) {
            return category;
          }
        }
        return extension === "md" ? null : "other";
      }
      /**
       * Determine target directory for markdown files based on frontmatter
       */
      getMarkdownTargetDirectory(metadata, baseDir) {
        const { frontmatter, file } = metadata;
        if (!frontmatter)
          return null;
        if (frontmatter.type === "journal" || frontmatter.category === "journal") {
          return `${baseDir}/journal`;
        }
        if (frontmatter.type === "project" || frontmatter.category === "project") {
          return `${baseDir}/workspace`;
        }
        if (frontmatter.type === "reference" || frontmatter.category === "reference") {
          return `${baseDir}/reference`;
        }
        if (frontmatter.type === "template" || frontmatter.category === "template") {
          return `${baseDir}/templates`;
        }
        if (metadata.tags.includes("#journal")) {
          return `${baseDir}/journal`;
        }
        if (metadata.tags.includes("#project")) {
          return `${baseDir}/workspace`;
        }
        if (metadata.tags.includes("#reference")) {
          return `${baseDir}/reference`;
        }
        return null;
      }
      /**
       * Get custom sorting rules from settings
       */
      getCustomRules() {
        return [
          {
            name: "High Priority Notes",
            condition: (metadata) => metadata.priority !== void 0 && metadata.priority >= 8,
            targetDirectory: "workspace/priority",
            priority: 100,
            description: "Notes with priority 8 or higher"
          },
          {
            name: "Meeting Notes",
            condition: (metadata) => {
              var _a;
              return ((_a = metadata.frontmatter) == null ? void 0 : _a.type) === "meeting" || metadata.tags.includes("#meeting");
            },
            targetDirectory: "workspace/meetings",
            priority: 90,
            description: "Meeting notes and minutes"
          },
          {
            name: "Daily Notes",
            condition: (metadata) => {
              const fileName = metadata.file.basename;
              return /^\d{4}-\d{2}-\d{2}$/.test(fileName);
            },
            targetDirectory: "journal",
            priority: 80,
            description: "Daily notes with YYYY-MM-DD format"
          }
        ];
      }
      /**
       * Sort a single file
       */
      async sortFile(file, dryRun = false) {
        var _a;
        try {
          const metadata = await this.extractMetadata(file);
          const targetDir = this.determineTargetDirectory(metadata);
          if (!targetDir) {
            return {
              moved: false,
              from: file.path,
              to: file.path,
              reason: "No sorting rule applies"
            };
          }
          const currentDir = ((_a = file.parent) == null ? void 0 : _a.path) || "";
          if (currentDir === targetDir) {
            return {
              moved: false,
              from: file.path,
              to: file.path,
              reason: "Already in correct location"
            };
          }
          if (this.shouldExcludeFile(file)) {
            return {
              moved: false,
              from: file.path,
              to: file.path,
              reason: "File excluded from sorting"
            };
          }
          if (dryRun) {
            return {
              moved: true,
              from: file.path,
              to: `${targetDir}/${file.name}`,
              reason: "Would be moved (dry run)"
            };
          }
          await this.directoryManager.getOrCreateDirectory(targetDir);
          const newPath = `${targetDir}/${file.name}`;
          await this.vault.rename(file, newPath);
          return {
            moved: true,
            from: file.path,
            to: newPath,
            reason: "Moved successfully"
          };
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          this.errorHandler.handleError(error, `Failed to sort file: ${file.path}`);
          return {
            moved: false,
            from: file.path,
            to: file.path,
            reason: `Error: ${errorMessage}`
          };
        }
      }
      /**
       * Check if file should be excluded from sorting
       */
      shouldExcludeFile(file) {
        const excludePatterns = [
          ".obsidian",
          ".git",
          ".gitignore",
          "node_modules",
          "quarantine"
        ];
        const filePath = file.path.toLowerCase();
        return excludePatterns.some((pattern) => filePath.includes(pattern.toLowerCase()));
      }
      /**
       * Bulk sort all files in the vault
       */
      async bulkSort(dryRun = false) {
        const results = [];
        let processed = 0;
        let moved = 0;
        let skipped = 0;
        let errors = 0;
        const allFiles = this.vault.getFiles();
        for (const file of allFiles) {
          if (this.shouldExcludeFile(file)) {
            skipped++;
            continue;
          }
          const result = await this.sortFile(file, dryRun);
          results.push(result);
          processed++;
          if (result.moved && !dryRun) {
            moved++;
          } else if (result.reason.startsWith("Error:")) {
            errors++;
          } else {
            skipped++;
          }
        }
        return { processed, moved, skipped, errors, results };
      }
      /**
       * Sort file on creation/modification if auto-sort is enabled
       */
      async autoSort(file) {
        var _a;
        if (!((_a = this.settings.fileSorting) == null ? void 0 : _a.enableAutoSorting)) {
          return;
        }
        setTimeout(async () => {
          await this.sortFile(file);
        }, 100);
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinkPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");
init_settings();

// src/ui/settingsTab.ts
var import_obsidian2 = require("obsidian");
init_settings();

// src/services/dateService.ts
var DateService = class {
  /**
   * Initialize the date service with Obsidian's moment instance
   * This should be called once when the plugin loads
   */
  static initialize() {
    this.moment = window.moment;
    if (!this.moment) {
      throw new Error("Obsidian moment.js not available");
    }
  }
  /**
   * Get current date/time
   */
  static now() {
    return this.moment();
  }
  /**
   * Create moment from date input
   */
  static from(input) {
    return this.moment(input);
  }
  /**
   * Create moment from date string with format
   */
  static fromFormat(input, format, strict = true) {
    return this.moment(input, format, strict);
  }
  /**
   * Format a date using the specified format
   */
  static format(date, format = "YYYY-MM-DD") {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.format(format);
  }
  /**
   * Get today's date formatted
   */
  static today(format = "YYYY-MM-DD") {
    return this.moment().format(format);
  }
  /**
   * Get current year
   */
  static currentYear() {
    return this.moment().format("YYYY");
  }
  /**
   * Get current month name
   */
  static currentMonth() {
    return this.moment().format("MMMM");
  }
  /**
   * Get start of year for given date
   */
  static startOfYear(date) {
    return (date ? this.moment(date) : this.moment()).startOf("year");
  }
  /**
   * End of year for given date
   */
  static endOfYear(date) {
    return (date ? this.moment(date) : this.moment()).endOf("year");
  }
  /**
   * Start of month for given date
   */
  static startOfMonth(date) {
    return (date ? this.moment(date) : this.moment()).startOf("month");
  }
  /**
   * End of month for given date
   */
  static endOfMonth(date) {
    return (date ? this.moment(date) : this.moment()).endOf("month");
  }
  /**
   * Add time to a date
   */
  static add(date, amount, unit) {
    return this.moment(date).add(amount, unit);
  }
  /**
   * Subtract time from a date
   */
  static subtract(date, amount, unit) {
    return this.moment(date).subtract(amount, unit);
  }
  /**
   * Check if date is valid
   */
  static isValid(date) {
    return this.moment(date).isValid();
  }
  /**
   * Check if date is same or before another date
   */
  static isSameOrBefore(date1, date2) {
    return this.moment(date1).isSameOrBefore(date2);
  }
  /**
   * Extract date from filename using format
   */
  static extractDateFromFilename(filename, format) {
    try {
      const date = this.moment(filename, format, true);
      return date.isValid() ? date : null;
    } catch (error) {
      return null;
    }
  }
  /**
   * Get journal path components for a date
   */
  static getJournalPathComponents(date) {
    const momentDate = date ? this.moment(date) : this.moment();
    const year = momentDate.format("YYYY");
    const monthName = momentDate.format("MMMM");
    return {
      year,
      monthName,
      yearFolder: `y_${year}`,
      monthFolder: monthName
    };
  }
  /**
   * Get formatted filename for journal entry
   */
  static getJournalFilename(date, format = "YYYY-MM-DD dddd") {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.format(format);
  }
  /**
   * Get previous day
   */
  static previousDay(date) {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.subtract(1, "day");
  }
  /**
   * Get next day
   */
  static nextDay(date) {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.add(1, "day");
  }
  /**
   * Create date range iterator
   */
  static *dateRange(startDate, endDate, unit = "day") {
    const current = this.moment(startDate);
    const end = this.moment(endDate);
    while (current.isSameOrBefore(end)) {
      yield this.moment(current);
      current.add(1, unit);
    }
  }
  /**
   * Get monthly folder path for a date
   */
  static getMonthlyFolderPath(basePath, date) {
    const components = this.getJournalPathComponents(date);
    return `${basePath}/${components.yearFolder}/${components.monthFolder}`;
  }
  /**
   * Get full journal file path
   */
  static getJournalFilePath(basePath, date, format = "YYYY-MM-DD dddd") {
    const monthlyPath = this.getMonthlyFolderPath(basePath, date);
    const filename = this.getJournalFilename(date, format);
    return `${monthlyPath}/${filename}.md`;
  }
  /**
   * Validate date format string
   */
  static isValidFormat(format) {
    try {
      const testDate = this.moment();
      testDate.format(format);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Get debug information about the moment instance
   */
  static getDebugInfo() {
    var _a;
    return {
      available: !!this.moment,
      version: ((_a = this.moment) == null ? void 0 : _a.version) || "unknown",
      type: typeof this.moment
    };
  }
};

// src/ui/settingsTab.ts
var SettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Link Plugin Settings" });
    const description = containerEl.createEl("p");
    description.innerHTML = `
      Essential settings for the Link Plugin. <strong>Quality over quantity</strong> - only the most important options are shown.
    `;
    description.style.marginBottom = "2em";
    description.style.color = "var(--text-muted)";
    this.addCoreSettings(containerEl);
    this.addSimplifiedJournalSettings(containerEl);
    this.addFileSortingSettings(containerEl);
  }
  addCoreSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F3E0} Core Settings" });
    new import_obsidian2.Setting(containerEl).setName("Base Folder").setDesc("Root folder for all plugin files (prevents vault collision)").addText((text) => text.setPlaceholder("LinkPlugin").setValue(this.plugin.settings.baseFolder).onChange(async (value) => {
      if (value.trim()) {
        this.plugin.settings.baseFolder = value.trim();
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Open new notes").setDesc("Open newly created notes in a new pane").addToggle((toggle) => toggle.setValue(this.plugin.settings.openNewNote).onChange(async (value) => {
      this.plugin.settings.openNewNote = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Rebuild Structure").setDesc("Recreate folder structure with current settings").addButton((button) => button.setButtonText("Rebuild").onClick(async () => {
      try {
        await this.plugin.directoryManager.rebuildDirectoryStructure();
        this.showSuccessMessage(button.buttonEl, "Structure rebuilt!");
      } catch (error) {
        this.plugin.errorHandler.handleError(error, "Failed to rebuild structure");
      }
    }));
  }
  addJournalSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F4C5} Journal Settings" });
    const journalDesc = containerEl.createEl("p");
    journalDesc.textContent = "Configure date formats and templates for journal entries.";
    journalDesc.style.color = "var(--text-muted)";
    journalDesc.style.marginBottom = "1em";
    new import_obsidian2.Setting(containerEl).setName("Journal Date Format").setDesc("Format for journal entry filenames. Uses moment.js format tokens (e.g., YYYY-MM-DD dddd).").addText((text) => text.setPlaceholder("YYYY-MM-DD dddd").setValue(this.plugin.settings.journalDateFormat).onChange(async (value) => {
      if (value.trim()) {
        if (JournalSettings.isValidDateFormat(value)) {
          this.plugin.settings.journalDateFormat = value.trim();
          await this.plugin.saveSettings();
          this.showValidationMessage(text.inputEl, "\u2705 Valid format", "success");
        } else {
          this.showValidationMessage(text.inputEl, "\u274C Invalid date format", "error");
        }
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Journal Folder Format").setDesc("Format for organizing journal folders by date.").addText((text) => text.setPlaceholder("YYYY/MM").setValue(this.plugin.settings.journalFolderFormat).onChange(async (value) => {
      if (value.trim()) {
        this.plugin.settings.journalFolderFormat = value.trim();
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Journal Template").setDesc("Template for new journal entries. Use {{date}}, {{title}}, {{previous}}, {{next}} as placeholders.").addTextArea((text) => {
      text.inputEl.rows = 8;
      text.inputEl.style.width = "100%";
      text.inputEl.style.minHeight = "150px";
      text.setPlaceholder(`# {{date}}

## Daily Log

## Tasks
- [ ] 

## Notes

## Reflection

---
Previous: {{previous}}
Next: {{next}}`);
      text.setValue(this.plugin.settings.journalTemplate);
      text.onChange(async (value) => {
        this.plugin.settings.journalTemplate = value;
        await this.plugin.saveSettings();
      });
      return text;
    });
    new import_obsidian2.Setting(containerEl).setName("Create Monthly Folders").setDesc("Pre-create monthly folders for the current year.").addButton((button) => button.setButtonText("Create Folders").setTooltip("Create all monthly folders for the current year").onClick(async () => {
      var _a;
      try {
        const startOfYear = DateService.startOfYear();
        const endOfYear = DateService.endOfYear();
        await this.plugin.journalManager.createMonthlyFoldersForRange(startOfYear, endOfYear);
        const notice = document.createElement("div");
        notice.textContent = "\u2705 Monthly folders created successfully!";
        notice.style.color = "var(--text-success)";
        notice.style.fontWeight = "bold";
        (_a = button.buttonEl.parentElement) == null ? void 0 : _a.appendChild(notice);
        setTimeout(() => notice.remove(), 3e3);
      } catch (error) {
        this.plugin.errorHandler.handleError(error, "Failed to create monthly folders");
      }
    }));
  }
  addSimplifiedJournalSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F4C5} Journal Settings" });
    new import_obsidian2.Setting(containerEl).setName("Simple Journal Mode").setDesc("Use simple folder structure (all notes in journal folder)").addToggle((toggle) => toggle.setValue(this.plugin.settings.simpleJournalMode).onChange(async (value) => {
      this.plugin.settings.simpleJournalMode = value;
      this.plugin.settings.enableDynamicFolders = !value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Date Format").setDesc("Format for journal filenames (YYYY-MM-DD recommended)").addText((text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.journalDateFormat).onChange(async (value) => {
      if (value.trim()) {
        this.plugin.settings.journalDateFormat = value.trim();
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Today's Journal").setDesc("Create or open today's journal entry").addButton((button) => button.setButtonText("Open Today").onClick(async () => {
      try {
        await this.plugin.journalManager.openTodayJournal();
        this.showSuccessMessage(button.buttonEl, "Journal opened!");
      } catch (error) {
        this.plugin.errorHandler.handleError(error, "Failed to open journal");
      }
    }));
  }
  addFileSortingSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F4C2} File Sorting" });
    new import_obsidian2.Setting(containerEl).setName("Auto Sort Files").setDesc("Automatically sort files when created or modified").addToggle((toggle) => toggle.setValue(this.plugin.settings.fileSorting.enableAutoSorting).onChange(async (value) => {
      this.plugin.settings.fileSorting.enableAutoSorting = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Sort on Create").setDesc("Sort files immediately when created").addToggle((toggle) => toggle.setValue(this.plugin.settings.fileSorting.sortOnFileCreate).onChange(async (value) => {
      this.plugin.settings.fileSorting.sortOnFileCreate = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Sort All Files").setDesc("Sort all existing files in vault (preview mode)").addButton((button) => button.setButtonText("Preview Sort").onClick(async () => {
      try {
        if (!this.plugin.fileSortingManager) {
          const { FileSortingManager: FileSortingManager2 } = await Promise.resolve().then(() => (init_fileSortingManager(), fileSortingManager_exports));
          this.plugin.fileSortingManager = new FileSortingManager2(
            this.plugin.app.vault,
            this.plugin.app.metadataCache,
            this.plugin.settings,
            this.plugin.directoryManager
          );
        }
        const result = await this.plugin.fileSortingManager.bulkSort(true);
        this.showSuccessMessage(button.buttonEl, `Preview: ${result.moved} files would be moved`);
      } catch (error) {
        this.plugin.errorHandler.handleError(error, "Failed to preview sort");
      }
    }));
  }
  addNoteSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F4DD} Note Creation" });
    const noteDesc = containerEl.createEl("p");
    noteDesc.textContent = "Configure templates and behavior for new note creation.";
    noteDesc.style.color = "var(--text-muted)";
    noteDesc.style.marginBottom = "1em";
    new import_obsidian2.Setting(containerEl).setName("Note Template").setDesc("Default template for new notes. Use {{title}}, {{date}}, {{source}} as placeholders.").addTextArea((text) => {
      text.inputEl.rows = 6;
      text.inputEl.style.width = "100%";
      text.inputEl.style.minHeight = "120px";
      text.setPlaceholder(`---
title: {{title}}
created: {{date}}
source: {{source}}
tags: []
---

# {{title}}

`);
      text.setValue(this.plugin.settings.noteTemplate);
      text.onChange(async (value) => {
        const validation = NoteSettings.validateTemplate(value);
        if (validation.isValid) {
          this.plugin.settings.noteTemplate = value;
          await this.plugin.saveSettings();
          this.showValidationMessage(text.inputEl, "\u2705 Valid template", "success");
        } else {
          this.showValidationMessage(text.inputEl, `\u274C ${validation.errors.join(", ")}`, "error");
        }
      });
      return text;
    });
    new import_obsidian2.Setting(containerEl).setName("Open New Notes").setDesc("Automatically open newly created notes in the editor.").addToggle((toggle) => toggle.setValue(this.plugin.settings.openNewNote).onChange(async (value) => {
      this.plugin.settings.openNewNote = value;
      await this.plugin.saveSettings();
    }));
  }
  // DEPRECATED: Shortcode functionality moved to quarantine
  // private addShortcodeSettings(containerEl: HTMLElement): void {
  //   containerEl.createEl('h2', { text: 'âš¡ Shortcodes' });
  //   
  //   const shortcodeDesc = containerEl.createEl('p');
  //   shortcodeDesc.innerHTML = `
  //     Configure the shortcode system for rapid content creation. 
  //     <br><small>Example: <code>h2+ul>li*3</code> creates a heading with a 3-item list.</small>
  //   `;
  //   shortcodeDesc.style.color = 'var(--text-muted)';
  //   shortcodeDesc.style.marginBottom = '1em';
  // }
  addGeneralSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u2699\uFE0F General Settings" });
    const generalDesc = containerEl.createEl("p");
    generalDesc.textContent = "General plugin configuration and debugging options.";
    generalDesc.style.color = "var(--text-muted)";
    generalDesc.style.marginBottom = "1em";
    new import_obsidian2.Setting(containerEl).setName("Debug Mode").setDesc("Enable detailed logging for troubleshooting. Check the developer console for debug messages.").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      await this.plugin.saveSettings();
      if (value) {
        console.log("[LinkPlugin] Debug mode enabled");
        console.log("[LinkPlugin] Current settings:", this.plugin.settings);
        console.log("[LinkPlugin] DateService info:", DateService.getDebugInfo());
      }
    }));
  }
  addAdvancedSettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F527} Advanced" });
    const advancedDesc = containerEl.createEl("p");
    advancedDesc.textContent = "Advanced settings and maintenance tools.";
    advancedDesc.style.color = "var(--text-muted)";
    advancedDesc.style.marginBottom = "1em";
    new import_obsidian2.Setting(containerEl).setName("Validate Settings").setDesc("Check current settings for any issues or conflicts.").addButton((button) => button.setButtonText("Validate").onClick(() => {
      var _a, _b;
      const validation = validateSettingsWithDetails(this.plugin.settings);
      const resultEl = document.createElement("div");
      resultEl.style.marginTop = "10px";
      resultEl.style.padding = "10px";
      resultEl.style.borderRadius = "4px";
      resultEl.style.border = "1px solid var(--background-modifier-border)";
      if (validation.isValid) {
        resultEl.style.backgroundColor = "var(--background-modifier-success)";
        resultEl.innerHTML = "<strong>\u2705 All settings are valid!</strong>";
      } else {
        resultEl.style.backgroundColor = "var(--background-modifier-error)";
        let content = "<strong>\u274C Settings validation failed:</strong><ul>";
        validation.errors.forEach((error) => {
          content += `<li>${error}</li>`;
        });
        content += "</ul>";
        if (validation.warnings.length > 0) {
          content += "<strong>\u26A0\uFE0F Warnings:</strong><ul>";
          validation.warnings.forEach((warning) => {
            content += `<li>${warning}</li>`;
          });
          content += "</ul>";
        }
        resultEl.innerHTML = content;
      }
      const existing = (_a = button.buttonEl.parentElement) == null ? void 0 : _a.querySelector(".validation-result");
      if (existing)
        existing.remove();
      resultEl.classList.add("validation-result");
      (_b = button.buttonEl.parentElement) == null ? void 0 : _b.appendChild(resultEl);
      setTimeout(() => resultEl.remove(), 1e4);
    }));
    new import_obsidian2.Setting(containerEl).setName("Reset to Defaults").setDesc("\u26A0\uFE0F Reset all settings to their default values. This cannot be undone.").addButton((button) => button.setButtonText("Reset").setWarning().onClick(async () => {
      var _a;
      const confirmed = confirm("Are you sure you want to reset all settings to defaults? This cannot be undone.");
      if (confirmed) {
        const { DEFAULT_SETTINGS: DEFAULT_SETTINGS3 } = await Promise.resolve().then(() => (init_settings(), settings_exports));
        this.plugin.settings = { ...DEFAULT_SETTINGS3 };
        await this.plugin.saveSettings();
        this.display();
        const notice = document.createElement("div");
        notice.textContent = "\u2705 Settings reset to defaults successfully!";
        notice.style.color = "var(--text-success)";
        notice.style.fontWeight = "bold";
        notice.style.marginTop = "10px";
        (_a = button.buttonEl.parentElement) == null ? void 0 : _a.appendChild(notice);
        setTimeout(() => notice.remove(), 3e3);
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Export Settings").setDesc("Export current settings as JSON for backup or sharing.").addButton((button) => button.setButtonText("Export").onClick(() => {
      const settingsJson = JSON.stringify(this.plugin.settings, null, 2);
      navigator.clipboard.writeText(settingsJson).then(() => {
        var _a;
        const notice = document.createElement("div");
        notice.textContent = "\u2705 Settings copied to clipboard!";
        notice.style.color = "var(--text-success)";
        notice.style.fontWeight = "bold";
        notice.style.marginTop = "10px";
        (_a = button.buttonEl.parentElement) == null ? void 0 : _a.appendChild(notice);
        setTimeout(() => notice.remove(), 3e3);
      });
    }));
  }
  showSuccessMessage(buttonEl, message) {
    var _a;
    const notice = document.createElement("div");
    notice.textContent = `\u2705 ${message}`;
    notice.style.color = "var(--text-success)";
    notice.style.fontWeight = "bold";
    notice.style.marginTop = "0.5em";
    (_a = buttonEl.parentElement) == null ? void 0 : _a.appendChild(notice);
    setTimeout(() => notice.remove(), 3e3);
  }
  showValidationMessage(inputEl, message, type) {
    var _a, _b;
    const existing = (_a = inputEl.parentElement) == null ? void 0 : _a.querySelector(".validation-message");
    if (existing)
      existing.remove();
    const messageEl = document.createElement("div");
    messageEl.classList.add("validation-message");
    messageEl.textContent = message;
    messageEl.style.fontSize = "0.8em";
    messageEl.style.marginTop = "4px";
    messageEl.style.color = type === "success" ? "var(--text-success)" : "var(--text-error)";
    (_b = inputEl.parentElement) == null ? void 0 : _b.appendChild(messageEl);
    setTimeout(() => messageEl.remove(), 3e3);
  }
  // DEPRECATED: Shortcode functionality moved to quarantine
  // private displayCustomShortcodes(containerEl: HTMLElement): void {
  //   // Shortcode display logic moved to quarantine
  // }
  // private showCustomShortcodeDialog(): void {
  //   // Shortcode dialog logic moved to quarantine
  // }
};

// src/ui/ribbonManager.ts
var import_obsidian3 = require("obsidian");
init_constants();
var RibbonManager = class {
  constructor(plugin) {
    this.ribbonButtons = [];
    this.plugin = plugin;
  }
  /**
   * Initialize ribbon buttons - minimized to 2 essential buttons
   */
  initializeRibbon() {
    this.addCreateFutureNoteButton();
    this.addSettingsButton();
    if (this.plugin.settings.debugMode) {
      console.log("[LinkPlugin] Ribbon initialized with", this.ribbonButtons.length, "buttons");
    }
  }
  /**
   * Clean up ribbon buttons on plugin unload
   */
  cleanup() {
    this.ribbonButtons.forEach((button) => {
      button.remove();
    });
    this.ribbonButtons = [];
  }
  /**
   * Add Today's Journal button
   */
  addTodayJournalButton() {
    const button = this.plugin.addRibbonIcon(
      RIBBON_BUTTONS.TODAY_JOURNAL.icon,
      RIBBON_BUTTONS.TODAY_JOURNAL.tooltip,
      async () => {
        try {
          await this.plugin.journalManager.openTodayJournal();
          this.showSuccess("Today's journal opened");
        } catch (error) {
          this.plugin.errorHandler.handleError(error, "Failed to open today's journal");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Add Create Future Note button - combines multiple functions into one smart button
   */
  addCreateFutureNoteButton() {
    const button = this.plugin.addRibbonIcon(
      "\u{1F4DD}",
      "Create Future Note - Creates daily notes, linked notes, or opens today's journal",
      async () => {
        try {
          const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
          if (activeView) {
            const editor = activeView.editor;
            const selection = editor.getSelection();
            if (selection) {
              this.plugin.linkManager.createLinkedNote(selection, editor, activeView);
              this.showSuccess("Linked note created");
              return;
            }
          }
          await this.plugin.journalManager.openTodayJournal();
          this.showSuccess("Today's journal opened");
        } catch (error) {
          this.plugin.errorHandler.handleError(error, "Failed to create note");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Add Monthly Folders button
   */
  addMonthlyFoldersButton() {
    const button = this.plugin.addRibbonIcon(
      RIBBON_BUTTONS.MONTHLY_FOLDERS.icon,
      RIBBON_BUTTONS.MONTHLY_FOLDERS.tooltip,
      async () => {
        try {
          const startOfYear = DateService.startOfYear();
          const endOfYear = DateService.endOfYear();
          await this.plugin.journalManager.createMonthlyFoldersForRange(startOfYear, endOfYear);
          this.showSuccess("Monthly folders created for current year");
        } catch (error) {
          this.plugin.errorHandler.handleError(error, "Failed to create monthly folders");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Add Shortcode Help button (deprecated - moved to quarantine)
   */
  // private addShortcodeHelpButton(): void {
  //   // Shortcode help button logic moved to quarantine
  // }
  /**
   * Add Rebuild Directory Structure button
   */
  addRebuildStructureButton() {
    const button = this.plugin.addRibbonIcon(
      RIBBON_BUTTONS.REBUILD_STRUCTURE.icon,
      RIBBON_BUTTONS.REBUILD_STRUCTURE.tooltip,
      async () => {
        try {
          await this.plugin.directoryManager.rebuildDirectoryStructure();
          this.showSuccess("Directory structure rebuilt");
        } catch (error) {
          this.plugin.errorHandler.handleError(error, "Failed to rebuild directory structure");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Add Settings button
   */
  addSettingsButton() {
    const button = this.plugin.addRibbonIcon(
      RIBBON_BUTTONS.PLUGIN_SETTINGS.icon,
      RIBBON_BUTTONS.PLUGIN_SETTINGS.tooltip,
      () => {
        try {
          this.plugin.app.setting.open();
          this.plugin.app.setting.openTabById(this.plugin.manifest.id);
        } catch (error) {
          new import_obsidian3.Notice("Please open Settings manually and find the Link Plugin tab");
          this.plugin.errorHandler.handleError(error, "Failed to open settings automatically");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Show success message
   */
  showSuccess(message) {
    new import_obsidian3.Notice(`\u2705 ${message}`);
    if (this.plugin.settings.debugMode) {
      console.log(`[LinkPlugin] ${message}`);
    }
  }
  /**
   * Update ribbon button states based on settings
   */
  updateButtonStates() {
    if (this.plugin.settings.debugMode) {
      console.log("[LinkPlugin] Ribbon button states updated");
    }
  }
  /**
   * Get ribbon button count for debugging
   */
  getButtonCount() {
    return this.ribbonButtons.length;
  }
  /**
   * Add a custom ribbon button (for future extensibility)
   */
  addCustomButton(icon, tooltip, callback) {
    const button = this.plugin.addRibbonIcon(icon, tooltip, callback);
    this.ribbonButtons.push(button);
    return button;
  }
  /**
   * Remove a specific ribbon button
   */
  removeButton(button) {
    const index = this.ribbonButtons.indexOf(button);
    if (index > -1) {
      this.ribbonButtons.splice(index, 1);
      button.remove();
    }
  }
  /**
   * Show quick actions menu (future enhancement)
   */
  showQuickActionsMenu() {
    const message = `
Link Plugin Quick Actions:
\u2022 Today's Journal: ${RIBBON_BUTTONS.TODAY_JOURNAL.tooltip}
\u2022 Create Note: ${RIBBON_BUTTONS.CREATE_NOTE.tooltip}
\u2022 Monthly Folders: ${RIBBON_BUTTONS.MONTHLY_FOLDERS.tooltip}
\u2022 Shortcode Help: (deprecated - moved to quarantine)
\u2022 Rebuild Structure: ${RIBBON_BUTTONS.REBUILD_STRUCTURE.tooltip}
\u2022 Settings: ${RIBBON_BUTTONS.PLUGIN_SETTINGS.tooltip}
    `.trim();
    new import_obsidian3.Notice(message, 8e3);
  }
};

// src/managers/directoryManager.ts
var import_obsidian5 = require("obsidian");
init_constants();

// src/utils/pathUtils.ts
var import_obsidian4 = require("obsidian");
var PathUtils = class {
  static sanitizePath(path) {
    return (0, import_obsidian4.normalizePath)(path.replace(/[\/:*?"<>|]/g, "").trim());
  }
  static joinPath(...segments) {
    return (0, import_obsidian4.normalizePath)(segments.filter(Boolean).join("/"));
  }
};

// src/managers/directoryManager.ts
var DirectoryManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates the base directory structure according to settings
   * All directories are created under the configured baseFolder to prevent collisions
   */
  async rebuildDirectoryStructure() {
    const { vault } = this.plugin.app;
    const { baseFolder, directoryStructure } = this.plugin.settings;
    try {
      const basePath = (0, import_obsidian5.normalizePath)(baseFolder);
      await this.getOrCreateDirectory(basePath);
      console.log(`Created base directory: ${basePath}`);
      for (const dirName of directoryStructure || DEFAULT_DIRECTORIES) {
        const dirPath = PathUtils.joinPath(basePath, dirName);
        await this.getOrCreateDirectory(dirPath);
        console.log(`Created directory: ${dirPath}`);
      }
      await this.createJournalStructure(basePath);
      await this.createReferenceStructure(basePath);
    } catch (error) {
      throw new Error(`Failed to rebuild directory structure: ${error}`);
    }
  }
  /**
   * Creates journal structure - simple or complex based on settings
   */
  async createJournalStructure(basePath) {
    const journalPath = PathUtils.joinPath(basePath, "journal");
    await this.getOrCreateDirectory(journalPath);
    console.log(`Created journal directory: ${journalPath}`);
    if (this.plugin.settings.enableDynamicFolders && !this.plugin.settings.simpleJournalMode) {
      const journalSubdirs = [
        "Misc",
        "y_2025/January",
        "y_2025/February",
        "y_2025/March",
        "y_2025/April",
        "y_2025/May",
        "y_2025/June",
        "y_2025/Misc",
        "y_2025/Yearly List",
        "y_2025/Yearly Log",
        "z_Archives/y_2022",
        "z_Archives/y_2023",
        "z_Archives/y_2024"
      ];
      for (const subdir of journalSubdirs) {
        const fullPath = PathUtils.joinPath(journalPath, subdir);
        await this.getOrCreateDirectory(fullPath);
        console.log(`Created journal directory: ${fullPath}`);
      }
    }
  }
  /**
   * Creates the reference file structure as specified in README
   */
  async createReferenceStructure(basePath) {
    const referencePath = PathUtils.joinPath(basePath, "reference");
    const fileTypes = ["images", "pdfs", "videos", "audio", "docs", "other"];
    for (const fileType of fileTypes) {
      const filePath = PathUtils.joinPath(referencePath, "files", fileType);
      await this.getOrCreateDirectory(filePath);
      console.log(`Created reference directory: ${filePath}`);
    }
  }
  /**
   * Creates optional complex structure directories
   */
  async createOptionalStructure(basePath) {
    for (const dirName of OPTIONAL_DIRECTORIES) {
      const dirPath = PathUtils.joinPath(basePath, dirName);
      await this.getOrCreateDirectory(dirPath);
      console.log(`Created optional directory: ${dirPath}`);
    }
  }
  /**
   * Gets a directory path, creating it if it doesn't exist
   * Handles both absolute paths and paths relative to the base folder
   */
  async getOrCreateDirectory(path) {
    const { vault } = this.plugin.app;
    const normalizedPath = (0, import_obsidian5.normalizePath)(path);
    const existingFolder = vault.getAbstractFileByPath(normalizedPath);
    if (existingFolder instanceof import_obsidian5.TFolder) {
      return existingFolder;
    }
    const pathParts = normalizedPath.split("/");
    let currentPath = "";
    for (const part of pathParts) {
      if (!part)
        continue;
      currentPath += (currentPath ? "/" : "") + part;
      const folder = vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await vault.createFolder(currentPath);
      } else if (!(folder instanceof import_obsidian5.TFolder)) {
        throw new Error(`Path ${currentPath} exists but is not a folder`);
      }
    }
    return vault.getAbstractFileByPath(normalizedPath);
  }
  /**
   * Gets the full path for a directory within the plugin's base folder
   */
  getPluginDirectoryPath(relativePath) {
    const { baseFolder } = this.plugin.settings;
    return PathUtils.joinPath(baseFolder, relativePath);
  }
  /**
   * Gets the journal directory path
   */
  getJournalPath() {
    const { baseFolder, journalRootFolder } = this.plugin.settings;
    return PathUtils.joinPath(baseFolder, journalRootFolder);
  }
  /**
   * Gets the workspace directory path  
   */
  getWorkspacePath() {
    const { baseFolder, documentDirectory } = this.plugin.settings;
    return PathUtils.joinPath(baseFolder, documentDirectory);
  }
  /**
   * Applies a directory template to create structured folders
   */
  async applyDirectoryTemplate(basePath, template) {
    for (const [key, value] of Object.entries(template)) {
      const dirPath = PathUtils.joinPath(basePath, key);
      await this.getOrCreateDirectory(dirPath);
      if (value && typeof value === "object") {
        await this.applyDirectoryTemplate(dirPath, value);
      }
    }
  }
  /**
   * Validates if a given path is within allowed directories
   */
  isValidPath(path) {
    const normalizedPath = (0, import_obsidian5.normalizePath)(path);
    const { restrictedDirectories } = this.plugin.settings;
    if (!restrictedDirectories || restrictedDirectories.length === 0) {
      return true;
    }
    return !restrictedDirectories.some((dir) => {
      const normalizedDir = (0, import_obsidian5.normalizePath)(dir);
      return normalizedPath === normalizedDir || normalizedPath.startsWith(normalizedDir + "/");
    });
  }
  /**
   * Lists all directories in the vault
   */
  getAllDirectories() {
    const { vault } = this.plugin.app;
    return vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian5.TFolder);
  }
  /**
   * Creates a directory with a specific template structure within the plugin's base folder
   */
  async createProjectDirectory(name, template) {
    const sanitizedName = PathUtils.sanitizePath(name);
    const workspacePath = this.getWorkspacePath();
    const projectPath = PathUtils.joinPath(workspacePath, sanitizedName);
    const projectFolder = await this.getOrCreateDirectory(projectPath);
    if (template) {
      await this.applyDirectoryTemplate(projectPath, template);
    }
    return projectFolder;
  }
};

// src/managers/journalManager.ts
var import_obsidian6 = require("obsidian");
var JournalManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates or opens a journal entry for the specified date
   * Automatically creates monthly folders as needed
   */
  async createOrOpenJournalEntry(date) {
    const { vault } = this.plugin.app;
    const { journalDateFormat, journalTemplate } = this.plugin.settings;
    await this.ensureMonthlyFolderExists(date);
    const monthlyFolderPath = this.getMonthlyFolderPath(date);
    const fileName = DateService.getJournalFilename(date, journalDateFormat);
    const filePath = (0, import_obsidian6.normalizePath)(`${monthlyFolderPath}/${fileName}.md`);
    let file = vault.getAbstractFileByPath(filePath);
    if (!file) {
      const content = await this.generateJournalContent(date);
      file = await vault.create(filePath, content);
      console.log(`Created daily note: ${filePath}`);
    }
    return file;
  }
  /**
   * Ensures the monthly folder exists for the given date
   * Creates the folder structure if it doesn't exist
   */
  async ensureMonthlyFolderExists(date) {
    const monthlyFolderPath = this.getMonthlyFolderPath(date);
    await this.plugin.directoryManager.getOrCreateDirectory(monthlyFolderPath);
    console.log(`Ensured monthly folder exists: ${monthlyFolderPath}`);
  }
  /**
   * Gets the monthly folder path for a given date
   * Uses dynamic folders if enabled, otherwise simple journal folder
   */
  getMonthlyFolderPath(date) {
    const journalBasePath = this.plugin.directoryManager.getJournalPath();
    if (!this.plugin.settings.enableDynamicFolders || this.plugin.settings.simpleJournalMode) {
      return journalBasePath;
    }
    return DateService.getMonthlyFolderPath(journalBasePath, date);
  }
  /**
   * Creates a daily note for today if it doesn't exist
   * Automatically handles monthly folder creation
   */
  async createTodayNote() {
    const today = DateService.now();
    return await this.createOrOpenJournalEntry(today);
  }
  /**
   * Creates a daily note for a future date
   * Automatically creates monthly folders as needed
   */
  async createFutureDailyNote(date) {
    const targetDate = DateService.from(date);
    return await this.createOrOpenJournalEntry(targetDate);
  }
  /**
   * Generate content for a journal entry
   */
  async generateJournalContent(date) {
    const { journalTemplate, journalDateFormat } = this.plugin.settings;
    const previousDay = DateService.previousDay(date);
    const nextDay = DateService.nextDay(date);
    const previousLink = `[[${DateService.format(previousDay, journalDateFormat)}]]`;
    const nextLink = `[[${DateService.format(nextDay, journalDateFormat)}]]`;
    const currentDate = DateService.format(date, "YYYY-MM-DD");
    const title = DateService.format(date, journalDateFormat);
    if (journalTemplate) {
      return journalTemplate.replace(/{{date}}/g, currentDate).replace(/{{title}}/g, title).replace(/{{previous}}/g, previousLink).replace(/{{next}}/g, nextLink);
    }
    return `---
date: ${currentDate}
previous: ${previousLink}
next: ${nextLink}
tags:
  - journal
---

# ${title}

## Daily Log

## Tasks
- [ ] 

## Notes

## Reflection

---
Previous: ${previousLink} | Next: ${nextLink}
`;
  }
  /**
   * Opens the journal entry for today
   * Creates monthly folder and daily note if they don't exist
   */
  async openTodayJournal() {
    const today = DateService.now();
    const file = await this.createOrOpenJournalEntry(today);
    const leaf = this.plugin.app.workspace.getLeaf();
    await leaf.openFile(file);
  }
  /**
   * Checks if we need to create a new monthly folder
   * Called when the plugin loads or when creating notes
   */
  async checkAndCreateCurrentMonthFolder() {
    const currentDate = DateService.now();
    await this.ensureMonthlyFolderExists(currentDate);
  }
  /**
   * Creates monthly folders for a range of dates
   * Useful for batch creation or setup
   */
  async createMonthlyFoldersForRange(startDate, endDate) {
    const current = DateService.startOfMonth(startDate);
    const end = DateService.endOfMonth(endDate);
    while (DateService.isSameOrBefore(current, end)) {
      await this.ensureMonthlyFolderExists(current);
      DateService.add(current, 1, "month");
    }
  }
  /**
   * Opens journal entry for a specific date
   */
  async openJournalForDate(date) {
    const momentDate = DateService.from(date);
    const file = await this.createOrOpenJournalEntry(momentDate);
    const leaf = this.plugin.app.workspace.getLeaf();
    await leaf.openFile(file);
  }
  /**
   * Updates links between journal entries
   */
  async updateJournalLinks(file) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    const fileDate = DateService.extractDateFromFilename(file.basename, journalDateFormat || "YYYY-MM-DD dddd");
    if (!fileDate)
      return;
    const content = await vault.read(file);
    const previousDay = DateService.previousDay(fileDate);
    const nextDay = DateService.nextDay(fileDate);
    const previousFileName = DateService.format(previousDay, journalDateFormat);
    const nextFileName = DateService.format(nextDay, journalDateFormat);
    const updatedContent = content.replace(/previous: '\[\[(.*?)\]\]'/g, `previous: '[[${previousFileName}]]'`).replace(/next: '\[\[(.*?)\]\]'/g, `next: '[[${nextFileName}]]'`);
    if (updatedContent !== content) {
      await vault.modify(file, updatedContent);
    }
  }
  /**
   * Get journal entries for a date range
   */
  async getJournalEntries(startDate, endDate) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    const entries = [];
    const current = DateService.from(startDate);
    while (DateService.isSameOrBefore(current, endDate)) {
      const filePath = DateService.getJournalFilePath(
        this.plugin.directoryManager.getJournalPath(),
        current,
        journalDateFormat
      );
      const file = vault.getAbstractFileByPath(filePath);
      if (file) {
        entries.push({
          date: DateService.format(current, "YYYY-MM-DD"),
          path: filePath,
          title: DateService.format(current, journalDateFormat),
          previous: DateService.format(DateService.previousDay(current), "YYYY-MM-DD"),
          next: DateService.format(DateService.nextDay(current), "YYYY-MM-DD")
        });
      }
      DateService.add(current, 1, "day");
    }
    return entries;
  }
};

// src/managers/linkManager.ts
var import_obsidian7 = require("obsidian");
init_constants();
var LinkManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Create a new note from selected text and link to it
   */
  async createLinkedNote(selection, editor, view) {
    const { vault } = this.plugin.app;
    const currentFile = view.file;
    if (!currentFile) {
      throw new Error("No active file found");
    }
    const fileName = this.sanitizeFileName(selection);
    const directoryPath = this.determineTargetDirectory(fileName);
    const filePath = (0, import_obsidian7.normalizePath)(`${directoryPath}/${fileName}.md`);
    let file = vault.getAbstractFileByPath(filePath);
    if (!file) {
      await this.plugin.directoryManager.getOrCreateDirectory(directoryPath);
      const content = this.generateNoteContent(selection, currentFile);
      file = await vault.create(filePath, content);
    }
    const linkText = this.generateLinkText(fileName, directoryPath, currentFile);
    editor.replaceSelection(linkText);
    if (this.plugin.settings.openNewNote) {
      const leaf = this.plugin.app.workspace.splitActiveLeaf();
      await leaf.openFile(file);
    }
  }
  /**
   * Determine the appropriate directory for a new note
   */
  determineTargetDirectory(title) {
    const { documentDirectory } = this.plugin.settings;
    const keywords = title.toLowerCase();
    if (keywords.includes("project") || keywords.includes("work")) {
      return "Workspace";
    } else if (keywords.includes("reference") || keywords.includes("definition")) {
      return "References";
    } else if (keywords.includes("template")) {
      return "Templates";
    }
    return documentDirectory || "Documents";
  }
  /**
   * Generate content for a new linked note
   */
  generateNoteContent(title, sourceFile) {
    const { noteTemplate } = this.plugin.settings;
    const currentDate = new Date().toISOString().split("T")[0];
    if (noteTemplate) {
      return noteTemplate.replace(/{{title}}/g, title).replace(/{{date}}/g, currentDate).replace(/{{source}}/g, `[[${sourceFile.basename}]]`);
    }
    return `---
title: ${title}
created: ${currentDate}
source: [[${sourceFile.basename}]]
tags: []
---

# ${title}

`;
  }
  /**
   * Generate appropriate link text based on directory structure
   * Supports directory-relative links like [[/reference/nesting]]
   */
  generateLinkText(fileName, targetDirectory, currentFile) {
    var _a;
    const currentFileDir = ((_a = currentFile.parent) == null ? void 0 : _a.path) || "";
    const baseFolder = this.plugin.settings.baseFolder || "LinkPlugin";
    if (targetDirectory !== currentFileDir) {
      if (targetDirectory.startsWith(baseFolder)) {
        const relativePath = targetDirectory.replace(baseFolder + "/", "");
        return `[[/${relativePath}/${fileName}]]`;
      } else {
        return `[[/${targetDirectory}/${fileName}]]`;
      }
    }
    return `[[${fileName}]]`;
  }
  /**
   * Sanitize a string for use as a filename
   */
  sanitizeFileName(input) {
    return input.replace(REGEX_PATTERNS.INVALID_FILENAME_CHARS, "").replace(/\s+/g, " ").trim().substring(0, 100);
  }
  /**
   * Find all links in a file
   */
  async findLinksInFile(file) {
    const { vault } = this.plugin.app;
    const content = await vault.read(file);
    const links = [];
    let match;
    while ((match = REGEX_PATTERNS.WIKI_LINK.exec(content)) !== null) {
      links.push(match[1]);
    }
    return links;
  }
  /**
   * Find all backlinks to a file
   */
  async findBacklinks(file) {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const backlinks = [];
    for (const potentialSource of files) {
      if (potentialSource.path === file.path)
        continue;
      const links = await this.findLinksInFile(potentialSource);
      if (links.includes(file.basename)) {
        backlinks.push(potentialSource);
      }
    }
    return backlinks;
  }
  /**
   * Find broken links in the vault
   */
  async findBrokenLinks() {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const brokenLinksData = [];
    for (const file of files) {
      const links = await this.findLinksInFile(file);
      const brokenLinks = [];
      for (const link of links) {
        const linkedFile = vault.getAbstractFileByPath(`${link}.md`) || vault.getAbstractFileByPath(link);
        if (!linkedFile) {
          brokenLinks.push(link);
        }
      }
      if (brokenLinks.length > 0) {
        brokenLinksData.push({ file, brokenLinks });
      }
    }
    return brokenLinksData;
  }
  /**
   * Find orphaned notes (notes with no backlinks)
   */
  async findOrphanedNotes() {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const orphanedNotes = [];
    for (const file of files) {
      const backlinks = await this.findBacklinks(file);
      if (backlinks.length === 0) {
        orphanedNotes.push(file);
      }
    }
    return orphanedNotes;
  }
  /**
   * Generate link suggestions based on content similarity
   */
  async generateLinkSuggestions(file, limit = 5) {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const suggestions = [];
    const currentContent = await vault.read(file);
    const currentWords = this.extractWords(currentContent);
    for (const otherFile of files) {
      if (otherFile.path === file.path)
        continue;
      const otherContent = await vault.read(otherFile);
      const otherWords = this.extractWords(otherContent);
      const relevance = this.calculateRelevance(currentWords, otherWords);
      if (relevance > 0.1) {
        suggestions.push({
          title: otherFile.basename,
          path: otherFile.path,
          relevance,
          type: "existing"
        });
      }
    }
    return suggestions.sort((a, b) => b.relevance - a.relevance).slice(0, limit);
  }
  /**
   * Extract meaningful words from content
   */
  extractWords(content) {
    const words = /* @__PURE__ */ new Set();
    const text = content.replace(/[#*`\[\]()]/g, "").toLowerCase().split(/\s+/);
    for (const word of text) {
      if (word.length > 3 && !this.isStopWord(word)) {
        words.add(word);
      }
    }
    return words;
  }
  /**
   * Calculate relevance between two sets of words
   */
  calculateRelevance(words1, words2) {
    const intersection = new Set([...words1].filter((word) => words2.has(word)));
    const union = /* @__PURE__ */ new Set([...words1, ...words2]);
    return intersection.size / union.size;
  }
  /**
   * Check if a word is a stop word
   */
  isStopWord(word) {
    const stopWords = /* @__PURE__ */ new Set([
      "the",
      "a",
      "an",
      "and",
      "or",
      "but",
      "in",
      "on",
      "at",
      "to",
      "for",
      "of",
      "with",
      "by",
      "is",
      "are",
      "was",
      "were",
      "be",
      "been",
      "have",
      "has",
      "had",
      "do",
      "does",
      "did",
      "will",
      "would",
      "could",
      "should",
      "may",
      "might",
      "must",
      "can",
      "this",
      "that",
      "these",
      "those"
    ]);
    return stopWords.has(word);
  }
};

// src/main.ts
init_fileSortingManager();
init_errorHandler();
init_constants();
var LinkPlugin = class extends import_obsidian8.Plugin {
  async onload() {
    console.log("Loading Link Plugin...");
    try {
      DateService.initialize();
      await this.loadSettings();
      this.errorHandler = new ErrorHandler(this);
      this.directoryManager = new DirectoryManager(this);
      this.journalManager = new JournalManager(this);
      this.linkManager = new LinkManager(this);
      this.fileSortingManager = new FileSortingManager(
        this.app.vault,
        this.app.metadataCache,
        this.settings,
        this.directoryManager
      );
      this.ribbonManager = new RibbonManager(this);
      this.addSettingTab(new SettingsTab(this.app, this));
      this.ribbonManager.initializeRibbon();
      this.registerCommands();
      this.registerEventHandlers();
      await this.directoryManager.rebuildDirectoryStructure();
      await this.journalManager.checkAndCreateCurrentMonthFolder();
      console.log("Link Plugin loaded successfully");
    } catch (error) {
      console.error("Failed to load Link Plugin:", error);
      if (this.errorHandler) {
        this.errorHandler.handleError(error, "Plugin initialization failed");
      }
    }
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = validateSettings(loadedData || {});
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.ribbonManager) {
      this.ribbonManager.updateButtonStates();
    }
  }
  registerCommands() {
    this.addCommand({
      id: COMMAND_IDS.CREATE_LINKED_NOTE,
      name: "Create Linked Note from Selection",
      editorCallback: (editor, view) => {
        try {
          const selection = editor.getSelection();
          if (selection) {
            if ("previewMode" in view) {
              this.linkManager.createLinkedNote(selection, editor, view);
            } else {
              this.errorHandler.handleError(new Error("Invalid view type"), "Please use this command in a markdown view");
            }
          } else {
            this.errorHandler.handleError(new Error("No text selected"), "Please select text to create a linked note");
          }
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create linked note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.REBUILD_DIRECTORY,
      name: "Rebuild Directory Structure",
      callback: () => {
        try {
          this.directoryManager.rebuildDirectoryStructure();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to rebuild directory structure");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.OPEN_TODAY_JOURNAL,
      name: "Open Today's Journal",
      callback: () => {
        try {
          this.journalManager.openTodayJournal();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to open today's journal");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_TODAY_NOTE,
      name: "Create Today's Daily Note",
      callback: async () => {
        try {
          const file = await this.journalManager.createTodayNote();
          const leaf = this.app.workspace.getLeaf();
          await leaf.openFile(file);
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create today's note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_MONTHLY_FOLDERS,
      name: "Create Monthly Folders for Current Year",
      callback: async () => {
        try {
          const startOfYear = DateService.startOfYear();
          const endOfYear = DateService.endOfYear();
          await this.journalManager.createMonthlyFoldersForRange(startOfYear, endOfYear);
          this.errorHandler.showNotice("Monthly folders created for current year");
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create monthly folders");
        }
      }
    });
    this.addCommand({
      id: "show-ribbon-actions",
      name: "Show Ribbon Quick Actions",
      callback: () => {
        try {
          this.ribbonManager.showQuickActionsMenu();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to show ribbon actions");
        }
      }
    });
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian8.TFile && this.settings.fileSorting.sortOnFileCreate) {
          this.fileSortingManager.autoSort(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian8.TFile && this.settings.fileSorting.sortOnFileModify) {
          this.fileSortingManager.autoSort(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if ("stat" in file && "basename" in file && "extension" in file && file.path.includes(this.settings.journalRootFolder)) {
          this.journalManager.updateJournalLinks(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (this.settings.debugMode) {
          console.log("File modified:", file.path);
        }
      })
    );
  }
  onunload() {
    console.log("Link Plugin unloaded");
    if (this.ribbonManager) {
      this.ribbonManager.cleanup();
    }
  }
};
