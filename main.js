/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinkPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/constants.ts
var DEFAULT_BASE_FOLDER = "Link";
var DEFAULT_TEMPLATES_PATH = "templates";
var DAILY_NOTES_TEMPLATE_NAME = "Daily Notes Template.md";
var COMMAND_IDS = {
  REBUILD_DIRECTORY: "rebuild-directory-structure",
  OPEN_TODAY_JOURNAL: "open-today-journal",
  CREATE_TODAY_NOTE: "create-today-note",
  CREATE_FUTURE_NOTE: "create-future-note",
  CREATE_MONTHLY_FOLDERS: "create-monthly-folders"
};
var DATE_FORMATS = {
  DEFAULT_JOURNAL: "YYYY-MM-DD dddd",
  ISO_DATE: "YYYY-MM-DD",
  FOLDER_FORMAT: "YYYY/MM"
};

// src/settings/directorySettings.ts
var DirectorySettings = class {
  static getDefaults() {
    return {
      baseFolder: DEFAULT_BASE_FOLDER,
      // Creates all directories under 'Link/' by default
      directoryStructure: ["journal"],
      restrictedDirectories: [],
      documentDirectory: "journal",
      // Simplified to journal only
      journalRootFolder: "journal"
      // Updated to match README structure
    };
  }
  /**
   * This function validates and sanitizes a partial DirectorySettingsConfig object.
   * 
   * - For each property in the input `settings` object, it checks if the property exists and is of the correct type.
   * - For `baseFolder`, it trims whitespace and, if the result is empty or only slashes, sets it to the root (empty string).
   * - For array properties (`directoryStructure`, `restrictedDirectories`), it checks if they are arrays and copies them if so.
   * - For string properties (`documentDirectory`, `journalRootFolder`), it checks if they are strings and copies them if so.
   * - Only valid and present properties are included in the returned object; missing or invalid properties are omitted.
   * 
   * This is a defensive programming pattern to ensure that only valid, sanitized settings are used, and to prevent
   * malformed or unexpected input from causing issues in the application.
   */
  static validate(settings) {
    const validated = {};
    if (settings.baseFolder !== void 0 && typeof settings.baseFolder === "string") {
      const trimmed = settings.baseFolder.trim();
      if (trimmed === "" || /^\/*$/.test(trimmed)) {
        validated.baseFolder = "";
      } else {
        validated.baseFolder = trimmed;
      }
    }
    if (settings.directoryStructure && Array.isArray(settings.directoryStructure)) {
      validated.directoryStructure = settings.directoryStructure;
    }
    if (settings.restrictedDirectories && Array.isArray(settings.restrictedDirectories)) {
      validated.restrictedDirectories = settings.restrictedDirectories;
    }
    if (settings.documentDirectory && typeof settings.documentDirectory === "string") {
      validated.documentDirectory = settings.documentDirectory;
    }
    if (settings.journalRootFolder && typeof settings.journalRootFolder === "string") {
      validated.journalRootFolder = settings.journalRootFolder;
    }
    return validated;
  }
};

// src/settings/journalSettings.ts
var JournalSettings = class {
  static getDefaults() {
    return {
      journalDateFormat: "YYYY-MM-DD dddd",
      journalFolderFormat: DATE_FORMATS.FOLDER_FORMAT,
      journalYearFormat: "YYYY",
      journalMonthFormat: "MM MMMM",
      simpleJournalMode: false
    };
  }
  static validate(settings) {
    const validated = {};
    if (settings.journalDateFormat && typeof settings.journalDateFormat === "string") {
      validated.journalDateFormat = settings.journalDateFormat;
    }
    if (settings.journalFolderFormat && typeof settings.journalFolderFormat === "string") {
      validated.journalFolderFormat = settings.journalFolderFormat;
    }
    if (typeof settings.simpleJournalMode === "boolean") {
      validated.simpleJournalMode = settings.simpleJournalMode;
    }
    return validated;
  }
  static isValidDateFormat(format) {
    try {
      const validTokens = ["YYYY", "MM", "DD", "dddd", "MMM", "MMMM"];
      return validTokens.some((token) => format.includes(token));
    } catch (e) {
      return false;
    }
  }
};

// src/settings/dailyNotesSettings.ts
var DailyNotesSettings = class {
  static getDefaults() {
    return {
      dailyNotesIntegration: {
        enabled: false,
        backup: null
      }
    };
  }
  static validate(settings) {
    const defaults = this.getDefaults();
    if (!settings.dailyNotesIntegration) {
      return defaults;
    }
    const integration = settings.dailyNotesIntegration;
    return {
      dailyNotesIntegration: {
        enabled: typeof integration.enabled === "boolean" ? integration.enabled : defaults.dailyNotesIntegration.enabled,
        backup: integration.backup || null
      }
    };
  }
};

// src/settings/generalSettings.ts
var GeneralSettings = class {
  static getDefaults() {
    return {
      enabled: false,
      showRibbonButton: true,
      debugMode: false
    };
  }
  static validate(settings) {
    const validated = {};
    if (typeof settings.enabled === "boolean") {
      validated.enabled = settings.enabled;
    }
    if (typeof settings.showRibbonButton === "boolean") {
      validated.showRibbonButton = settings.showRibbonButton;
    }
    if (typeof settings.debugMode === "boolean") {
      validated.debugMode = settings.debugMode;
    }
    return validated;
  }
  static getDebugInfo() {
    return {
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      language: navigator.language
    };
  }
};

// src/settings/settingsValidator.ts
function validateSettings(settings) {
  const validatedSettings = {
    ...DirectorySettings.getDefaults(),
    ...JournalSettings.getDefaults(),
    ...DailyNotesSettings.getDefaults(),
    ...GeneralSettings.getDefaults()
  };
  const directoryValidation = DirectorySettings.validate(settings);
  const journalValidation = JournalSettings.validate(settings);
  const dailyNotesValidation = DailyNotesSettings.validate(settings);
  const generalValidation = GeneralSettings.validate(settings);
  Object.assign(
    validatedSettings,
    directoryValidation,
    journalValidation,
    dailyNotesValidation,
    generalValidation
  );
  if (typeof settings.customTemplateLocation === "string") {
    validatedSettings.customTemplateLocation = settings.customTemplateLocation.trim();
  } else {
    validatedSettings.customTemplateLocation = void 0;
  }
  return validatedSettings;
}

// src/settings/defaultSettings.ts
var DEFAULT_SETTINGS = {
  ...DirectorySettings.getDefaults(),
  ...JournalSettings.getDefaults(),
  ...DailyNotesSettings.getDefaults(),
  ...GeneralSettings.getDefaults(),
  customTemplateLocation: void 0
};

// src/managers/directoryManager.ts
var import_obsidian2 = require("obsidian");

// src/utils/pathUtils.ts
var import_obsidian = require("obsidian");
var PathUtils = class {
  static sanitizePath(path) {
    return (0, import_obsidian.normalizePath)(path.replace(/[\/:*?"<>|]/g, "").trim());
  }
  static joinPath(...segments) {
    return (0, import_obsidian.normalizePath)(segments.filter(Boolean).join("/"));
  }
};

// src/services/dateService.ts
var DateService = class {
  static initialize() {
    this.moment = window.moment;
    if (!this.moment) {
      throw new Error("Obsidian moment.js not available");
    }
  }
  static now() {
    return this.moment();
  }
  static from(input) {
    return this.moment(input);
  }
  static fromFormat(input, format, strict = true) {
    return this.moment(input, format, strict);
  }
  static format(date, format = "YYYY-MM-DD") {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.format(format);
  }
  static today(format = "YYYY-MM-DD") {
    return this.moment().format(format);
  }
  static currentYear() {
    return this.moment().format("YYYY");
  }
  static currentMonth() {
    return this.moment().format("MMMM");
  }
  static startOfYear(date) {
    return (date ? this.moment(date) : this.moment()).startOf("year");
  }
  static endOfYear(date) {
    return (date ? this.moment(date) : this.moment()).endOf("year");
  }
  static startOfMonth(date) {
    return (date ? this.moment(date) : this.moment()).startOf("month");
  }
  static endOfMonth(date) {
    return (date ? this.moment(date) : this.moment()).endOf("month");
  }
  static add(date, amount, unit) {
    return this.moment(date).add(amount, unit);
  }
  static subtract(date, amount, unit) {
    return this.moment(date).subtract(amount, unit);
  }
  static addDays(date, days) {
    return this.add(date, days, "days");
  }
  static isValid(date) {
    return this.moment(date).isValid();
  }
  static isSameOrBefore(date1, date2) {
    return this.moment(date1).isSameOrBefore(date2);
  }
  static extractDateFromFilename(filename, format) {
    try {
      const date = this.moment(filename, format, true);
      return date.isValid() ? date : null;
    } catch (error) {
      return null;
    }
  }
  static getJournalPathComponents(date, yearFormat, monthFormat) {
    const momentDate = date ? this.moment(date) : this.moment();
    const year = momentDate.format("YYYY");
    const monthName = momentDate.format("MMMM");
    const monthNumber = momentDate.format("MM");
    const yearFolderFormat = yearFormat && yearFormat !== "y_YYYY" ? yearFormat : "YYYY";
    const monthFolderFormat = monthFormat || "MM MMMM";
    let cleanMonthFormat = monthFolderFormat;
    if (monthFolderFormat === "MMmmmm" || monthFolderFormat === "MMMMM" || monthFolderFormat === "MMMM") {
      cleanMonthFormat = "MM MMMM";
    }
    return {
      year,
      monthName,
      monthNumber,
      yearFolder: momentDate.format(yearFolderFormat),
      monthFolder: momentDate.format(cleanMonthFormat)
    };
  }
  static getJournalFilename(date, format = "YYYY-MM-DD dddd") {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.format(format);
  }
  static previousDay(date) {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.subtract(1, "day");
  }
  static nextDay(date) {
    const momentDate = date ? this.moment(date) : this.moment();
    return momentDate.add(1, "day");
  }
  static *dateRange(startDate, endDate, unit = "day") {
    const current = this.moment(startDate);
    const end = this.moment(endDate);
    while (current.isSameOrBefore(end)) {
      yield this.moment(current);
      current.add(1, unit);
    }
  }
  static getMonthlyFolderPath(basePath, date, yearFormat, monthFormat) {
    const components = this.getJournalPathComponents(date, yearFormat, monthFormat);
    return `${basePath}/${components.yearFolder}/${components.monthFolder}`;
  }
  static getJournalFilePath(basePath, date, format = "YYYY-MM-DD dddd") {
    const monthlyPath = this.getMonthlyFolderPath(basePath, date);
    const filename = this.getJournalFilename(date, format);
    return `${monthlyPath}/${filename}.md`;
  }
  static isValidFormat(format) {
    try {
      const testDate = this.moment();
      testDate.format(format);
      return true;
    } catch (e) {
      return false;
    }
  }
  static getDebugInfo() {
    var _a;
    return {
      available: !!this.moment,
      version: ((_a = this.moment) == null ? void 0 : _a.version) || "unknown",
      type: typeof this.moment
    };
  }
};

// src/utils/debugUtils.ts
var DebugUtils = class {
  static initialize(plugin) {
    this.plugin = plugin;
  }
  static log(message, ...args) {
    if (this.isDebugEnabled()) {
      console.log(`[Link Plugin] ${message}`, ...args);
    }
  }
  static error(message, error) {
    console.error(`[Link Plugin] ${message}`, error);
  }
  static isDebugEnabled() {
    var _a, _b;
    return ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.debugMode) === true;
  }
};
DebugUtils.plugin = null;

// src/managers/directoryManager.ts
var DirectoryManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates the base directory structure according to settings
   * All directories are created under the configured baseFolder to prevent collisions
   */
  async rebuildDirectoryStructure() {
    const { vault } = this.plugin.app;
    const { baseFolder, directoryStructure } = this.plugin.settings;
    try {
      const basePath = baseFolder ? (0, import_obsidian2.normalizePath)(baseFolder) : "";
      if (basePath) {
        await this.getOrCreateDirectory(basePath);
        DebugUtils.log(`Created base directory: ${basePath}`);
      } else {
        DebugUtils.log("Using vault root as base directory");
      }
      for (const dirName of directoryStructure || ["journal"]) {
        if (dirName === "templates")
          continue;
        const dirPath = basePath ? PathUtils.joinPath(basePath, dirName) : dirName;
        await this.getOrCreateDirectory(dirPath);
        DebugUtils.log(`Created directory: ${dirPath}`);
      }
      await this.createJournalStructure(basePath);
    } catch (error) {
      throw new Error(`Failed to rebuild directory structure: ${error}`);
    }
  }
  /**
   * Creates journal structure - simple or dynamic based on single setting
   */
  async createJournalStructure(basePath) {
    const journalPath = PathUtils.joinPath(basePath, "journal");
    await this.getOrCreateDirectory(journalPath);
    DebugUtils.log(`Created journal directory: ${journalPath}`);
    if (!this.plugin.settings.simpleJournalMode) {
      const currentDate = DateService.now();
      const currentYear = DateService.format(currentDate, "YYYY");
      const currentMonth = DateService.format(currentDate, "MM MMMM");
      const currentYearPath = PathUtils.joinPath(journalPath, currentYear);
      const currentMonthPath = PathUtils.joinPath(currentYearPath, currentMonth);
      await this.getOrCreateDirectory(currentYearPath);
      await this.getOrCreateDirectory(currentMonthPath);
      DebugUtils.log(`Created current month directory: ${currentMonthPath}`);
      DebugUtils.log("Current month journal structure created");
    }
  }
  /**
   * Creates templates directory and copies the daily notes template when enabled
   * Templates are siblings to journal structure for proper organization
   */
  async setupTemplates() {
    try {
      const { baseFolder } = this.plugin.settings;
      const templatesPath = baseFolder ? PathUtils.joinPath(baseFolder, DEFAULT_TEMPLATES_PATH) : DEFAULT_TEMPLATES_PATH;
      await this.getOrCreateDirectory(templatesPath);
      DebugUtils.log(`Created templates directory: ${templatesPath}`);
      const templateFilePath = PathUtils.joinPath(
        templatesPath,
        DAILY_NOTES_TEMPLATE_NAME
      );
      const { vault } = this.plugin.app;
      if (!vault.getAbstractFileByPath(templateFilePath)) {
        const templateContent = DirectoryManager.getDailyNotesTemplateContent();
        await vault.create(templateFilePath, templateContent);
        DebugUtils.log(`Created template file: ${templateFilePath}`);
      } else {
        DebugUtils.log(`Template already exists: ${templateFilePath}`);
      }
    } catch (error) {
      throw new Error(`Failed to setup templates: ${error}`);
    }
  }
  /**
   * Gets the daily notes template content from the plugin assets
   * Always returns the raw template with Templater syntax to avoid conflicts
   */
  static getDailyNotesTemplateContent() {
    return `---
previous: '[[<% tp.date.now("YYYY-MM-DD dddd", -1) %>]]'
next: '[[<% tp.date.now("YYYY-MM-DD dddd", 1) %>]]'
tags:
  - \u2600\uFE0F
  - <% tp.date.now("MM-DD dddd") %>
resources: []
---
---
## Log

### Routine Checklist

- [ ] Open Daily Note
- [ ] **Morning Checks**
	- [ ] Bed and Clothes \u{1F6CF}\uFE0F\u{1F9FA}
  - [ ] Self Care\u{1F6C0}\u{1F9F4}
  - [ ] Make Breakfast \u{1F37D}\u2728
	- [ ] Pet Care \u{1F415}\u{1F6B6}\u{1F3FB}\u200D\u2642\uFE0F
	- [ ] Get Focused \u{1F5A5}\uFE0F\u{1F48A}
  - [ ] Check [Calendar](https://calendar.google.com) \u{1F4C6}
	- [ ] Check [Mail](https://mail.google.com) \u2709\uFE0F 
  - [ ] Review [[Yearly List]] \u2705
	- [ ] Review [July Log](Yearly%20Log.md#July) \u{1F5D3}\uFE0F

---`;
  }
  /**
   * Returns the full path to the journal directory, respecting baseFolder and settings
   */
  getJournalPath() {
    const { baseFolder } = this.plugin.settings;
    return baseFolder ? PathUtils.joinPath(baseFolder, "journal") : "journal";
  }
  /**
   * Gets a directory path, creating it if it doesn't exist
   * Handles both absolute paths and paths relative to the base folder
   */
  async getOrCreateDirectory(path) {
    const { vault } = this.plugin.app;
    const normalizedPath = (0, import_obsidian2.normalizePath)(path);
    const existingFolder = vault.getAbstractFileByPath(normalizedPath);
    if (existingFolder instanceof import_obsidian2.TFolder) {
      return existingFolder;
    }
    const pathParts = normalizedPath.split("/");
    let currentPath = "";
    for (const part of pathParts) {
      if (!part)
        continue;
      currentPath += (currentPath ? "/" : "") + part;
      const folder = vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await vault.createFolder(currentPath);
      } else if (!(folder instanceof import_obsidian2.TFolder)) {
        throw new Error(`Path ${currentPath} exists but is not a folder`);
      }
    }
    return vault.getAbstractFileByPath(normalizedPath);
  }
};

// src/managers/journalManager.ts
var import_obsidian3 = require("obsidian");
var JournalManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates or opens a journal entry for the specified date
   * Automatically creates monthly folders as needed
   */
  async createOrOpenJournalEntry(date) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    await this.ensureMonthlyFolderExists(date);
    const monthlyFolderPath = this.getMonthlyFolderPath(date);
    const fileName = DateService.getJournalFilename(date, journalDateFormat);
    const filePath = (0, import_obsidian3.normalizePath)(`${monthlyFolderPath}/${fileName}.md`);
    let file = vault.getAbstractFileByPath(filePath);
    if (!file) {
      const templateContent = this.getTemplateContentForDate(date);
      file = await vault.create(filePath, templateContent);
      DebugUtils.log(`Created daily note with template: ${filePath}`);
    } else {
      const content = await vault.read(file);
      if (!content.trim()) {
        const templateContent = this.getTemplateContentForDate(date);
        await vault.modify(file, templateContent);
        DebugUtils.log(`Populated existing empty note with template: ${filePath}`);
      }
    }
    return file;
  }
  /**
   * Ensures the monthly folder exists for the given date
   * Creates the folder structure if it doesn't exist
   */
  async ensureMonthlyFolderExists(date) {
    const monthlyFolderPath = this.getMonthlyFolderPath(date);
    const monthName = DateService.format(date, "MMMM YYYY");
    const folder = this.plugin.app.vault.getFolderByPath(monthlyFolderPath);
    const folderExists = folder !== null;
    if (!folderExists) {
      await this.plugin.directoryManager.getOrCreateDirectory(monthlyFolderPath);
      DebugUtils.log(`\u2705 Created monthly folder for ${monthName}: ${monthlyFolderPath}`);
    } else {
      DebugUtils.log(`Monthly folder for ${monthName} already exists: ${monthlyFolderPath}`);
    }
  }
  /**
   * Gets the monthly folder path for a given date
   * Uses simple mode OR dynamic folders based on single setting
   */
  getMonthlyFolderPath(date) {
    const journalBasePath = this.plugin.directoryManager.getJournalPath();
    if (this.plugin.settings.simpleJournalMode) {
      return journalBasePath;
    }
    return DateService.getMonthlyFolderPath(
      journalBasePath,
      date,
      this.plugin.settings.journalYearFormat,
      this.plugin.settings.journalMonthFormat
    );
  }
  /**
   * Creates a daily note for today if it doesn't exist
   * Automatically handles monthly folder creation
   */
  async createTodayNote() {
    const today = DateService.now();
    return await this.createOrOpenJournalEntry(today);
  }
  /**
   * Creates a daily note for a future date
   * Automatically creates monthly folders as needed
   * Uses the daily note template and modifies previous/next dates for the target date
   */
  async createFutureDailyNote(date) {
    const targetDate = DateService.from(date);
    DebugUtils.log(`Creating future daily note for: ${DateService.format(targetDate, "YYYY-MM-DD")}`);
    const file = await this.createOrOpenJournalEntry(targetDate);
    const monthlyPath = this.getMonthlyFolderPath(targetDate);
    DebugUtils.log(`Future note created in: ${monthlyPath}`);
    return file;
  }
  /**
   * Gets the template content modified for a specific date
   * Replaces the current moment references with the target date
   */
  getTemplateContentForDate(targetDate) {
    const { journalDateFormat } = this.plugin.settings;
    const baseTemplate = DirectoryManager.getDailyNotesTemplateContent();
    const previousDate = DateService.previousDay(targetDate);
    const nextDate = DateService.nextDay(targetDate);
    const previousFormatted = DateService.format(previousDate, journalDateFormat);
    const nextFormatted = DateService.format(nextDate, journalDateFormat);
    const targetFormatted = DateService.format(targetDate, journalDateFormat);
    const modifiedTemplate = baseTemplate.replace(/<% tp\.date\.now\("YYYY-MM-DD dddd", -1\) %>/g, previousFormatted).replace(/<% tp\.date\.now\("YYYY-MM-DD dddd", 1\) %>/g, nextFormatted).replace(/<% tp\.date\.now\("MM-DD dddd"\) %>/g, DateService.format(targetDate, "MM-DD dddd"));
    return modifiedTemplate;
  }
  /**
   * Opens the journal entry for today
   * Creates monthly folder and daily note if they don't exist
   */
  async openTodayJournal() {
    const today = DateService.now();
    const file = await this.createOrOpenJournalEntry(today);
    const leaf = this.plugin.app.workspace.getLeaf();
    await leaf.openFile(file);
  }
  /**
   * Checks if we need to create a new monthly folder
   * Called when the plugin loads, when creating notes, or when date changes
   */
  async checkAndCreateCurrentMonthFolder() {
    const currentDate = DateService.now();
    await this.ensureMonthlyFolderExists(currentDate);
    const daysUntilNextMonth = DateService.endOfMonth(currentDate).diff(currentDate, "days");
    if (daysUntilNextMonth <= 2) {
      const nextMonth = DateService.add(currentDate, 1, "month");
      await this.ensureMonthlyFolderExists(nextMonth);
      DebugUtils.log("Pre-created next month folder (end of month detected)");
    }
  }
  /**
   * Creates monthly folders for a range of dates
   * Useful for batch creation or setup
   */
  async createMonthlyFoldersForRange(startDate, endDate) {
    let current = DateService.startOfMonth(startDate);
    const end = DateService.endOfMonth(endDate);
    while (DateService.isSameOrBefore(current, end)) {
      await this.ensureMonthlyFolderExists(current);
      current = DateService.add(current, 1, "month");
    }
  }
  /**
   * Opens journal entry for a specific date
   */
  async openJournalForDate(date) {
    const momentDate = DateService.from(date);
    const file = await this.createOrOpenJournalEntry(momentDate);
    const leaf = this.plugin.app.workspace.getLeaf();
    await leaf.openFile(file);
  }
  /**
   * Updates links between journal entries
   */
  async updateJournalLinks(file) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    const fileDate = DateService.extractDateFromFilename(file.basename, journalDateFormat || "YYYY-MM-DD dddd");
    if (!fileDate)
      return;
    const content = await vault.read(file);
    const previousDay = DateService.previousDay(fileDate);
    const nextDay = DateService.nextDay(fileDate);
    const previousFileName = DateService.format(previousDay, journalDateFormat);
    const nextFileName = DateService.format(nextDay, journalDateFormat);
    const updatedContent = content.replace(/previous: '\[\[(.*?)\]\]'/g, `previous: '[[${previousFileName}]]'`).replace(/next: '\[\[(.*?)\]\]'/g, `next: '[[${nextFileName}]]'`);
    if (updatedContent !== content) {
      await vault.modify(file, updatedContent);
    }
  }
  /**
   * Get journal entries for a date range
   */
  async getJournalEntries(startDate, endDate) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    const entries = [];
    let current = DateService.from(startDate);
    while (DateService.isSameOrBefore(current, endDate)) {
      const filePath = DateService.getJournalFilePath(
        this.plugin.directoryManager.getJournalPath(),
        current,
        journalDateFormat
      );
      const file = vault.getAbstractFileByPath(filePath);
      if (file) {
        entries.push({
          date: DateService.format(current, "YYYY-MM-DD"),
          path: filePath,
          title: DateService.format(current, journalDateFormat),
          previous: DateService.format(DateService.previousDay(current), "YYYY-MM-DD"),
          next: DateService.format(DateService.nextDay(current), "YYYY-MM-DD")
        });
      }
      current = DateService.add(current, 1, "day");
    }
    return entries;
  }
};

// src/utils/errorHandler.ts
var import_obsidian4 = require("obsidian");
var ErrorHandler = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  handleError(error, context) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`${context}: ${message}`);
    new import_obsidian4.Notice(`${context}: ${message}`);
  }
  showNotice(message, duration) {
    new import_obsidian4.Notice(message, duration);
  }
  showSuccess(message) {
    new import_obsidian4.Notice(message, 3e3);
  }
  showWarning(message) {
    new import_obsidian4.Notice(`\u26A0\uFE0F ${message}`, 5e3);
  }
};

// src/ui/ribbonManager.ts
var import_obsidian5 = require("obsidian");
var RibbonManager = class {
  constructor(plugin) {
    this.ribbonButtons = [];
    this.plugin = plugin;
  }
  /**
   * Initialize ribbon with core journal functionality only
   */
  initializeRibbon() {
    this.clearRibbon();
    this.addCreateFutureNoteButton();
    if (this.plugin.settings.showRibbonButton) {
      this.addSettingsButton();
    }
    DebugUtils.log("Ribbon initialized - Core journal functionality enabled");
  }
  /**
   * Add Create Future Note button - CORE FEATURE with date picker
   */
  addCreateFutureNoteButton() {
    const button = this.plugin.addRibbonIcon(
      "calendar-plus",
      "Create Future Note - Select date to create note",
      async () => {
        if (!this.plugin.settings.enabled) {
          this.plugin.errorHandler.showNotice("\u274C Plugin is disabled. Enable it in settings to use this feature.");
          return;
        }
        try {
          const selectedDate = await this.showDatePicker();
          if (selectedDate) {
            const file = await this.plugin.journalManager.createFutureDailyNote(selectedDate);
            const leaf = this.plugin.app.workspace.getLeaf();
            await leaf.openFile(file);
            const formattedDate = DateService.format(DateService.from(selectedDate), "YYYY-MM-DD");
            this.showSuccess(`Created future note for ${formattedDate}`);
          }
        } catch (error) {
          this.plugin.errorHandler.handleError(error, "Failed to create future note");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Show date picker modal for future note creation - FIXED MODAL API
   */
  async showDatePicker() {
    return new Promise((resolve) => {
      const modal = new import_obsidian5.Modal(this.plugin.app);
      modal.setTitle("Create Future Daily Note");
      const { contentEl } = modal;
      const instructions = contentEl.createEl("p");
      instructions.textContent = "Select a date to create a daily note. This will automatically create the required monthly folders.";
      instructions.style.marginBottom = "1em";
      instructions.style.color = "var(--text-muted)";
      const dateInput = contentEl.createEl("input");
      dateInput.type = "date";
      dateInput.style.width = "100%";
      dateInput.style.padding = "8px";
      dateInput.style.marginBottom = "1em";
      dateInput.style.border = "1px solid var(--background-modifier-border)";
      dateInput.style.borderRadius = "4px";
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      dateInput.value = tomorrow.toISOString().split("T")[0];
      const buttonContainer = contentEl.createDiv();
      buttonContainer.style.display = "flex";
      buttonContainer.style.gap = "8px";
      buttonContainer.style.justifyContent = "flex-end";
      const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
      cancelButton.onclick = () => {
        modal.close();
        resolve(null);
      };
      const createButton = buttonContainer.createEl("button", {
        text: "Create Note",
        cls: "mod-cta"
      });
      createButton.onclick = () => {
        const selectedDate = dateInput.value;
        if (selectedDate) {
          modal.close();
          resolve(selectedDate);
        }
      };
      dateInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          const selectedDate = dateInput.value;
          if (selectedDate) {
            modal.close();
            resolve(selectedDate);
          }
        }
      });
      modal.scope.register([], "Escape", () => {
        modal.close();
        resolve(null);
      });
      modal.open();
      setTimeout(() => dateInput.focus(), 100);
    });
  }
  /**
   * Add Settings button
   */
  addSettingsButton() {
    const button = this.plugin.addRibbonIcon(
      "link",
      "Open Obsidian Link Journal Settings",
      () => {
        try {
          this.plugin.app.setting.open();
          this.plugin.app.setting.openTabById(this.plugin.manifest.id);
        } catch (error) {
          this.plugin.errorHandler.showNotice("Please open Settings \u2192 Community Plugins \u2192 Obsidian Link Journal to configure");
          this.plugin.errorHandler.handleError(error, "Failed to open settings automatically");
        }
      }
    );
    this.ribbonButtons.push(button);
  }
  /**
   * Clear all ribbon buttons
   */
  clearRibbon() {
    this.ribbonButtons.forEach((button) => button.remove());
    this.ribbonButtons = [];
  }
  /**
   * Cleanup method for plugin unload
   */
  cleanup() {
    this.clearRibbon();
  }
  /**
   * Update button states based on settings
   */
  updateButtonStates() {
    this.initializeRibbon();
    DebugUtils.log("Ribbon buttons updated");
  }
  /**
   * Show quick actions menu
   */
  showQuickActionsMenu() {
    if (!this.plugin.settings.enabled) {
      this.plugin.errorHandler.showNotice("\u274C Plugin is disabled. Enable it in settings to use journal management features.");
      return;
    }
    const message = `Obsidian Link Journal Quick Actions:
\u2022 Create Today's Note: Open or create today's journal
\u2022 Create Monthly Folders: Set up folder structure
\u2022 Settings: Configure journal management`;
    this.plugin.errorHandler.showNotice(message);
  }
  /**
   * Show success message
   */
  showSuccess(message) {
    this.plugin.errorHandler.showNotice(message);
  }
};

// src/ui/settingsTab.ts
var import_obsidian6 = require("obsidian");
var SettingsTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("p", {
      text: "Simple journal management settings",
      cls: "setting-item-description"
    });
    new import_obsidian6.Setting(containerEl).setName("Plugin Status").setHeading();
    this.addPluginStatusSettings(containerEl);
    new import_obsidian6.Setting(containerEl).setName("Daily Notes Integration").setHeading();
    this.addDailyNotesIntegrationSettings(containerEl);
    new import_obsidian6.Setting(containerEl).setName("Core Settings").setHeading();
    this.addCoreSettings(containerEl);
    new import_obsidian6.Setting(containerEl).setName("Journal Template Settings").setHeading();
    this.addJournalTemplateSettings(containerEl);
  }
  addPluginStatusSettings(containerEl) {
    new import_obsidian6.Setting(containerEl).setName("Enable Plugin").setDesc("Enable or disable the journal management plugin. When disabled, no folder structure or integration operations will be performed.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enabled).onChange(async (value) => {
        this.plugin.settings.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          try {
            await this.plugin.directoryManager.rebuildDirectoryStructure();
            await this.plugin.journalManager.checkAndCreateCurrentMonthFolder();
            await this.plugin.updateDailyNotesSettings();
            this.plugin.errorHandler.showNotice(
              "\u2705 Plugin enabled - Journal management features are now active!"
            );
          } catch (error) {
            this.plugin.errorHandler.handleError(
              error,
              "Failed to initialize plugin after enabling"
            );
          }
        } else {
          this.plugin.errorHandler.showNotice(
            "\u26A0\uFE0F Plugin disabled - Journal management features are now inactive"
          );
        }
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Show Ribbon Button").setDesc("Show or hide the Link settings button in the ribbon. When hidden, you can still access settings through the Community Plugins menu.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showRibbonButton).onChange(async (value) => {
        this.plugin.settings.showRibbonButton = value;
        await this.plugin.saveSettings();
        this.plugin.ribbonManager.updateButtonStates();
        if (value) {
          this.plugin.errorHandler.showNotice(
            "\u2705 Ribbon button is now visible"
          );
        } else {
          this.plugin.errorHandler.showNotice(
            "\u26A0\uFE0F Ribbon button is now hidden. Access settings via Community Plugins menu."
          );
        }
      })
    );
  }
  addCoreSettings(containerEl) {
    new import_obsidian6.Setting(containerEl).setName("Base Folder").setDesc("Root folder for journal content (empty = vault root)").addText(
      (text) => text.setPlaceholder("Link").setValue(this.plugin.settings.baseFolder).onChange(async (value) => {
        this.plugin.settings.baseFolder = value.trim();
        await this.plugin.saveSettings();
        this.display();
      })
    ).then((setting) => {
      const textComponent = setting.components[0];
      if (textComponent && textComponent.inputEl) {
        const input = textComponent.inputEl;
        const wrapper = input.parentElement;
        if (wrapper) {
          const prefix = wrapper.createSpan({ text: "/", cls: "path-prefix" });
          wrapper.insertBefore(prefix, input);
          prefix.style.marginRight = "2px";
          prefix.style.opacity = "0.6";
        }
      }
    });
    const optionalFolders = [
      { name: "Workspace", key: "workspace" },
      { name: "Reference", key: "reference" }
    ];
    optionalFolders.forEach((folder) => {
      new import_obsidian6.Setting(containerEl).setName(`${folder.name} Folder`).setDesc(
        `Create a ${folder.name.toLowerCase()} folder alongside journal`
      ).addToggle((toggle) => {
        const enabled = this.plugin.settings.directoryStructure.includes(
          folder.key
        );
        toggle.setValue(enabled).onChange(async (value) => {
          const dirs = this.plugin.settings.directoryStructure.filter(
            (d) => d !== folder.key
          );
          if (value)
            dirs.push(folder.key);
          this.plugin.settings.directoryStructure = dirs;
          await this.plugin.saveSettings();
        });
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Rebuild Journal Structure").setDesc("Recreate the journal folder structure").addButton(
      (button) => button.setButtonText("Rebuild").onClick(async () => {
        try {
          await this.plugin.directoryManager.rebuildDirectoryStructure();
          alert(
            "\u2705 Journal structure rebuilt successfully!\n\nJournal folder structure has been recreated in: " + this.plugin.settings.baseFolder
          );
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          alert(
            "\u274C Failed to rebuild journal structure.\n\nError: " + errorMessage
          );
          this.plugin.errorHandler.handleError(
            error,
            "Failed to rebuild journal structure"
          );
        }
      })
    );
    this.addJournalSettings(containerEl);
    new import_obsidian6.Setting(containerEl).setName("Debug Mode").setDesc("Enable debug logging to console (for troubleshooting)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
        this.plugin.settings.debugMode = value;
        await this.plugin.saveSettings();
      })
    );
  }
  addJournalSettings(containerEl) {
    new import_obsidian6.Setting(containerEl).setName("Year Folder Format").setDesc('Format for year folders (YYYY creates "2025")').addText(
      (text) => text.setPlaceholder("YYYY").setValue(this.plugin.settings.journalYearFormat).onChange(async (value) => {
        if (value.trim()) {
          this.plugin.settings.journalYearFormat = value.trim();
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Month Folder Format").setDesc('Format for month folders (MM MMMM creates "07-July")').addText(
      (text) => text.setPlaceholder("MM MMMM").setValue(this.plugin.settings.journalMonthFormat).onChange(async (value) => {
        if (value.trim()) {
          this.plugin.settings.journalMonthFormat = value.trim();
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Daily Note Format").setDesc("Format for daily note filenames").addText(
      (text) => text.setPlaceholder("YYYY-MM-DD dddd").setValue(this.plugin.settings.journalDateFormat).onChange(async (value) => {
        if (value.trim()) {
          this.plugin.settings.journalDateFormat = value.trim();
          await this.plugin.saveSettings();
        }
      })
    );
  }
  addJournalTemplateSettings(containerEl) {
    new import_obsidian6.Setting(containerEl).setName("Daily Note Template Location").setDesc(
      'Override the default template path (e.g. "templates/Daily Notes Template.md")'
    ).addText(
      (text) => text.setPlaceholder("templates/Daily Notes Template.md").setValue(this.plugin.settings.customTemplateLocation || "").onChange(async (value) => {
        this.plugin.settings.customTemplateLocation = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Setup Templates").setDesc(
      "Create templates directory alongside journal and copy Daily Notes template (works with Templater plugin)"
    ).addButton(
      (button) => button.setButtonText("Setup Templates").onClick(async () => {
        var _a, _b;
        try {
          await this.plugin.directoryManager.setupTemplates();
          const templatesPath = this.plugin.settings.baseFolder ? `${this.plugin.settings.baseFolder}/templates` : "templates";
          const templaterPlugin = (_b = (_a = this.plugin.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["templater-obsidian"];
          const hasTemplater = templaterPlugin && templaterPlugin._loaded;
          const templaterStatus = hasTemplater ? "\n\n\u2705 Templater plugin detected - Template will work with dynamic dates" : "\n\n\u26A0\uFE0F Templater plugin not detected - Template contains Templater syntax that may not render";
          alert(
            "\u2705 Templates setup successfully!\n\nTemplates directory created alongside journal at: " + templatesPath + templaterStatus
          );
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          alert("\u274C Failed to setup templates.\n\nError: " + errorMessage);
          this.plugin.errorHandler.handleError(
            error,
            "Failed to setup templates"
          );
        }
      })
    );
  }
  /**
   * Adds Daily Notes integration settings with backup and restore functionality
   */
  addDailyNotesIntegrationSettings(containerEl) {
    containerEl.createEl("p", {
      text: "Control how this plugin integrates with Obsidian's Daily Notes plugin. Your original settings will be backed up automatically.",
      cls: "setting-item-description"
    });
    new import_obsidian6.Setting(containerEl).setDesc(
      "Automatically backup and apply Daily Notes plugin settings to use our folder structure"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.dailyNotesIntegration.enabled).onChange(async (value) => {
        try {
          if (value) {
            await this.plugin.updateDailyNotesSettings();
            this.plugin.settings.dailyNotesIntegration.enabled = true;
            this.plugin.errorHandler.showSuccess("\u2705 Daily Notes integration enabled! Your original settings have been backed up.");
          } else {
            await this.plugin.restoreDailyNotesSettings();
            this.plugin.settings.dailyNotesIntegration.enabled = false;
            this.plugin.errorHandler.showSuccess("\u2705 Daily Notes integration disabled! Your original settings have been restored.");
          }
          await this.plugin.saveSettings();
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          this.showStatus(
            containerEl,
            "\u274C Failed to " + (value ? "enable" : "disable") + " integration. " + errorMessage,
            false
          );
          this.plugin.errorHandler.handleError(
            error,
            "Failed to " + (value ? "enable" : "disable") + " Daily Notes integration"
          );
          toggle.setValue(!value);
        }
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Reapply Integration Settings").setDesc("Reapply the integration settings to Daily Notes plugin").addButton(
      (button) => button.setButtonText("Reapply").onClick(async () => {
        try {
          await this.plugin.updateDailyNotesSettings();
          this.plugin.errorHandler.showSuccess("\u2705 Daily Notes integration settings reapplied successfully!");
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          this.showStatus(
            containerEl,
            "\u274C Failed to reapply integration settings. " + errorMessage,
            false
          );
          this.plugin.errorHandler.handleError(
            error,
            "Failed to reapply Daily Notes integration"
          );
        }
      })
    );
    const backup = this.plugin.settings.dailyNotesIntegration.backup;
    if (backup) {
      const backupDate = new Date(backup.timestamp).toLocaleString();
      new import_obsidian6.Setting(containerEl).setName("\u{1F4E6} Backup Information").setDesc(`Backup created: ${backupDate} (${backup.pluginType} plugin)`);
    }
  }
  // Helper to show status/feedback message
  showStatus(containerEl, message, success) {
    const status = containerEl.createDiv({ cls: "setting-item-info" });
    status.style.marginTop = "12px";
    status.style.marginBottom = "12px";
    status.style.color = success ? "var(--text-success)" : "var(--text-error)";
    status.style.fontWeight = "bold";
    status.innerText = message;
  }
};

// src/main.ts
var LinkPlugin = class extends import_obsidian7.Plugin {
  async onload() {
    DebugUtils.initialize(this);
    DebugUtils.log("Loading Obsidian Link Journal v2.2.0 - Pure Journal Management...");
    try {
      DateService.initialize();
      await this.loadSettings();
      this.errorHandler = new ErrorHandler(this);
      this.directoryManager = new DirectoryManager(this);
      this.journalManager = new JournalManager(this);
      this.ribbonManager = new RibbonManager(this);
      this.addSettingTab(new SettingsTab(this.app, this));
      this.ribbonManager.initializeRibbon();
      this.registerCommands();
      this.registerEventHandlers();
      if (this.settings.enabled) {
        await this.directoryManager.rebuildDirectoryStructure();
        await this.journalManager.checkAndCreateCurrentMonthFolder();
        await this.updateDailyNotesSettings();
        this.startDateChangeMonitoring();
        const debugInfo = DateService.getDebugInfo();
        DebugUtils.log("DateService initialized:", debugInfo);
        DebugUtils.log("Today:", DateService.today());
        DebugUtils.log("Current month:", DateService.currentMonth());
        this.errorHandler.showNotice(
          "Obsidian Link Journal loaded - Pure journal management ready!"
        );
        DebugUtils.log("Obsidian Link Journal loaded successfully - Core journal functionality enabled");
      } else {
        DebugUtils.log("Obsidian Link Journal loaded - Plugin disabled, no operations performed");
        this.errorHandler.showNotice(
          "Obsidian Link Journal loaded - Plugin is disabled. Enable it in settings to start using journal management features."
        );
      }
    } catch (error) {
      DebugUtils.error("Failed to load Link Plugin:", error);
      if (this.errorHandler) {
        this.errorHandler.handleError(error, "Plugin initialization failed");
      }
    }
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    if (!loadedData || Object.keys(loadedData).length === 0) {
      this.settings = { ...DEFAULT_SETTINGS };
      await this.saveSettings();
    } else {
      this.settings = validateSettings({ ...DEFAULT_SETTINGS, ...loadedData });
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.ribbonManager) {
      this.ribbonManager.updateButtonStates();
    }
  }
  registerCommands() {
    this.addCommand({
      id: COMMAND_IDS.REBUILD_DIRECTORY,
      name: "Rebuild Directory Structure",
      callback: () => {
        if (!this.settings.enabled) {
          this.errorHandler.showNotice("\u274C Plugin is disabled. Enable it in settings to use this command.");
          return;
        }
        try {
          this.directoryManager.rebuildDirectoryStructure();
        } catch (error) {
          this.errorHandler.handleError(
            error,
            "Failed to rebuild directory structure"
          );
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.OPEN_TODAY_JOURNAL,
      name: "Open Today's Journal",
      callback: () => {
        if (!this.settings.enabled) {
          this.errorHandler.showNotice("\u274C Plugin is disabled. Enable it in settings to use this command.");
          return;
        }
        try {
          this.journalManager.openTodayJournal();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to open today's journal");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_TODAY_NOTE,
      name: "Create Today's Daily Note",
      callback: async () => {
        if (!this.settings.enabled) {
          this.errorHandler.showNotice("\u274C Plugin is disabled. Enable it in settings to use this command.");
          return;
        }
        try {
          const file = await this.journalManager.createTodayNote();
          const leaf = this.app.workspace.getLeaf();
          await leaf.openFile(file);
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create today's note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_FUTURE_NOTE,
      name: "Create Future Daily Note",
      callback: async () => {
        if (!this.settings.enabled) {
          this.errorHandler.showNotice("\u274C Plugin is disabled. Enable it in settings to use this command.");
          return;
        }
        try {
          const dateInput = await this.promptForDate();
          if (dateInput) {
            const file = await this.journalManager.createFutureDailyNote(
              dateInput
            );
            const leaf = this.app.workspace.getLeaf();
            await leaf.openFile(file);
            this.errorHandler.showNotice(
              `Created future note for ${DateService.format(
                DateService.from(dateInput),
                "YYYY-MM-DD"
              )}`
            );
          }
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create future note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_MONTHLY_FOLDERS,
      name: "Create Monthly Folders for Current Year",
      callback: async () => {
        if (!this.settings.enabled) {
          this.errorHandler.showNotice("\u274C Plugin is disabled. Enable it in settings to use this command.");
          return;
        }
        try {
          const startOfYear = DateService.startOfYear();
          const endOfYear = DateService.endOfYear();
          await this.journalManager.createMonthlyFoldersForRange(
            startOfYear,
            endOfYear
          );
          this.errorHandler.showNotice(
            "Monthly folders created for current year"
          );
        } catch (error) {
          this.errorHandler.handleError(
            error,
            "Failed to create monthly folders"
          );
        }
      }
    });
    this.addCommand({
      id: "show-ribbon-actions",
      name: "Show Ribbon Quick Actions",
      callback: () => {
        if (!this.settings.enabled) {
          this.errorHandler.showNotice("\u274C Plugin is disabled. Enable it in settings to use this command.");
          return;
        }
        try {
          this.ribbonManager.showQuickActionsMenu();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to show ribbon actions");
        }
      }
    });
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (this.settings.enabled && "stat" in file && "basename" in file && "extension" in file && file.path.includes(this.settings.journalRootFolder)) {
          this.journalManager.updateJournalLinks(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (this.settings.enabled && this.settings.debugMode && file.path.includes(this.settings.journalRootFolder)) {
          DebugUtils.log("Journal file modified:", file.path);
        }
      })
    );
  }
  /**
   * Algorithm 5: Date Input Modal
   * Presents a modal dialog for date input, handles user input and keyboard shortcuts.
   */
  async promptForDate() {
    return new Promise((resolve) => {
      const modal = new import_obsidian7.Modal(this.app);
      modal.setTitle("Create Future Daily Note");
      const { contentEl } = modal;
      contentEl.createEl("p", {
        text: "Select a date to create a daily note. This will automatically create the required monthly folders.",
        cls: "modal-description"
      });
      const inputContainer = contentEl.createDiv({
        cls: "date-input-container"
      });
      const input = inputContainer.createEl("input", {
        type: "date",
        value: DateService.today(),
        cls: "date-input"
      });
      contentEl.createDiv({ cls: "date-picker-spacer" });
      const buttonContainer = contentEl.createDiv({
        cls: "modal-button-container"
      });
      const createButton = buttonContainer.createEl("button", {
        text: "Create Note",
        cls: "mod-cta"
      });
      const cancelButton = buttonContainer.createEl("button", {
        text: "Cancel"
      });
      const style = document.createElement("style");
      style.textContent = `
        .date-input-container {
          margin: 16px 0;
          position: relative;
          z-index: 1;
        }
        .date-input {
          width: 100%;
          padding: 8px 12px;
          border: 1px solid var(--background-modifier-border);
          border-radius: 4px;
          background: var(--background-primary);
          color: var(--text-normal);
          font-size: 14px;
        }
        .date-picker-spacer {
          height: 40px;
        }
        .modal-button-container {
          display: flex;
          gap: 8px;
          justify-content: flex-end;
          margin-top: 20px;
        }
        .modal-description {
          margin-bottom: 16px;
          color: var(--text-muted);
        }
      `;
      contentEl.appendChild(style);
      setTimeout(() => input.focus(), 100);
      createButton.onclick = () => {
        const dateValue = input.value;
        if (dateValue) {
          modal.close();
          resolve(dateValue);
        }
      };
      cancelButton.onclick = () => {
        modal.close();
        resolve(null);
      };
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          createButton.click();
        } else if (e.key === "Escape") {
          cancelButton.click();
        }
      });
      modal.open();
    });
  }
  /**
   * Algorithm 6: Date Change Monitoring
   * Periodically checks if the month has changed and creates new monthly folders as needed.
   */
  startDateChangeMonitoring() {
    let lastCheckedMonth = DateService.format(DateService.now(), "YYYY-MM");
    this.registerInterval(
      window.setInterval(async () => {
        try {
          if (!this.settings.enabled) {
            return;
          }
          const currentMonth = DateService.format(DateService.now(), "YYYY-MM");
          if (currentMonth !== lastCheckedMonth) {
            DebugUtils.log(
              `Month changed from ${lastCheckedMonth} to ${currentMonth} - creating new monthly folder`
            );
            await this.journalManager.checkAndCreateCurrentMonthFolder();
            await this.updateDailyNotesSettings();
            lastCheckedMonth = currentMonth;
            const monthName = DateService.format(DateService.now(), "MMMM YYYY");
            this.errorHandler.showNotice(
              `\u{1F4C5} New month detected: ${monthName} folder created`
            );
          }
        } catch (error) {
          DebugUtils.error("Error in date change monitoring:", error);
        }
      }, 60 * 60 * 1e3)
    );
    DebugUtils.log(
      "Date change monitoring started - will auto-create monthly folders"
    );
  }
  /**
   * Algorithm 7: Daily Notes Plugin Integration
   * Updates Obsidian's Daily Notes plugin settings to use our folder structure.
   */
  async updateDailyNotesSettings() {
    var _a, _b, _c, _d;
    if (!this.settings.dailyNotesIntegration.enabled) {
      return;
    }
    try {
      const dailyNotesPlugin = (_b = (_a = this.app.internalPlugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["daily-notes"];
      if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        await this.updateCorePluginSettings(dailyNotesPlugin);
      } else {
        const communityDailyNotes = (_d = (_c = this.app.plugins) == null ? void 0 : _c.plugins) == null ? void 0 : _d["daily-notes"];
        if (communityDailyNotes) {
          await this.updateCommunityPluginSettings(communityDailyNotes);
        } else {
          DebugUtils.log(
            "Daily Notes plugin not found or not enabled - using plugin folder structure only"
          );
        }
      }
    } catch (error) {
      DebugUtils.log(
        "Daily Notes integration skipped:",
        error instanceof Error ? error.message : String(error)
      );
    }
  }
  /**
   * Algorithm 7: Daily Notes Plugin Integration (Core)
   * Updates core Daily Notes plugin settings with backup.
   */
  async updateCorePluginSettings(dailyNotesPlugin) {
    const dailyNotesSettings = dailyNotesPlugin.instance.options;
    if (!this.settings.dailyNotesIntegration.backup) {
      await this.createDailyNotesBackup("core", dailyNotesSettings);
    }
    const currentDate = DateService.now();
    const monthlyFolderPath = this.journalManager.getMonthlyFolderPath(currentDate);
    dailyNotesSettings.folder = monthlyFolderPath;
    dailyNotesSettings.format = this.settings.journalDateFormat;
    const templatesPath = this.settings.customTemplateLocation ? this.settings.customTemplateLocation : this.settings.baseFolder ? `${this.settings.baseFolder}/templates/Daily Notes Template.md` : "templates/Daily Notes Template.md";
    dailyNotesSettings.template = templatesPath;
    DebugUtils.log(`Updated Core Daily Notes plugin settings`);
    this.errorHandler.showNotice(`\u2705 Daily Notes settings updated`);
  }
  /**
   * Algorithm 7: Daily Notes Plugin Integration (Community)
   * Updates community Daily Notes plugin settings with backup.
   */
  async updateCommunityPluginSettings(communityDailyNotes) {
    if (!this.settings.dailyNotesIntegration.backup) {
      await this.createDailyNotesBackup(
        "community",
        communityDailyNotes.settings
      );
    }
    const currentDate = DateService.now();
    const monthlyFolderPath = this.journalManager.getMonthlyFolderPath(currentDate);
    communityDailyNotes.settings.folder = monthlyFolderPath;
    communityDailyNotes.settings.format = this.settings.journalDateFormat;
    const templatesPath = this.settings.customTemplateLocation ? this.settings.customTemplateLocation : this.settings.baseFolder ? `${this.settings.baseFolder}/templates/Daily Notes Template.md` : "templates/Daily Notes Template.md";
    communityDailyNotes.settings.template = templatesPath;
    await communityDailyNotes.saveSettings();
    DebugUtils.log(`Updated Community Daily Notes plugin settings`);
    this.errorHandler.showNotice(`\u2705 Daily Notes settings updated`);
  }
  /**
   * Algorithm 8: Backup/Restore Algorithm (Backup)
   * Creates a backup of current Daily Notes settings.
   */
  async createDailyNotesBackup(pluginType, currentSettings) {
    this.settings.dailyNotesIntegration.backup = {
      timestamp: new Date().toISOString(),
      pluginType,
      originalSettings: { ...currentSettings }
    };
    await this.saveSettings();
    DebugUtils.log(`Created Daily Notes backup for ${pluginType} plugin`);
  }
  /**
   * Algorithm 8: Backup/Restore Algorithm (Restore)
   * Restores Daily Notes settings from backup.
   */
  async restoreDailyNotesSettings() {
    var _a, _b, _c, _d;
    const backup = this.settings.dailyNotesIntegration.backup;
    if (!backup) {
      this.errorHandler.showNotice("\u274C No backup found to restore");
      return;
    }
    try {
      if (backup.pluginType === "core") {
        const dailyNotesPlugin = (_b = (_a = this.app.internalPlugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["daily-notes"];
        if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
          Object.assign(
            dailyNotesPlugin.instance.options,
            backup.originalSettings
          );
          DebugUtils.log("Restored Core Daily Notes settings from backup");
        }
      } else {
        const communityDailyNotes = (_d = (_c = this.app.plugins) == null ? void 0 : _c.plugins) == null ? void 0 : _d["daily-notes"];
        if (communityDailyNotes) {
          Object.assign(communityDailyNotes.settings, backup.originalSettings);
          await communityDailyNotes.saveSettings();
          DebugUtils.log("Restored Community Daily Notes settings from backup");
        }
      }
      this.settings.dailyNotesIntegration.enabled = false;
      this.settings.dailyNotesIntegration.backup = null;
      await this.saveSettings();
      this.errorHandler.showNotice(
        "\u2705 Daily Notes settings restored from backup"
      );
    } catch (error) {
      this.errorHandler.handleError(
        error,
        "Failed to restore Daily Notes settings"
      );
    }
  }
  /**
   * Algorithm 9: Cleanup
   * Cleans up managers and UI elements on plugin unload.
   */
  onunload() {
    DebugUtils.log("Obsidian Link Journal unloaded");
    if (this.ribbonManager) {
      this.ribbonManager.cleanup();
    }
  }
};
