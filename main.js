/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinkPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/constants.ts
var DEFAULT_BASE_FOLDER = "LinkPlugin";
var DEFAULT_DIRECTORIES = [
  "journal",
  "templates",
  "workspace",
  "reference"
];
var OPTIONAL_DIRECTORIES = [
  "context",
  "schema",
  "Projects"
];
var COMMAND_IDS = {
  CREATE_LINKED_NOTE: "create-linked-note",
  REBUILD_DIRECTORY: "rebuild-directory-structure",
  OPEN_TODAY_JOURNAL: "open-today-journal",
  CREATE_TODAY_NOTE: "create-today-note",
  CREATE_FUTURE_NOTE: "create-future-note",
  CREATE_MONTHLY_FOLDERS: "create-monthly-folders",
  EXPAND_SHORTCODE: "expand-shortcode",
  SHOW_LINK_SUGGESTIONS: "show-link-suggestions"
};
var DATE_FORMATS = {
  DEFAULT_JOURNAL: "YYYY-MM-DD dddd",
  ISO_DATE: "YYYY-MM-DD",
  FOLDER_FORMAT: "YYYY/MM"
};
var DEFAULT_TEMPLATES = {
  JOURNAL: `# {{date}}

## Daily Log

## Tasks
- [ ] 

## Notes

## Reflection

---
Previous: {{previous}}
Next: {{next}}
`,
  NOTE: `---
title: {{title}}
created: {{date}}
source: {{source}}
tags: []
---

# {{title}}

`
};
var REGEX_PATTERNS = {
  WIKI_LINK: /\[\[(.*?)\]\]/g,
  SHORTCODE: /[\w>+*{}\[\]()]+$/,
  DATE_FILENAME: /\d{4}-\d{2}-\d{2}/,
  INVALID_FILENAME_CHARS: /[\\/:*?"<>|]/g
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  // Directory structure settings
  baseFolder: DEFAULT_BASE_FOLDER,
  // Creates all directories under 'LinkPlugin/' by default
  directoryStructure: DEFAULT_DIRECTORIES,
  restrictedDirectories: [],
  documentDirectory: "workspace",
  // Updated to match README structure
  journalRootFolder: "journal",
  // Updated to match README structure
  // Journal settings
  journalDateFormat: DATE_FORMATS.DEFAULT_JOURNAL,
  journalFolderFormat: DATE_FORMATS.FOLDER_FORMAT,
  journalTemplate: DEFAULT_TEMPLATES.JOURNAL,
  // Note creation settings
  noteTemplate: DEFAULT_TEMPLATES.NOTE,
  openNewNote: true,
  // Shortcode settings
  shortcodeEnabled: true,
  shortcodeTriggerKey: "Tab",
  customShortcodes: {},
  // Other settings
  debugMode: false
};
function validateSettings(settings) {
  const validatedSettings = { ...DEFAULT_SETTINGS };
  if (settings.baseFolder && typeof settings.baseFolder === "string") {
    validatedSettings.baseFolder = settings.baseFolder.trim();
  }
  if (settings.directoryStructure && Array.isArray(settings.directoryStructure)) {
    validatedSettings.directoryStructure = settings.directoryStructure;
  }
  if (settings.restrictedDirectories && Array.isArray(settings.restrictedDirectories)) {
    validatedSettings.restrictedDirectories = settings.restrictedDirectories;
  }
  if (settings.documentDirectory && typeof settings.documentDirectory === "string") {
    validatedSettings.documentDirectory = settings.documentDirectory;
  }
  if (settings.journalRootFolder && typeof settings.journalRootFolder === "string") {
    validatedSettings.journalRootFolder = settings.journalRootFolder;
  }
  if (settings.journalDateFormat && typeof settings.journalDateFormat === "string") {
    validatedSettings.journalDateFormat = settings.journalDateFormat;
  }
  if (settings.journalFolderFormat && typeof settings.journalFolderFormat === "string") {
    validatedSettings.journalFolderFormat = settings.journalFolderFormat;
  }
  if (settings.journalTemplate && typeof settings.journalTemplate === "string") {
    validatedSettings.journalTemplate = settings.journalTemplate;
  }
  if (settings.noteTemplate && typeof settings.noteTemplate === "string") {
    validatedSettings.noteTemplate = settings.noteTemplate;
  }
  if (typeof settings.openNewNote === "boolean") {
    validatedSettings.openNewNote = settings.openNewNote;
  }
  if (typeof settings.shortcodeEnabled === "boolean") {
    validatedSettings.shortcodeEnabled = settings.shortcodeEnabled;
  }
  if (settings.shortcodeTriggerKey && typeof settings.shortcodeTriggerKey === "string") {
    validatedSettings.shortcodeTriggerKey = settings.shortcodeTriggerKey;
  }
  if (settings.customShortcodes && typeof settings.customShortcodes === "object") {
    validatedSettings.customShortcodes = settings.customShortcodes;
  }
  if (typeof settings.debugMode === "boolean") {
    validatedSettings.debugMode = settings.debugMode;
  }
  return validatedSettings;
}

// src/ui/settingsTab.ts
var import_obsidian = require("obsidian");
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Link Plugin Settings" });
    new import_obsidian.Setting(containerEl).setName("Debug Mode").setDesc("Enable debug logging").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/managers/directoryManager.ts
var import_obsidian3 = require("obsidian");

// src/utils/pathUtils.ts
var import_obsidian2 = require("obsidian");
var PathUtils = class {
  static sanitizePath(path) {
    return (0, import_obsidian2.normalizePath)(path.replace(/[\/:*?"<>|]/g, "").trim());
  }
  static joinPath(...segments) {
    return (0, import_obsidian2.normalizePath)(segments.filter(Boolean).join("/"));
  }
};

// src/managers/directoryManager.ts
var DirectoryManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates the base directory structure according to settings
   * All directories are created under the configured baseFolder to prevent collisions
   */
  async rebuildDirectoryStructure() {
    const { vault } = this.plugin.app;
    const { baseFolder, directoryStructure } = this.plugin.settings;
    try {
      const basePath = (0, import_obsidian3.normalizePath)(baseFolder);
      await this.getOrCreateDirectory(basePath);
      console.log(`Created base directory: ${basePath}`);
      for (const dirName of directoryStructure || DEFAULT_DIRECTORIES) {
        const dirPath = PathUtils.joinPath(basePath, dirName);
        await this.getOrCreateDirectory(dirPath);
        console.log(`Created directory: ${dirPath}`);
      }
      await this.createJournalStructure(basePath);
      await this.createReferenceStructure(basePath);
    } catch (error) {
      throw new Error(`Failed to rebuild directory structure: ${error}`);
    }
  }
  /**
   * Creates the detailed journal structure as specified in README
   */
  async createJournalStructure(basePath) {
    const journalPath = PathUtils.joinPath(basePath, "journal");
    const journalSubdirs = [
      "Misc",
      "y_2025/January",
      "y_2025/February",
      "y_2025/March",
      "y_2025/April",
      "y_2025/May",
      "y_2025/June",
      "y_2025/Misc",
      "y_2025/Yearly List",
      "y_2025/Yearly Log",
      "z_Archives/y_2022",
      "z_Archives/y_2023",
      "z_Archives/y_2024"
    ];
    for (const subdir of journalSubdirs) {
      const fullPath = PathUtils.joinPath(journalPath, subdir);
      await this.getOrCreateDirectory(fullPath);
      console.log(`Created journal directory: ${fullPath}`);
    }
  }
  /**
   * Creates the reference file structure as specified in README
   */
  async createReferenceStructure(basePath) {
    const referencePath = PathUtils.joinPath(basePath, "reference");
    const fileTypes = ["images", "pdfs", "videos", "audio", "docs", "other"];
    for (const fileType of fileTypes) {
      const filePath = PathUtils.joinPath(referencePath, "files", fileType);
      await this.getOrCreateDirectory(filePath);
      console.log(`Created reference directory: ${filePath}`);
    }
  }
  /**
   * Creates optional complex structure directories
   */
  async createOptionalStructure(basePath) {
    for (const dirName of OPTIONAL_DIRECTORIES) {
      const dirPath = PathUtils.joinPath(basePath, dirName);
      await this.getOrCreateDirectory(dirPath);
      console.log(`Created optional directory: ${dirPath}`);
    }
  }
  /**
   * Gets a directory path, creating it if it doesn't exist
   * Handles both absolute paths and paths relative to the base folder
   */
  async getOrCreateDirectory(path) {
    const { vault } = this.plugin.app;
    const normalizedPath = (0, import_obsidian3.normalizePath)(path);
    const existingFolder = vault.getAbstractFileByPath(normalizedPath);
    if (existingFolder instanceof import_obsidian3.TFolder) {
      return existingFolder;
    }
    const pathParts = normalizedPath.split("/");
    let currentPath = "";
    for (const part of pathParts) {
      if (!part)
        continue;
      currentPath += (currentPath ? "/" : "") + part;
      const folder = vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await vault.createFolder(currentPath);
      } else if (!(folder instanceof import_obsidian3.TFolder)) {
        throw new Error(`Path ${currentPath} exists but is not a folder`);
      }
    }
    return vault.getAbstractFileByPath(normalizedPath);
  }
  /**
   * Gets the full path for a directory within the plugin's base folder
   */
  getPluginDirectoryPath(relativePath) {
    const { baseFolder } = this.plugin.settings;
    return PathUtils.joinPath(baseFolder, relativePath);
  }
  /**
   * Gets the journal directory path
   */
  getJournalPath() {
    const { baseFolder, journalRootFolder } = this.plugin.settings;
    return PathUtils.joinPath(baseFolder, journalRootFolder);
  }
  /**
   * Gets the workspace directory path  
   */
  getWorkspacePath() {
    const { baseFolder, documentDirectory } = this.plugin.settings;
    return PathUtils.joinPath(baseFolder, documentDirectory);
  }
  /**
   * Applies a directory template to create structured folders
   */
  async applyDirectoryTemplate(basePath, template) {
    for (const [key, value] of Object.entries(template)) {
      const dirPath = PathUtils.joinPath(basePath, key);
      await this.getOrCreateDirectory(dirPath);
      if (value && typeof value === "object") {
        await this.applyDirectoryTemplate(dirPath, value);
      }
    }
  }
  /**
   * Validates if a given path is within allowed directories
   */
  isValidPath(path) {
    const normalizedPath = (0, import_obsidian3.normalizePath)(path);
    const { restrictedDirectories } = this.plugin.settings;
    if (!restrictedDirectories || restrictedDirectories.length === 0) {
      return true;
    }
    return !restrictedDirectories.some((dir) => {
      const normalizedDir = (0, import_obsidian3.normalizePath)(dir);
      return normalizedPath === normalizedDir || normalizedPath.startsWith(normalizedDir + "/");
    });
  }
  /**
   * Lists all directories in the vault
   */
  getAllDirectories() {
    const { vault } = this.plugin.app;
    return vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian3.TFolder);
  }
  /**
   * Creates a directory with a specific template structure within the plugin's base folder
   */
  async createProjectDirectory(name, template) {
    const sanitizedName = PathUtils.sanitizePath(name);
    const workspacePath = this.getWorkspacePath();
    const projectPath = PathUtils.joinPath(workspacePath, sanitizedName);
    const projectFolder = await this.getOrCreateDirectory(projectPath);
    if (template) {
      await this.applyDirectoryTemplate(projectPath, template);
    }
    return projectFolder;
  }
};

// src/managers/journalManager.ts
var import_obsidian5 = require("obsidian");

// src/utils/dateUtils.ts
var import_obsidian4 = require("obsidian");
var DateUtils = class {
  static extractDateFromFilename(filename, format) {
    try {
      const date = (0, import_obsidian4.moment)(filename, format, true);
      return date.isValid() ? date : null;
    } catch (error) {
      return null;
    }
  }
  static formatDate(date, format = "YYYY-MM-DD") {
    const m = date instanceof Date ? (0, import_obsidian4.moment)(date) : date;
    return m.format(format);
  }
  static getJournalPath(date, baseFolder, journalFolder, dateFormat) {
    const m = date instanceof Date ? (0, import_obsidian4.moment)(date) : date;
    const year = m.format("YYYY");
    const monthName = m.format("MMMM");
    const fileName = m.format(dateFormat || "YYYY-MM-DD dddd");
    return `${baseFolder}/${journalFolder}/y_${year}/${monthName}/${fileName}.md`;
  }
  static getCurrentMonth() {
    return (0, import_obsidian4.moment)().format("MMMM");
  }
  static getCurrentYear() {
    return (0, import_obsidian4.moment)().format("YYYY");
  }
  static getMonthlyFolderName(date) {
    const m = date instanceof Date ? (0, import_obsidian4.moment)(date) : date;
    return `y_${m.format("YYYY")}/${m.format("MMMM")}`;
  }
};

// src/managers/journalManager.ts
var JournalManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Creates or opens a journal entry for the specified date
   * Automatically creates monthly folders as needed
   */
  async createOrOpenJournalEntry(date) {
    const { vault } = this.plugin.app;
    const { journalDateFormat, journalTemplate } = this.plugin.settings;
    await this.ensureMonthlyFolderExists(date);
    const monthlyFolderPath = this.getMonthlyFolderPath(date);
    const fileName = date.format(journalDateFormat || "YYYY-MM-DD dddd");
    const filePath = (0, import_obsidian5.normalizePath)(`${monthlyFolderPath}/${fileName}.md`);
    let file = vault.getAbstractFileByPath(filePath);
    if (!file) {
      const content = await this.generateJournalContent(date);
      file = await vault.create(filePath, content);
      console.log(`Created daily note: ${filePath}`);
    }
    return file;
  }
  /**
   * Ensures the monthly folder exists for the given date
   * Creates the folder structure if it doesn't exist
   */
  async ensureMonthlyFolderExists(date) {
    const monthlyFolderPath = this.getMonthlyFolderPath(date);
    await this.plugin.directoryManager.getOrCreateDirectory(monthlyFolderPath);
    console.log(`Ensured monthly folder exists: ${monthlyFolderPath}`);
  }
  /**
   * Gets the monthly folder path for a given date
   * Uses the new base folder structure: LinkPlugin/journal/y_YYYY/MonthName/
   */
  getMonthlyFolderPath(date) {
    const journalBasePath = this.plugin.directoryManager.getJournalPath();
    const year = date.format("YYYY");
    const monthName = date.format("MMMM");
    return `${journalBasePath}/y_${year}/${monthName}`;
  }
  /**
   * Creates a daily note for today if it doesn't exist
   * Automatically handles monthly folder creation
   */
  async createTodayNote() {
    const today = (0, import_obsidian5.moment)();
    return await this.createOrOpenJournalEntry(today);
  }
  /**
   * Creates a daily note for a future date
   * Automatically creates monthly folders as needed
   */
  async createFutureDailyNote(date) {
    const targetDate = typeof date === "string" ? (0, import_obsidian5.moment)(date) : (0, import_obsidian5.moment)(date);
    return await this.createOrOpenJournalEntry(targetDate);
  }
  /**
   * Generate content for a journal entry
   */
  async generateJournalContent(date) {
    const { journalTemplate, journalDateFormat } = this.plugin.settings;
    const previousDay = (0, import_obsidian5.moment)(date).subtract(1, "day");
    const nextDay = (0, import_obsidian5.moment)(date).add(1, "day");
    const previousLink = `[[${previousDay.format(journalDateFormat || "YYYY-MM-DD dddd")}]]`;
    const nextLink = `[[${nextDay.format(journalDateFormat || "YYYY-MM-DD dddd")}]]`;
    const currentDate = date.format("YYYY-MM-DD");
    const title = date.format(journalDateFormat || "YYYY-MM-DD dddd");
    if (journalTemplate) {
      return journalTemplate.replace(/{{date}}/g, currentDate).replace(/{{title}}/g, title).replace(/{{previous}}/g, previousLink).replace(/{{next}}/g, nextLink);
    }
    return `---
date: ${currentDate}
previous: ${previousLink}
next: ${nextLink}
tags:
  - journal
---

# ${title}

## Daily Log

## Tasks
- [ ] 

## Notes

## Reflection

---
Previous: ${previousLink} | Next: ${nextLink}
`;
  }
  /**
   * Opens the journal entry for today
   * Creates monthly folder and daily note if they don't exist
   */
  async openTodayJournal() {
    const today = (0, import_obsidian5.moment)();
    const file = await this.createOrOpenJournalEntry(today);
    const leaf = this.plugin.app.workspace.getLeaf();
    await leaf.openFile(file);
  }
  /**
   * Checks if we need to create a new monthly folder
   * Called when the plugin loads or when creating notes
   */
  async checkAndCreateCurrentMonthFolder() {
    const currentDate = (0, import_obsidian5.moment)();
    await this.ensureMonthlyFolderExists(currentDate);
  }
  /**
   * Creates monthly folders for a range of dates
   * Useful for batch creation or setup
   */
  async createMonthlyFoldersForRange(startDate, endDate) {
    const current = (0, import_obsidian5.moment)(startDate).startOf("month");
    const end = (0, import_obsidian5.moment)(endDate).endOf("month");
    while (current.isSameOrBefore(end)) {
      await this.ensureMonthlyFolderExists(current);
      current.add(1, "month");
    }
  }
  /**
   * Opens journal entry for a specific date
   */
  async openJournalForDate(date) {
    const momentDate = typeof date === "string" ? (0, import_obsidian5.moment)(date) : (0, import_obsidian5.moment)(date);
    const file = await this.createOrOpenJournalEntry(momentDate);
    const leaf = this.plugin.app.workspace.getLeaf();
    await leaf.openFile(file);
  }
  /**
   * Updates links between journal entries
   */
  async updateJournalLinks(file) {
    const { vault } = this.plugin.app;
    const { journalDateFormat } = this.plugin.settings;
    const fileDate = DateUtils.extractDateFromFilename(file.basename, journalDateFormat);
    if (!fileDate)
      return;
    const content = await vault.read(file);
    const previousDay = (0, import_obsidian5.moment)(fileDate).subtract(1, "day");
    const nextDay = (0, import_obsidian5.moment)(fileDate).add(1, "day");
    const previousFileName = previousDay.format(journalDateFormat || "YYYY-MM-DD dddd");
    const nextFileName = nextDay.format(journalDateFormat || "YYYY-MM-DD dddd");
    const updatedContent = content.replace(/previous: '\[\[(.*?)\]\]'/g, `previous: '[[${previousFileName}]]'`).replace(/next: '\[\[(.*?)\]\]'/g, `next: '[[${nextFileName}]]'`);
    if (content !== updatedContent) {
      await vault.modify(file, updatedContent);
    }
  }
  /**
   * Get all journal entries in a date range
   */
  async getJournalEntries(startDate, endDate) {
    const { vault } = this.plugin.app;
    const entries = [];
    const current = (0, import_obsidian5.moment)(startDate);
    while (current.isSameOrBefore(endDate)) {
      const entryPath = DateUtils.getJournalPath(
        current,
        this.plugin.settings.journalRootFolder,
        this.plugin.settings.journalFolderFormat,
        this.plugin.settings.journalDateFormat
      );
      const file = vault.getAbstractFileByPath(entryPath);
      if (file) {
        entries.push({
          date: current.format("YYYY-MM-DD"),
          path: file.path,
          title: file.basename,
          previous: (0, import_obsidian5.moment)(current).subtract(1, "day").format("YYYY-MM-DD"),
          next: (0, import_obsidian5.moment)(current).add(1, "day").format("YYYY-MM-DD")
        });
      }
      current.add(1, "day");
    }
    return entries;
  }
};

// src/managers/linkManager.ts
var import_obsidian6 = require("obsidian");
var LinkManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Create a new note from selected text and link to it
   */
  async createLinkedNote(selection, editor, view) {
    const { vault } = this.plugin.app;
    const currentFile = view.file;
    if (!currentFile) {
      throw new Error("No active file found");
    }
    const fileName = this.sanitizeFileName(selection);
    const directoryPath = this.determineTargetDirectory(fileName);
    const filePath = (0, import_obsidian6.normalizePath)(`${directoryPath}/${fileName}.md`);
    let file = vault.getAbstractFileByPath(filePath);
    if (!file) {
      await this.plugin.directoryManager.getOrCreateDirectory(directoryPath);
      const content = this.generateNoteContent(selection, currentFile);
      file = await vault.create(filePath, content);
    }
    editor.replaceSelection(`[[${fileName}]]`);
    if (this.plugin.settings.openNewNote) {
      const leaf = this.plugin.app.workspace.splitActiveLeaf();
      await leaf.openFile(file);
    }
  }
  /**
   * Determine the appropriate directory for a new note
   */
  determineTargetDirectory(title) {
    const { documentDirectory } = this.plugin.settings;
    const keywords = title.toLowerCase();
    if (keywords.includes("project") || keywords.includes("work")) {
      return "Workspace";
    } else if (keywords.includes("reference") || keywords.includes("definition")) {
      return "References";
    } else if (keywords.includes("template")) {
      return "Templates";
    }
    return documentDirectory || "Documents";
  }
  /**
   * Generate content for a new linked note
   */
  generateNoteContent(title, sourceFile) {
    const { noteTemplate } = this.plugin.settings;
    const currentDate = new Date().toISOString().split("T")[0];
    if (noteTemplate) {
      return noteTemplate.replace(/{{title}}/g, title).replace(/{{date}}/g, currentDate).replace(/{{source}}/g, `[[${sourceFile.basename}]]`);
    }
    return `---
title: ${title}
created: ${currentDate}
source: [[${sourceFile.basename}]]
tags: []
---

# ${title}

`;
  }
  /**
   * Sanitize a string for use as a filename
   */
  sanitizeFileName(input) {
    return input.replace(REGEX_PATTERNS.INVALID_FILENAME_CHARS, "").replace(/\s+/g, " ").trim().substring(0, 100);
  }
  /**
   * Find all links in a file
   */
  async findLinksInFile(file) {
    const { vault } = this.plugin.app;
    const content = await vault.read(file);
    const links = [];
    let match;
    while ((match = REGEX_PATTERNS.WIKI_LINK.exec(content)) !== null) {
      links.push(match[1]);
    }
    return links;
  }
  /**
   * Find all backlinks to a file
   */
  async findBacklinks(file) {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const backlinks = [];
    for (const potentialSource of files) {
      if (potentialSource.path === file.path)
        continue;
      const links = await this.findLinksInFile(potentialSource);
      if (links.includes(file.basename)) {
        backlinks.push(potentialSource);
      }
    }
    return backlinks;
  }
  /**
   * Find broken links in the vault
   */
  async findBrokenLinks() {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const brokenLinksData = [];
    for (const file of files) {
      const links = await this.findLinksInFile(file);
      const brokenLinks = [];
      for (const link of links) {
        const linkedFile = vault.getAbstractFileByPath(`${link}.md`) || vault.getAbstractFileByPath(link);
        if (!linkedFile) {
          brokenLinks.push(link);
        }
      }
      if (brokenLinks.length > 0) {
        brokenLinksData.push({ file, brokenLinks });
      }
    }
    return brokenLinksData;
  }
  /**
   * Find orphaned notes (notes with no backlinks)
   */
  async findOrphanedNotes() {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const orphanedNotes = [];
    for (const file of files) {
      const backlinks = await this.findBacklinks(file);
      if (backlinks.length === 0) {
        orphanedNotes.push(file);
      }
    }
    return orphanedNotes;
  }
  /**
   * Generate link suggestions based on content similarity
   */
  async generateLinkSuggestions(file, limit = 5) {
    const { vault } = this.plugin.app;
    const files = vault.getMarkdownFiles();
    const suggestions = [];
    const currentContent = await vault.read(file);
    const currentWords = this.extractWords(currentContent);
    for (const otherFile of files) {
      if (otherFile.path === file.path)
        continue;
      const otherContent = await vault.read(otherFile);
      const otherWords = this.extractWords(otherContent);
      const relevance = this.calculateRelevance(currentWords, otherWords);
      if (relevance > 0.1) {
        suggestions.push({
          title: otherFile.basename,
          path: otherFile.path,
          relevance,
          type: "existing"
        });
      }
    }
    return suggestions.sort((a, b) => b.relevance - a.relevance).slice(0, limit);
  }
  /**
   * Extract meaningful words from content
   */
  extractWords(content) {
    const words = /* @__PURE__ */ new Set();
    const text = content.replace(/[#*`\[\]()]/g, "").toLowerCase().split(/\s+/);
    for (const word of text) {
      if (word.length > 3 && !this.isStopWord(word)) {
        words.add(word);
      }
    }
    return words;
  }
  /**
   * Calculate relevance between two sets of words
   */
  calculateRelevance(words1, words2) {
    const intersection = new Set([...words1].filter((word) => words2.has(word)));
    const union = /* @__PURE__ */ new Set([...words1, ...words2]);
    return intersection.size / union.size;
  }
  /**
   * Check if a word is a stop word
   */
  isStopWord(word) {
    const stopWords = /* @__PURE__ */ new Set([
      "the",
      "a",
      "an",
      "and",
      "or",
      "but",
      "in",
      "on",
      "at",
      "to",
      "for",
      "of",
      "with",
      "by",
      "is",
      "are",
      "was",
      "were",
      "be",
      "been",
      "have",
      "has",
      "had",
      "do",
      "does",
      "did",
      "will",
      "would",
      "could",
      "should",
      "may",
      "might",
      "must",
      "can",
      "this",
      "that",
      "these",
      "those"
    ]);
    return stopWords.has(word);
  }
};

// src/shortcodes/tokenizer.ts
var Tokenizer = class {
  /**
   * Tokenize an Emmet-like shortcode string
   */
  tokenize(input) {
    const tokens = [];
    let currentPos = 0;
    while (currentPos < input.length) {
      const char = input[currentPos];
      if (this.isNameChar(char)) {
        const { token, newPos } = this.tokenizeElement(input, currentPos);
        tokens.push(token);
        currentPos = newPos;
        continue;
      }
      if (this.isOperator(char)) {
        tokens.push({
          type: "operator",
          value: char
        });
        currentPos++;
        continue;
      }
      if (char === "{") {
        const { token, newPos } = this.tokenizeContent(input, currentPos);
        tokens.push(token);
        currentPos = newPos;
        continue;
      }
      if (char === "[") {
        const { token, newPos } = this.tokenizeAttribute(input, currentPos);
        tokens.push(token);
        currentPos = newPos;
        continue;
      }
      if (char === "(") {
        const { token, newPos } = this.tokenizeGroup(input, currentPos);
        tokens.push(token);
        currentPos = newPos;
        continue;
      }
      if (char === " " || char === "	" || char === "\n") {
        currentPos++;
        continue;
      }
      throw new Error(`Unexpected character: ${char} at position ${currentPos}`);
    }
    return tokens;
  }
  tokenizeElement(input, startPos) {
    let endPos = startPos;
    while (endPos < input.length && this.isNameChar(input[endPos])) {
      endPos++;
    }
    if (endPos < input.length && input[endPos] === "*") {
      const elementName = input.substring(startPos, endPos);
      endPos++;
      const numberStartPos = endPos;
      while (endPos < input.length && /\d/.test(input[endPos])) {
        endPos++;
      }
      const multiplier = parseInt(input.substring(numberStartPos, endPos), 10);
      return {
        token: {
          type: "element",
          value: elementName,
          children: [{
            type: "multiplier",
            value: multiplier.toString()
          }]
        },
        newPos: endPos
      };
    }
    return {
      token: {
        type: "element",
        value: input.substring(startPos, endPos)
      },
      newPos: endPos
    };
  }
  tokenizeContent(input, startPos) {
    let endPos = startPos + 1;
    let depth = 1;
    while (endPos < input.length && depth > 0) {
      if (input[endPos] === "{")
        depth++;
      if (input[endPos] === "}")
        depth--;
      endPos++;
    }
    if (depth !== 0) {
      throw new Error("Unclosed content braces");
    }
    return {
      token: {
        type: "content",
        value: input.substring(startPos + 1, endPos - 1)
      },
      newPos: endPos
    };
  }
  tokenizeAttribute(input, startPos) {
    let endPos = startPos + 1;
    let depth = 1;
    while (endPos < input.length && depth > 0) {
      if (input[endPos] === "[")
        depth++;
      if (input[endPos] === "]")
        depth--;
      endPos++;
    }
    if (depth !== 0) {
      throw new Error("Unclosed attribute brackets");
    }
    return {
      token: {
        type: "attribute",
        value: input.substring(startPos + 1, endPos - 1)
      },
      newPos: endPos
    };
  }
  tokenizeGroup(input, startPos) {
    let endPos = startPos + 1;
    let depth = 1;
    while (endPos < input.length && depth > 0) {
      if (input[endPos] === "(")
        depth++;
      if (input[endPos] === ")")
        depth--;
      endPos++;
    }
    if (depth !== 0) {
      throw new Error("Unclosed group parentheses");
    }
    const groupContent = input.substring(startPos + 1, endPos - 1);
    const childTokens = new Tokenizer().tokenize(groupContent);
    return {
      token: {
        type: "group",
        value: groupContent,
        children: childTokens
      },
      newPos: endPos
    };
  }
  isNameChar(char) {
    return /[a-zA-Z0-9_-]/.test(char);
  }
  isOperator(char) {
    return char === ">" || char === "+" || char === "*";
  }
};

// src/shortcodes/parser.ts
var Parser = class {
  /**
   * Parse tokens into an Abstract Syntax Tree
   */
  parse(tokens) {
    const ast = [];
    let currentNode = null;
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      switch (token.type) {
        case "element":
          currentNode = {
            type: "element",
            name: token.value,
            children: []
          };
          if (token.children && token.children.length > 0) {
            const multiplier = token.children.find((child) => child.type === "multiplier");
            if (multiplier) {
              currentNode.repeat = parseInt(multiplier.value, 10);
            }
          }
          ast.push(currentNode);
          break;
        case "content":
          if (currentNode) {
            currentNode.content = token.value;
          }
          break;
        case "attribute":
          if (currentNode) {
            currentNode.attributes = this.parseAttributes(token.value);
          }
          break;
        case "operator":
          if (token.value === ">" && i + 1 < tokens.length) {
            const childTokens = [tokens[++i]];
            const childNodes = this.parse(childTokens);
            if (currentNode && childNodes.length > 0) {
              currentNode.children = currentNode.children || [];
              currentNode.children.push(...childNodes);
              childNodes.forEach((child) => child.parent = currentNode.name);
            }
          } else if (token.value === "+") {
            continue;
          }
          break;
        case "group":
          if (token.children) {
            const groupNodes = this.parse(token.children);
            ast.push(...groupNodes);
          }
          break;
      }
    }
    return ast;
  }
  parseAttributes(attrString) {
    const attributes = {};
    if (attrString.includes("=")) {
      const pairs = attrString.split(/\s+/);
      for (const pair of pairs) {
        const [key, value] = pair.split("=");
        if (key && value) {
          attributes[key] = value.replace(/["']/g, "");
        }
      }
    } else {
      attributes.value = attrString;
    }
    return attributes;
  }
  /**
   * Validate the AST structure
   */
  validate(ast) {
    for (const node of ast) {
      if (!node.name && node.type === "element") {
        return false;
      }
      if (node.children && node.children.length > 0) {
        if (!this.validate(node.children)) {
          return false;
        }
      }
    }
    return true;
  }
};

// src/shortcodes/transformer.ts
var Transformer = class {
  transform(ast) {
    return ast.map((node) => node.content || "").join("\n");
  }
};

// src/shortcodes/registry.ts
var ShortcodeManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.tokenizer = new Tokenizer();
    this.parser = new Parser();
    this.transformer = new Transformer();
  }
  checkForShortcodes(editor) {
  }
  showHelpModal() {
  }
};

// src/utils/errorHandler.ts
var import_obsidian7 = require("obsidian");
var ErrorHandler = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  handleError(error, context) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`${context}: ${message}`);
    new import_obsidian7.Notice(`${context}: ${message}`);
  }
  showNotice(message, duration) {
    new import_obsidian7.Notice(message, duration);
  }
  showSuccess(message) {
    new import_obsidian7.Notice(message, 3e3);
  }
  showWarning(message) {
    new import_obsidian7.Notice(`\u26A0\uFE0F ${message}`, 5e3);
  }
};

// src/main.ts
var LinkPlugin = class extends import_obsidian8.Plugin {
  async onload() {
    console.log("Loading Link Plugin...");
    try {
      await this.loadSettings();
      this.errorHandler = new ErrorHandler(this);
      this.directoryManager = new DirectoryManager(this);
      this.journalManager = new JournalManager(this);
      this.linkManager = new LinkManager(this);
      this.shortcodeManager = new ShortcodeManager(this);
      this.addSettingTab(new SettingsTab(this.app, this));
      this.registerCommands();
      this.registerEventHandlers();
      await this.directoryManager.rebuildDirectoryStructure();
      await this.journalManager.checkAndCreateCurrentMonthFolder();
      console.log("Link Plugin loaded successfully");
    } catch (error) {
      console.error("Failed to load Link Plugin:", error);
      if (this.errorHandler) {
        this.errorHandler.handleError(error, "Plugin initialization failed");
      }
    }
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = validateSettings(loadedData || {});
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  registerCommands() {
    this.addCommand({
      id: COMMAND_IDS.CREATE_LINKED_NOTE,
      name: "Create Linked Note from Selection",
      editorCallback: (editor, view) => {
        try {
          const selection = editor.getSelection();
          if (selection) {
            this.linkManager.createLinkedNote(selection, editor, view);
          } else {
            this.errorHandler.handleError(new Error("No text selected"), "Please select text to create a linked note");
          }
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create linked note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.REBUILD_DIRECTORY,
      name: "Rebuild Directory Structure",
      callback: () => {
        try {
          this.directoryManager.rebuildDirectoryStructure();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to rebuild directory structure");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.OPEN_TODAY_JOURNAL,
      name: "Open Today's Journal",
      callback: () => {
        try {
          this.journalManager.openTodayJournal();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to open today's journal");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_TODAY_NOTE,
      name: "Create Today's Daily Note",
      callback: async () => {
        try {
          const file = await this.journalManager.createTodayNote();
          const leaf = this.app.workspace.getLeaf();
          await leaf.openFile(file);
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create today's note");
        }
      }
    });
    this.addCommand({
      id: COMMAND_IDS.CREATE_MONTHLY_FOLDERS,
      name: "Create Monthly Folders for Current Year",
      callback: async () => {
        try {
          const startOfYear = window.moment().startOf("year");
          const endOfYear = window.moment().endOf("year");
          await this.journalManager.createMonthlyFoldersForRange(startOfYear, endOfYear);
          this.errorHandler.showNotice("Monthly folders created for current year");
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to create monthly folders");
        }
      }
    });
    this.addCommand({
      id: "show-shortcode-help",
      name: "Show Shortcode Help",
      callback: () => {
        try {
          this.shortcodeManager.showHelpModal();
        } catch (error) {
          this.errorHandler.handleError(error, "Failed to show shortcode help");
        }
      }
    });
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.workspace.on("editor-change", (editor) => {
        if (this.settings.shortcodeEnabled) {
          this.shortcodeManager.checkForShortcodes(editor);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file.path.includes(this.settings.journalRootFolder)) {
          this.journalManager.updateJournalLinks(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (this.settings.debugMode) {
          console.log("File modified:", file.path);
        }
      })
    );
  }
  onunload() {
    console.log("Link Plugin unloaded");
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL2NvbnN0YW50cy50cyIsICJzcmMvc2V0dGluZ3MudHMiLCAic3JjL3VpL3NldHRpbmdzVGFiLnRzIiwgInNyYy9tYW5hZ2Vycy9kaXJlY3RvcnlNYW5hZ2VyLnRzIiwgInNyYy91dGlscy9wYXRoVXRpbHMudHMiLCAic3JjL21hbmFnZXJzL2pvdXJuYWxNYW5hZ2VyLnRzIiwgInNyYy91dGlscy9kYXRlVXRpbHMudHMiLCAic3JjL21hbmFnZXJzL2xpbmtNYW5hZ2VyLnRzIiwgInNyYy9zaG9ydGNvZGVzL3Rva2VuaXplci50cyIsICJzcmMvc2hvcnRjb2Rlcy9wYXJzZXIudHMiLCAic3JjL3Nob3J0Y29kZXMvdHJhbnNmb3JtZXIudHMiLCAic3JjL3Nob3J0Y29kZXMvcmVnaXN0cnkudHMiLCAic3JjL3V0aWxzL2Vycm9ySGFuZGxlci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgREVGQVVMVF9TRVRUSU5HUywgTGlua1BsdWdpblNldHRpbmdzLCB2YWxpZGF0ZVNldHRpbmdzIH0gZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyBTZXR0aW5nc1RhYiB9IGZyb20gJy4vdWkvc2V0dGluZ3NUYWInO1xuaW1wb3J0IHsgRGlyZWN0b3J5TWFuYWdlciB9IGZyb20gJy4vbWFuYWdlcnMvZGlyZWN0b3J5TWFuYWdlcic7XG5pbXBvcnQgeyBKb3VybmFsTWFuYWdlciB9IGZyb20gJy4vbWFuYWdlcnMvam91cm5hbE1hbmFnZXInO1xuaW1wb3J0IHsgTGlua01hbmFnZXIgfSBmcm9tICcuL21hbmFnZXJzL2xpbmtNYW5hZ2VyJztcbmltcG9ydCB7IFNob3J0Y29kZU1hbmFnZXIgfSBmcm9tICcuL3Nob3J0Y29kZXMvcmVnaXN0cnknO1xuaW1wb3J0IHsgRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi91dGlscy9lcnJvckhhbmRsZXInO1xuaW1wb3J0IHsgQ09NTUFORF9JRFMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmtQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICBzZXR0aW5nczogTGlua1BsdWdpblNldHRpbmdzO1xuICBkaXJlY3RvcnlNYW5hZ2VyOiBEaXJlY3RvcnlNYW5hZ2VyO1xuICBqb3VybmFsTWFuYWdlcjogSm91cm5hbE1hbmFnZXI7XG4gIGxpbmtNYW5hZ2VyOiBMaW5rTWFuYWdlcjtcbiAgc2hvcnRjb2RlTWFuYWdlcjogU2hvcnRjb2RlTWFuYWdlcjtcbiAgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXI7XG5cbiAgYXN5bmMgb25sb2FkKCkge1xuICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIExpbmsgUGx1Z2luLi4uJyk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gTG9hZCBzZXR0aW5nc1xuICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBlcnJvciBoYW5kbGVyIGZpcnN0XG4gICAgICB0aGlzLmVycm9ySGFuZGxlciA9IG5ldyBFcnJvckhhbmRsZXIodGhpcyk7XG5cbiAgICAgIC8vIEluaXRpYWxpemUgbWFuYWdlcnNcbiAgICAgIHRoaXMuZGlyZWN0b3J5TWFuYWdlciA9IG5ldyBEaXJlY3RvcnlNYW5hZ2VyKHRoaXMpO1xuICAgICAgdGhpcy5qb3VybmFsTWFuYWdlciA9IG5ldyBKb3VybmFsTWFuYWdlcih0aGlzKTtcbiAgICAgIHRoaXMubGlua01hbmFnZXIgPSBuZXcgTGlua01hbmFnZXIodGhpcyk7XG4gICAgICB0aGlzLnNob3J0Y29kZU1hbmFnZXIgPSBuZXcgU2hvcnRjb2RlTWFuYWdlcih0aGlzKTtcblxuICAgICAgLy8gQWRkIHNldHRpbmdzIHRhYlxuICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTZXR0aW5nc1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG4gICAgICAvLyBSZWdpc3RlciBjb21tYW5kc1xuICAgICAgdGhpcy5yZWdpc3RlckNvbW1hbmRzKCk7XG5cbiAgICAgIC8vIFJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG4gICAgICB0aGlzLnJlZ2lzdGVyRXZlbnRIYW5kbGVycygpO1xuXG4gICAgICAvLyBJbml0aWFsaXplIGRpcmVjdG9yeSBzdHJ1Y3R1cmVcbiAgICAgIGF3YWl0IHRoaXMuZGlyZWN0b3J5TWFuYWdlci5yZWJ1aWxkRGlyZWN0b3J5U3RydWN0dXJlKCk7XG5cbiAgICAgIC8vIEVuc3VyZSBjdXJyZW50IG1vbnRoIGZvbGRlciBleGlzdHNcbiAgICAgIGF3YWl0IHRoaXMuam91cm5hbE1hbmFnZXIuY2hlY2tBbmRDcmVhdGVDdXJyZW50TW9udGhGb2xkZXIoKTtcblxuICAgICAgY29uc29sZS5sb2coJ0xpbmsgUGx1Z2luIGxvYWRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgTGluayBQbHVnaW46JywgZXJyb3IpO1xuICAgICAgaWYgKHRoaXMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCAnUGx1Z2luIGluaXRpYWxpemF0aW9uIGZhaWxlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICBjb25zdCBsb2FkZWREYXRhID0gYXdhaXQgdGhpcy5sb2FkRGF0YSgpO1xuICAgIHRoaXMuc2V0dGluZ3MgPSB2YWxpZGF0ZVNldHRpbmdzKGxvYWRlZERhdGEgfHwge30pO1xuICB9XG5cbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gIH1cblxuICByZWdpc3RlckNvbW1hbmRzKCkge1xuICAgIC8vIENyZWF0ZSBsaW5rZWQgbm90ZSBjb21tYW5kXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBDT01NQU5EX0lEUy5DUkVBVEVfTElOS0VEX05PVEUsXG4gICAgICBuYW1lOiAnQ3JlYXRlIExpbmtlZCBOb3RlIGZyb20gU2VsZWN0aW9uJyxcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yLCB2aWV3KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGlua01hbmFnZXIuY3JlYXRlTGlua2VkTm90ZShzZWxlY3Rpb24sIGVkaXRvciwgdmlldyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKG5ldyBFcnJvcignTm8gdGV4dCBzZWxlY3RlZCcpLCAnUGxlYXNlIHNlbGVjdCB0ZXh0IHRvIGNyZWF0ZSBhIGxpbmtlZCBub3RlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCAnRmFpbGVkIHRvIGNyZWF0ZSBsaW5rZWQgbm90ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZWJ1aWxkIGRpcmVjdG9yeSBzdHJ1Y3R1cmUgY29tbWFuZFxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogQ09NTUFORF9JRFMuUkVCVUlMRF9ESVJFQ1RPUlksXG4gICAgICBuYW1lOiAnUmVidWlsZCBEaXJlY3RvcnkgU3RydWN0dXJlJyxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5kaXJlY3RvcnlNYW5hZ2VyLnJlYnVpbGREaXJlY3RvcnlTdHJ1Y3R1cmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgJ0ZhaWxlZCB0byByZWJ1aWxkIGRpcmVjdG9yeSBzdHJ1Y3R1cmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gT3BlbiB0b2RheSdzIGpvdXJuYWwgY29tbWFuZFxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogQ09NTUFORF9JRFMuT1BFTl9UT0RBWV9KT1VSTkFMLFxuICAgICAgbmFtZTogJ09wZW4gVG9kYXlcXCdzIEpvdXJuYWwnLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmpvdXJuYWxNYW5hZ2VyLm9wZW5Ub2RheUpvdXJuYWwoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgJ0ZhaWxlZCB0byBvcGVuIHRvZGF5XFwncyBqb3VybmFsJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSB0b2RheSdzIG5vdGUgY29tbWFuZFxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogQ09NTUFORF9JRFMuQ1JFQVRFX1RPREFZX05PVEUsXG4gICAgICBuYW1lOiAnQ3JlYXRlIFRvZGF5XFwncyBEYWlseSBOb3RlJyxcbiAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHRoaXMuam91cm5hbE1hbmFnZXIuY3JlYXRlVG9kYXlOb3RlKCk7XG4gICAgICAgICAgY29uc3QgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKCk7XG4gICAgICAgICAgYXdhaXQgbGVhZi5vcGVuRmlsZShmaWxlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgJ0ZhaWxlZCB0byBjcmVhdGUgdG9kYXlcXCdzIG5vdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIG1vbnRobHkgZm9sZGVycyBjb21tYW5kXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBDT01NQU5EX0lEUy5DUkVBVEVfTU9OVEhMWV9GT0xERVJTLFxuICAgICAgbmFtZTogJ0NyZWF0ZSBNb250aGx5IEZvbGRlcnMgZm9yIEN1cnJlbnQgWWVhcicsXG4gICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIENyZWF0ZSBmb2xkZXJzIGZvciB0aGUgZW50aXJlIGN1cnJlbnQgeWVhclxuICAgICAgICAgIGNvbnN0IHN0YXJ0T2ZZZWFyID0gKHdpbmRvdyBhcyBhbnkpLm1vbWVudCgpLnN0YXJ0T2YoJ3llYXInKTtcbiAgICAgICAgICBjb25zdCBlbmRPZlllYXIgPSAod2luZG93IGFzIGFueSkubW9tZW50KCkuZW5kT2YoJ3llYXInKTtcbiAgICAgICAgICBcbiAgICAgICAgICBhd2FpdCB0aGlzLmpvdXJuYWxNYW5hZ2VyLmNyZWF0ZU1vbnRobHlGb2xkZXJzRm9yUmFuZ2Uoc3RhcnRPZlllYXIsIGVuZE9mWWVhcik7XG4gICAgICAgICAgXG4gICAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIuc2hvd05vdGljZSgnTW9udGhseSBmb2xkZXJzIGNyZWF0ZWQgZm9yIGN1cnJlbnQgeWVhcicpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCAnRmFpbGVkIHRvIGNyZWF0ZSBtb250aGx5IGZvbGRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2hvdyBzaG9ydGNvZGUgaGVscFxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogJ3Nob3ctc2hvcnRjb2RlLWhlbHAnLFxuICAgICAgbmFtZTogJ1Nob3cgU2hvcnRjb2RlIEhlbHAnLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnNob3J0Y29kZU1hbmFnZXIuc2hvd0hlbHBNb2RhbCgpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCAnRmFpbGVkIHRvIHNob3cgc2hvcnRjb2RlIGhlbHAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmVnaXN0ZXJFdmVudEhhbmRsZXJzKCkge1xuICAgIC8vIExpc3RlbiBmb3IgZWRpdG9yIGNoYW5nZXMgdG8gZGV0ZWN0IHNob3J0Y29kZXNcbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXG4gICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2VkaXRvci1jaGFuZ2UnLCAoZWRpdG9yKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNob3J0Y29kZUVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLnNob3J0Y29kZU1hbmFnZXIuY2hlY2tGb3JTaG9ydGNvZGVzKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIExpc3RlbiBmb3IgZmlsZSBjcmVhdGlvbiB0byB1cGRhdGUgam91cm5hbCBsaW5rc1xuICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgIHRoaXMuYXBwLnZhdWx0Lm9uKCdjcmVhdGUnLCAoZmlsZSkgPT4ge1xuICAgICAgICBpZiAoZmlsZS5wYXRoLmluY2x1ZGVzKHRoaXMuc2V0dGluZ3Muam91cm5hbFJvb3RGb2xkZXIpKSB7XG4gICAgICAgICAgdGhpcy5qb3VybmFsTWFuYWdlci51cGRhdGVKb3VybmFsTGlua3MoZmlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIExpc3RlbiBmb3IgZmlsZSBtb2RpZmljYXRpb25zXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAudmF1bHQub24oJ21vZGlmeScsIChmaWxlKSA9PiB7XG4gICAgICAgIC8vIFVwZGF0ZSBiYWNrbGlua3Mgb3IgcGVyZm9ybSBvdGhlciBvcGVyYXRpb25zXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRlYnVnTW9kZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdGaWxlIG1vZGlmaWVkOicsIGZpbGUucGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG9udW5sb2FkKCkge1xuICAgIGNvbnNvbGUubG9nKCdMaW5rIFBsdWdpbiB1bmxvYWRlZCcpO1xuICB9XG59IiwgIi8vIERlZmF1bHQgYmFzZSBmb2xkZXIgdG8gcHJldmVudCBjb2xsaXNpb24gd2l0aCBleGlzdGluZyB2YXVsdCBzdHJ1Y3R1cmVcbmV4cG9ydCBjb25zdCBERUZBVUxUX0JBU0VfRk9MREVSID0gJ0xpbmtQbHVnaW4nO1xuXG4vLyBVcGRhdGVkIGRpcmVjdG9yeSBzdHJ1Y3R1cmUgYmFzZWQgb24gUkVBRE1FIHNwZWNpZmljYXRpb25zXG5leHBvcnQgY29uc3QgREVGQVVMVF9ESVJFQ1RPUklFUyA9IFtcbiAgJ2pvdXJuYWwnLFxuICAndGVtcGxhdGVzJyxcbiAgJ3dvcmtzcGFjZScsXG4gICdyZWZlcmVuY2UnXG5dO1xuXG4vLyBEZXRhaWxlZCBqb3VybmFsIHN0cnVjdHVyZSBhcyBzaG93biBpbiBSRUFETUVcbmV4cG9ydCBjb25zdCBERUZBVUxUX0pPVVJOQUxfU1RSVUNUVVJFID0ge1xuICAnam91cm5hbCc6IHtcbiAgICAnTWlzYyc6IG51bGwsXG4gICAgJ3lfMjAyNSc6IHtcbiAgICAgICdKYW51YXJ5JzogbnVsbCxcbiAgICAgICdGZWJydWFyeSc6IG51bGwsXG4gICAgICAnTWFyY2gnOiBudWxsLFxuICAgICAgJ0FwcmlsJzogbnVsbCxcbiAgICAgICdNYXknOiBudWxsLFxuICAgICAgJ0p1bmUnOiBudWxsLFxuICAgICAgJ01pc2MnOiBudWxsLFxuICAgICAgJ1llYXJseSBMaXN0JzogbnVsbCxcbiAgICAgICdZZWFybHkgTG9nJzogbnVsbFxuICAgIH0sXG4gICAgJ3pfQXJjaGl2ZXMnOiB7XG4gICAgICAneV8yMDIyJzogbnVsbCxcbiAgICAgICd5XzIwMjMnOiBudWxsLFxuICAgICAgJ3lfMjAyNCc6IG51bGxcbiAgICB9XG4gIH1cbn07XG5cbi8vIFJlZmVyZW5jZSBzdHJ1Y3R1cmUgYXMgc2hvd24gaW4gUkVBRE1FXG5leHBvcnQgY29uc3QgREVGQVVMVF9SRUZFUkVOQ0VfU1RSVUNUVVJFID0ge1xuICAncmVmZXJlbmNlJzoge1xuICAgICdmaWxlcyc6IHtcbiAgICAgICdpbWFnZXMnOiBudWxsLFxuICAgICAgJ3BkZnMnOiBudWxsLFxuICAgICAgJ3ZpZGVvcyc6IG51bGwsXG4gICAgICAnYXVkaW8nOiBudWxsLFxuICAgICAgJ2RvY3MnOiBudWxsLFxuICAgICAgJ290aGVyJzogbnVsbFxuICAgIH1cbiAgfVxufTtcblxuLy8gT3B0aW9uYWwgY29tcGxleCBzdHJ1Y3R1cmUgbWVudGlvbmVkIGluIFJFQURNRVxuZXhwb3J0IGNvbnN0IE9QVElPTkFMX0RJUkVDVE9SSUVTID0gW1xuICAnY29udGV4dCcsXG4gICdzY2hlbWEnLFxuICAnUHJvamVjdHMnXG5dO1xuXG5leHBvcnQgY29uc3QgQ09NTUFORF9JRFMgPSB7XG4gIENSRUFURV9MSU5LRURfTk9URTogJ2NyZWF0ZS1saW5rZWQtbm90ZScsXG4gIFJFQlVJTERfRElSRUNUT1JZOiAncmVidWlsZC1kaXJlY3Rvcnktc3RydWN0dXJlJyxcbiAgT1BFTl9UT0RBWV9KT1VSTkFMOiAnb3Blbi10b2RheS1qb3VybmFsJyxcbiAgQ1JFQVRFX1RPREFZX05PVEU6ICdjcmVhdGUtdG9kYXktbm90ZScsXG4gIENSRUFURV9GVVRVUkVfTk9URTogJ2NyZWF0ZS1mdXR1cmUtbm90ZScsXG4gIENSRUFURV9NT05USExZX0ZPTERFUlM6ICdjcmVhdGUtbW9udGhseS1mb2xkZXJzJyxcbiAgRVhQQU5EX1NIT1JUQ09ERTogJ2V4cGFuZC1zaG9ydGNvZGUnLFxuICBTSE9XX0xJTktfU1VHR0VTVElPTlM6ICdzaG93LWxpbmstc3VnZ2VzdGlvbnMnXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgREFURV9GT1JNQVRTID0ge1xuICBERUZBVUxUX0pPVVJOQUw6ICdZWVlZLU1NLUREIGRkZGQnLFxuICBJU09fREFURTogJ1lZWVktTU0tREQnLFxuICBGT0xERVJfRk9STUFUOiAnWVlZWS9NTSdcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBTSE9SVENPREVfUEFUVEVSTlMgPSB7XG4gIEVMRU1FTlQ6IC9eW2EtekEtWjAtOV8tXSskLyxcbiAgTVVMVElQTElFUjogL15bYS16QS1aMC05Xy1dK1xcKlxcZCskLyxcbiAgQ0hJTEQ6IC8+LyxcbiAgU0lCTElORzogL1xcKy8sXG4gIENPTlRFTlQ6IC9cXHsuKlxcfS8sXG4gIEFUVFJJQlVURTogL1xcWy4qXFxdLyxcbiAgR1JPVVA6IC9cXCguKlxcKS9cbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBFUlJPUl9NRVNTQUdFUyA9IHtcbiAgSU5WQUxJRF9QQVRIOiAnSW52YWxpZCBmaWxlIHBhdGggcHJvdmlkZWQnLFxuICBESVJFQ1RPUllfQ1JFQVRFX0ZBSUxFRDogJ0ZhaWxlZCB0byBjcmVhdGUgZGlyZWN0b3J5JyxcbiAgRklMRV9DUkVBVEVfRkFJTEVEOiAnRmFpbGVkIHRvIGNyZWF0ZSBmaWxlJyxcbiAgU0hPUlRDT0RFX1BBUlNFX0VSUk9SOiAnRmFpbGVkIHRvIHBhcnNlIHNob3J0Y29kZScsXG4gIEpPVVJOQUxfQ1JFQVRFX0VSUk9SOiAnRmFpbGVkIHRvIGNyZWF0ZSBqb3VybmFsIGVudHJ5J1xufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVEVNUExBVEVTID0ge1xuICBKT1VSTkFMOiBgIyB7e2RhdGV9fVxuXG4jIyBEYWlseSBMb2dcblxuIyMgVGFza3Ncbi0gWyBdIFxuXG4jIyBOb3Rlc1xuXG4jIyBSZWZsZWN0aW9uXG5cbi0tLVxuUHJldmlvdXM6IHt7cHJldmlvdXN9fVxuTmV4dDoge3tuZXh0fX1cbmAsXG4gIE5PVEU6IGAtLS1cbnRpdGxlOiB7e3RpdGxlfX1cbmNyZWF0ZWQ6IHt7ZGF0ZX19XG5zb3VyY2U6IHt7c291cmNlfX1cbnRhZ3M6IFtdXG4tLS1cblxuIyB7e3RpdGxlfX1cblxuYFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFJFR0VYX1BBVFRFUk5TID0ge1xuICBXSUtJX0xJTks6IC9cXFtcXFsoLio/KVxcXVxcXS9nLFxuICBTSE9SVENPREU6IC9bXFx3Pisqe31cXFtcXF0oKV0rJC8sXG4gIERBVEVfRklMRU5BTUU6IC9cXGR7NH0tXFxkezJ9LVxcZHsyfS8sXG4gIElOVkFMSURfRklMRU5BTUVfQ0hBUlM6IC9bXFxcXC86Kj9cIjw+fF0vZ1xufSBhcyBjb25zdDsiLCAiaW1wb3J0IHsgTGlua1BsdWdpblNldHRpbmdzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBERUZBVUxUX0RJUkVDVE9SSUVTLCBERUZBVUxUX0JBU0VfRk9MREVSLCBEQVRFX0ZPUk1BVFMsIERFRkFVTFRfVEVNUExBVEVTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogTGlua1BsdWdpblNldHRpbmdzID0ge1xuICAvLyBEaXJlY3Rvcnkgc3RydWN0dXJlIHNldHRpbmdzXG4gIGJhc2VGb2xkZXI6IERFRkFVTFRfQkFTRV9GT0xERVIsIC8vIENyZWF0ZXMgYWxsIGRpcmVjdG9yaWVzIHVuZGVyICdMaW5rUGx1Z2luLycgYnkgZGVmYXVsdFxuICBkaXJlY3RvcnlTdHJ1Y3R1cmU6IERFRkFVTFRfRElSRUNUT1JJRVMsXG4gIHJlc3RyaWN0ZWREaXJlY3RvcmllczogW10sXG4gIGRvY3VtZW50RGlyZWN0b3J5OiAnd29ya3NwYWNlJywgLy8gVXBkYXRlZCB0byBtYXRjaCBSRUFETUUgc3RydWN0dXJlXG4gIGpvdXJuYWxSb290Rm9sZGVyOiAnam91cm5hbCcsIC8vIFVwZGF0ZWQgdG8gbWF0Y2ggUkVBRE1FIHN0cnVjdHVyZVxuXG4gIC8vIEpvdXJuYWwgc2V0dGluZ3NcbiAgam91cm5hbERhdGVGb3JtYXQ6IERBVEVfRk9STUFUUy5ERUZBVUxUX0pPVVJOQUwsXG4gIGpvdXJuYWxGb2xkZXJGb3JtYXQ6IERBVEVfRk9STUFUUy5GT0xERVJfRk9STUFULFxuICBqb3VybmFsVGVtcGxhdGU6IERFRkFVTFRfVEVNUExBVEVTLkpPVVJOQUwsXG5cbiAgLy8gTm90ZSBjcmVhdGlvbiBzZXR0aW5nc1xuICBub3RlVGVtcGxhdGU6IERFRkFVTFRfVEVNUExBVEVTLk5PVEUsXG4gIG9wZW5OZXdOb3RlOiB0cnVlLFxuXG4gIC8vIFNob3J0Y29kZSBzZXR0aW5nc1xuICBzaG9ydGNvZGVFbmFibGVkOiB0cnVlLFxuICBzaG9ydGNvZGVUcmlnZ2VyS2V5OiAnVGFiJyxcbiAgY3VzdG9tU2hvcnRjb2Rlczoge30sXG5cbiAgLy8gT3RoZXIgc2V0dGluZ3NcbiAgZGVidWdNb2RlOiBmYWxzZVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU2V0dGluZ3Moc2V0dGluZ3M6IFBhcnRpYWw8TGlua1BsdWdpblNldHRpbmdzPik6IExpbmtQbHVnaW5TZXR0aW5ncyB7XG4gIGNvbnN0IHZhbGlkYXRlZFNldHRpbmdzID0geyAuLi5ERUZBVUxUX1NFVFRJTkdTIH07XG5cbiAgLy8gVmFsaWRhdGUgYmFzZSBmb2xkZXIgc2V0dGluZ1xuICBpZiAoc2V0dGluZ3MuYmFzZUZvbGRlciAmJiB0eXBlb2Ygc2V0dGluZ3MuYmFzZUZvbGRlciA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWxpZGF0ZWRTZXR0aW5ncy5iYXNlRm9sZGVyID0gc2V0dGluZ3MuYmFzZUZvbGRlci50cmltKCk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBhbmQgbWVyZ2Ugc2V0dGluZ3NcbiAgaWYgKHNldHRpbmdzLmRpcmVjdG9yeVN0cnVjdHVyZSAmJiBBcnJheS5pc0FycmF5KHNldHRpbmdzLmRpcmVjdG9yeVN0cnVjdHVyZSkpIHtcbiAgICB2YWxpZGF0ZWRTZXR0aW5ncy5kaXJlY3RvcnlTdHJ1Y3R1cmUgPSBzZXR0aW5ncy5kaXJlY3RvcnlTdHJ1Y3R1cmU7XG4gIH1cblxuICBpZiAoc2V0dGluZ3MucmVzdHJpY3RlZERpcmVjdG9yaWVzICYmIEFycmF5LmlzQXJyYXkoc2V0dGluZ3MucmVzdHJpY3RlZERpcmVjdG9yaWVzKSkge1xuICAgIHZhbGlkYXRlZFNldHRpbmdzLnJlc3RyaWN0ZWREaXJlY3RvcmllcyA9IHNldHRpbmdzLnJlc3RyaWN0ZWREaXJlY3RvcmllcztcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy5kb2N1bWVudERpcmVjdG9yeSAmJiB0eXBlb2Ygc2V0dGluZ3MuZG9jdW1lbnREaXJlY3RvcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsaWRhdGVkU2V0dGluZ3MuZG9jdW1lbnREaXJlY3RvcnkgPSBzZXR0aW5ncy5kb2N1bWVudERpcmVjdG9yeTtcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy5qb3VybmFsUm9vdEZvbGRlciAmJiB0eXBlb2Ygc2V0dGluZ3Muam91cm5hbFJvb3RGb2xkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsaWRhdGVkU2V0dGluZ3Muam91cm5hbFJvb3RGb2xkZXIgPSBzZXR0aW5ncy5qb3VybmFsUm9vdEZvbGRlcjtcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy5qb3VybmFsRGF0ZUZvcm1hdCAmJiB0eXBlb2Ygc2V0dGluZ3Muam91cm5hbERhdGVGb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsaWRhdGVkU2V0dGluZ3Muam91cm5hbERhdGVGb3JtYXQgPSBzZXR0aW5ncy5qb3VybmFsRGF0ZUZvcm1hdDtcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy5qb3VybmFsRm9sZGVyRm9ybWF0ICYmIHR5cGVvZiBzZXR0aW5ncy5qb3VybmFsRm9sZGVyRm9ybWF0ID09PSAnc3RyaW5nJykge1xuICAgIHZhbGlkYXRlZFNldHRpbmdzLmpvdXJuYWxGb2xkZXJGb3JtYXQgPSBzZXR0aW5ncy5qb3VybmFsRm9sZGVyRm9ybWF0O1xuICB9XG5cbiAgaWYgKHNldHRpbmdzLmpvdXJuYWxUZW1wbGF0ZSAmJiB0eXBlb2Ygc2V0dGluZ3Muam91cm5hbFRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgIHZhbGlkYXRlZFNldHRpbmdzLmpvdXJuYWxUZW1wbGF0ZSA9IHNldHRpbmdzLmpvdXJuYWxUZW1wbGF0ZTtcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy5ub3RlVGVtcGxhdGUgJiYgdHlwZW9mIHNldHRpbmdzLm5vdGVUZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWxpZGF0ZWRTZXR0aW5ncy5ub3RlVGVtcGxhdGUgPSBzZXR0aW5ncy5ub3RlVGVtcGxhdGU7XG4gIH1cblxuICBpZiAodHlwZW9mIHNldHRpbmdzLm9wZW5OZXdOb3RlID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWxpZGF0ZWRTZXR0aW5ncy5vcGVuTmV3Tm90ZSA9IHNldHRpbmdzLm9wZW5OZXdOb3RlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzZXR0aW5ncy5zaG9ydGNvZGVFbmFibGVkID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWxpZGF0ZWRTZXR0aW5ncy5zaG9ydGNvZGVFbmFibGVkID0gc2V0dGluZ3Muc2hvcnRjb2RlRW5hYmxlZDtcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy5zaG9ydGNvZGVUcmlnZ2VyS2V5ICYmIHR5cGVvZiBzZXR0aW5ncy5zaG9ydGNvZGVUcmlnZ2VyS2V5ID09PSAnc3RyaW5nJykge1xuICAgIHZhbGlkYXRlZFNldHRpbmdzLnNob3J0Y29kZVRyaWdnZXJLZXkgPSBzZXR0aW5ncy5zaG9ydGNvZGVUcmlnZ2VyS2V5O1xuICB9XG5cbiAgaWYgKHNldHRpbmdzLmN1c3RvbVNob3J0Y29kZXMgJiYgdHlwZW9mIHNldHRpbmdzLmN1c3RvbVNob3J0Y29kZXMgPT09ICdvYmplY3QnKSB7XG4gICAgdmFsaWRhdGVkU2V0dGluZ3MuY3VzdG9tU2hvcnRjb2RlcyA9IHNldHRpbmdzLmN1c3RvbVNob3J0Y29kZXM7XG4gIH1cblxuICBpZiAodHlwZW9mIHNldHRpbmdzLmRlYnVnTW9kZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsaWRhdGVkU2V0dGluZ3MuZGVidWdNb2RlID0gc2V0dGluZ3MuZGVidWdNb2RlO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZFNldHRpbmdzO1xufSIsICJcbmltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBMaW5rUGx1Z2luIGZyb20gJy4uL21haW4nO1xuXG5leHBvcnQgY2xhc3MgU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgcGx1Z2luOiBMaW5rUGx1Z2luO1xuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBMaW5rUGx1Z2luKSB7XG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG4gIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0xpbmsgUGx1Z2luIFNldHRpbmdzJyB9KTtcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKCdEZWJ1ZyBNb2RlJylcbiAgICAgIC5zZXREZXNjKCdFbmFibGUgZGVidWcgbG9nZ2luZycpXG4gICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcbiAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmRlYnVnTW9kZSlcbiAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRlYnVnTW9kZSA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9KSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBURm9sZGVyLCBub3JtYWxpemVQYXRoIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IExpbmtQbHVnaW4gZnJvbSAnLi4vbWFpbic7XG5pbXBvcnQgeyBcbiAgREVGQVVMVF9ESVJFQ1RPUklFUywgXG4gIERFRkFVTFRfSk9VUk5BTF9TVFJVQ1RVUkUsIFxuICBERUZBVUxUX1JFRkVSRU5DRV9TVFJVQ1RVUkUsXG4gIE9QVElPTkFMX0RJUkVDVE9SSUVTIFxufSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgUGF0aFV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvcGF0aFV0aWxzJztcbmltcG9ydCB7IERpcmVjdG9yeVRlbXBsYXRlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgRGlyZWN0b3J5TWFuYWdlciB7XG4gIHBsdWdpbjogTGlua1BsdWdpbjtcblxuICBjb25zdHJ1Y3RvcihwbHVnaW46IExpbmtQbHVnaW4pIHtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBiYXNlIGRpcmVjdG9yeSBzdHJ1Y3R1cmUgYWNjb3JkaW5nIHRvIHNldHRpbmdzXG4gICAqIEFsbCBkaXJlY3RvcmllcyBhcmUgY3JlYXRlZCB1bmRlciB0aGUgY29uZmlndXJlZCBiYXNlRm9sZGVyIHRvIHByZXZlbnQgY29sbGlzaW9uc1xuICAgKi9cbiAgYXN5bmMgcmVidWlsZERpcmVjdG9yeVN0cnVjdHVyZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLnBsdWdpbi5hcHA7XG4gICAgY29uc3QgeyBiYXNlRm9sZGVyLCBkaXJlY3RvcnlTdHJ1Y3R1cmUgfSA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgYmFzZSBmb2xkZXIgZmlyc3RcbiAgICAgIGNvbnN0IGJhc2VQYXRoID0gbm9ybWFsaXplUGF0aChiYXNlRm9sZGVyKTtcbiAgICAgIGF3YWl0IHRoaXMuZ2V0T3JDcmVhdGVEaXJlY3RvcnkoYmFzZVBhdGgpO1xuICAgICAgY29uc29sZS5sb2coYENyZWF0ZWQgYmFzZSBkaXJlY3Rvcnk6ICR7YmFzZVBhdGh9YCk7XG5cbiAgICAgIC8vIENyZWF0ZSBiYXNpYyBkaXJlY3Rvcnkgc3RydWN0dXJlXG4gICAgICBmb3IgKGNvbnN0IGRpck5hbWUgb2YgZGlyZWN0b3J5U3RydWN0dXJlIHx8IERFRkFVTFRfRElSRUNUT1JJRVMpIHtcbiAgICAgICAgY29uc3QgZGlyUGF0aCA9IFBhdGhVdGlscy5qb2luUGF0aChiYXNlUGF0aCwgZGlyTmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0T3JDcmVhdGVEaXJlY3RvcnkoZGlyUGF0aCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGVkIGRpcmVjdG9yeTogJHtkaXJQYXRofWApO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgZGV0YWlsZWQgam91cm5hbCBzdHJ1Y3R1cmVcbiAgICAgIGF3YWl0IHRoaXMuY3JlYXRlSm91cm5hbFN0cnVjdHVyZShiYXNlUGF0aCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSByZWZlcmVuY2Ugc3RydWN0dXJlXG4gICAgICBhd2FpdCB0aGlzLmNyZWF0ZVJlZmVyZW5jZVN0cnVjdHVyZShiYXNlUGF0aCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVidWlsZCBkaXJlY3Rvcnkgc3RydWN0dXJlOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBkZXRhaWxlZCBqb3VybmFsIHN0cnVjdHVyZSBhcyBzcGVjaWZpZWQgaW4gUkVBRE1FXG4gICAqL1xuICBhc3luYyBjcmVhdGVKb3VybmFsU3RydWN0dXJlKGJhc2VQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBqb3VybmFsUGF0aCA9IFBhdGhVdGlscy5qb2luUGF0aChiYXNlUGF0aCwgJ2pvdXJuYWwnKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgam91cm5hbCBzdWJkaXJlY3Rvcmllc1xuICAgIGNvbnN0IGpvdXJuYWxTdWJkaXJzID0gW1xuICAgICAgJ01pc2MnLFxuICAgICAgJ3lfMjAyNS9KYW51YXJ5JyxcbiAgICAgICd5XzIwMjUvRmVicnVhcnknLCBcbiAgICAgICd5XzIwMjUvTWFyY2gnLFxuICAgICAgJ3lfMjAyNS9BcHJpbCcsXG4gICAgICAneV8yMDI1L01heScsXG4gICAgICAneV8yMDI1L0p1bmUnLFxuICAgICAgJ3lfMjAyNS9NaXNjJyxcbiAgICAgICd5XzIwMjUvWWVhcmx5IExpc3QnLFxuICAgICAgJ3lfMjAyNS9ZZWFybHkgTG9nJyxcbiAgICAgICd6X0FyY2hpdmVzL3lfMjAyMicsXG4gICAgICAnel9BcmNoaXZlcy95XzIwMjMnLFxuICAgICAgJ3pfQXJjaGl2ZXMveV8yMDI0J1xuICAgIF07XG5cbiAgICBmb3IgKGNvbnN0IHN1YmRpciBvZiBqb3VybmFsU3ViZGlycykge1xuICAgICAgY29uc3QgZnVsbFBhdGggPSBQYXRoVXRpbHMuam9pblBhdGgoam91cm5hbFBhdGgsIHN1YmRpcik7XG4gICAgICBhd2FpdCB0aGlzLmdldE9yQ3JlYXRlRGlyZWN0b3J5KGZ1bGxQYXRoKTtcbiAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGVkIGpvdXJuYWwgZGlyZWN0b3J5OiAke2Z1bGxQYXRofWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSByZWZlcmVuY2UgZmlsZSBzdHJ1Y3R1cmUgYXMgc3BlY2lmaWVkIGluIFJFQURNRVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlUmVmZXJlbmNlU3RydWN0dXJlKGJhc2VQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCByZWZlcmVuY2VQYXRoID0gUGF0aFV0aWxzLmpvaW5QYXRoKGJhc2VQYXRoLCAncmVmZXJlbmNlJyk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHJlZmVyZW5jZSBmaWxlIHR5cGUgZGlyZWN0b3JpZXNcbiAgICBjb25zdCBmaWxlVHlwZXMgPSBbJ2ltYWdlcycsICdwZGZzJywgJ3ZpZGVvcycsICdhdWRpbycsICdkb2NzJywgJ290aGVyJ107XG4gICAgXG4gICAgZm9yIChjb25zdCBmaWxlVHlwZSBvZiBmaWxlVHlwZXMpIHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gUGF0aFV0aWxzLmpvaW5QYXRoKHJlZmVyZW5jZVBhdGgsICdmaWxlcycsIGZpbGVUeXBlKTtcbiAgICAgIGF3YWl0IHRoaXMuZ2V0T3JDcmVhdGVEaXJlY3RvcnkoZmlsZVBhdGgpO1xuICAgICAgY29uc29sZS5sb2coYENyZWF0ZWQgcmVmZXJlbmNlIGRpcmVjdG9yeTogJHtmaWxlUGF0aH1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBvcHRpb25hbCBjb21wbGV4IHN0cnVjdHVyZSBkaXJlY3Rvcmllc1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlT3B0aW9uYWxTdHJ1Y3R1cmUoYmFzZVBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGZvciAoY29uc3QgZGlyTmFtZSBvZiBPUFRJT05BTF9ESVJFQ1RPUklFUykge1xuICAgICAgY29uc3QgZGlyUGF0aCA9IFBhdGhVdGlscy5qb2luUGF0aChiYXNlUGF0aCwgZGlyTmFtZSk7XG4gICAgICBhd2FpdCB0aGlzLmdldE9yQ3JlYXRlRGlyZWN0b3J5KGRpclBhdGgpO1xuICAgICAgY29uc29sZS5sb2coYENyZWF0ZWQgb3B0aW9uYWwgZGlyZWN0b3J5OiAke2RpclBhdGh9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBkaXJlY3RvcnkgcGF0aCwgY3JlYXRpbmcgaXQgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgKiBIYW5kbGVzIGJvdGggYWJzb2x1dGUgcGF0aHMgYW5kIHBhdGhzIHJlbGF0aXZlIHRvIHRoZSBiYXNlIGZvbGRlclxuICAgKi9cbiAgYXN5bmMgZ2V0T3JDcmVhdGVEaXJlY3RvcnkocGF0aDogc3RyaW5nKTogUHJvbWlzZTxURm9sZGVyPiB7XG4gICAgY29uc3QgeyB2YXVsdCB9ID0gdGhpcy5wbHVnaW4uYXBwO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChwYXRoKTtcbiAgICBjb25zdCBleGlzdGluZ0ZvbGRlciA9IHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3JtYWxpemVkUGF0aCk7XG5cbiAgICBpZiAoZXhpc3RpbmdGb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdGb2xkZXI7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHBhcmVudCBkaXJlY3RvcmllcyByZWN1cnNpdmVseVxuICAgIGNvbnN0IHBhdGhQYXJ0cyA9IG5vcm1hbGl6ZWRQYXRoLnNwbGl0KCcvJyk7XG4gICAgbGV0IGN1cnJlbnRQYXRoID0gJyc7XG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0aFBhcnRzKSB7XG4gICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuXG4gICAgICBjdXJyZW50UGF0aCArPSAoY3VycmVudFBhdGggPyAnLycgOiAnJykgKyBwYXJ0O1xuICAgICAgY29uc3QgZm9sZGVyID0gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGN1cnJlbnRQYXRoKTtcblxuICAgICAgaWYgKCFmb2xkZXIpIHtcbiAgICAgICAgYXdhaXQgdmF1bHQuY3JlYXRlRm9sZGVyKGN1cnJlbnRQYXRoKTtcbiAgICAgIH0gZWxzZSBpZiAoIShmb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGggJHtjdXJyZW50UGF0aH0gZXhpc3RzIGJ1dCBpcyBub3QgYSBmb2xkZXJgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG5vcm1hbGl6ZWRQYXRoKSBhcyBURm9sZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZ1bGwgcGF0aCBmb3IgYSBkaXJlY3Rvcnkgd2l0aGluIHRoZSBwbHVnaW4ncyBiYXNlIGZvbGRlclxuICAgKi9cbiAgZ2V0UGx1Z2luRGlyZWN0b3J5UGF0aChyZWxhdGl2ZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBiYXNlRm9sZGVyIH0gPSB0aGlzLnBsdWdpbi5zZXR0aW5ncztcbiAgICByZXR1cm4gUGF0aFV0aWxzLmpvaW5QYXRoKGJhc2VGb2xkZXIsIHJlbGF0aXZlUGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgam91cm5hbCBkaXJlY3RvcnkgcGF0aFxuICAgKi9cbiAgZ2V0Sm91cm5hbFBhdGgoKTogc3RyaW5nIHtcbiAgICBjb25zdCB7IGJhc2VGb2xkZXIsIGpvdXJuYWxSb290Rm9sZGVyIH0gPSB0aGlzLnBsdWdpbi5zZXR0aW5ncztcbiAgICByZXR1cm4gUGF0aFV0aWxzLmpvaW5QYXRoKGJhc2VGb2xkZXIsIGpvdXJuYWxSb290Rm9sZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB3b3Jrc3BhY2UgZGlyZWN0b3J5IHBhdGggIFxuICAgKi9cbiAgZ2V0V29ya3NwYWNlUGF0aCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHsgYmFzZUZvbGRlciwgZG9jdW1lbnREaXJlY3RvcnkgfSA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuICAgIHJldHVybiBQYXRoVXRpbHMuam9pblBhdGgoYmFzZUZvbGRlciwgZG9jdW1lbnREaXJlY3RvcnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBkaXJlY3RvcnkgdGVtcGxhdGUgdG8gY3JlYXRlIHN0cnVjdHVyZWQgZm9sZGVyc1xuICAgKi9cbiAgYXN5bmMgYXBwbHlEaXJlY3RvcnlUZW1wbGF0ZShiYXNlUGF0aDogc3RyaW5nLCB0ZW1wbGF0ZTogRGlyZWN0b3J5VGVtcGxhdGUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0ZW1wbGF0ZSkpIHtcbiAgICAgIGNvbnN0IGRpclBhdGggPSBQYXRoVXRpbHMuam9pblBhdGgoYmFzZVBhdGgsIGtleSk7XG4gICAgICBhd2FpdCB0aGlzLmdldE9yQ3JlYXRlRGlyZWN0b3J5KGRpclBhdGgpO1xuXG4gICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhd2FpdCB0aGlzLmFwcGx5RGlyZWN0b3J5VGVtcGxhdGUoZGlyUGF0aCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgaWYgYSBnaXZlbiBwYXRoIGlzIHdpdGhpbiBhbGxvd2VkIGRpcmVjdG9yaWVzXG4gICAqL1xuICBpc1ZhbGlkUGF0aChwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aCk7XG4gICAgY29uc3QgeyByZXN0cmljdGVkRGlyZWN0b3JpZXMgfSA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuXG4gICAgaWYgKCFyZXN0cmljdGVkRGlyZWN0b3JpZXMgfHwgcmVzdHJpY3RlZERpcmVjdG9yaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuICFyZXN0cmljdGVkRGlyZWN0b3JpZXMuc29tZSgoZGlyOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWREaXIgPSBub3JtYWxpemVQYXRoKGRpcik7XG4gICAgICByZXR1cm4gbm9ybWFsaXplZFBhdGggPT09IG5vcm1hbGl6ZWREaXIgfHwgbm9ybWFsaXplZFBhdGguc3RhcnRzV2l0aChub3JtYWxpemVkRGlyICsgJy8nKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgZGlyZWN0b3JpZXMgaW4gdGhlIHZhdWx0XG4gICAqL1xuICBnZXRBbGxEaXJlY3RvcmllcygpOiBURm9sZGVyW10ge1xuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMucGx1Z2luLmFwcDtcbiAgICByZXR1cm4gdmF1bHQuZ2V0QWxsTG9hZGVkRmlsZXMoKVxuICAgICAgLmZpbHRlcihmaWxlID0+IGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSBhcyBURm9sZGVyW107XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGRpcmVjdG9yeSB3aXRoIGEgc3BlY2lmaWMgdGVtcGxhdGUgc3RydWN0dXJlIHdpdGhpbiB0aGUgcGx1Z2luJ3MgYmFzZSBmb2xkZXJcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVByb2plY3REaXJlY3RvcnkobmFtZTogc3RyaW5nLCB0ZW1wbGF0ZT86IERpcmVjdG9yeVRlbXBsYXRlKTogUHJvbWlzZTxURm9sZGVyPiB7XG4gICAgY29uc3Qgc2FuaXRpemVkTmFtZSA9IFBhdGhVdGlscy5zYW5pdGl6ZVBhdGgobmFtZSk7XG4gICAgY29uc3Qgd29ya3NwYWNlUGF0aCA9IHRoaXMuZ2V0V29ya3NwYWNlUGF0aCgpO1xuICAgIGNvbnN0IHByb2plY3RQYXRoID0gUGF0aFV0aWxzLmpvaW5QYXRoKHdvcmtzcGFjZVBhdGgsIHNhbml0aXplZE5hbWUpO1xuXG4gICAgY29uc3QgcHJvamVjdEZvbGRlciA9IGF3YWl0IHRoaXMuZ2V0T3JDcmVhdGVEaXJlY3RvcnkocHJvamVjdFBhdGgpO1xuXG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBhd2FpdCB0aGlzLmFwcGx5RGlyZWN0b3J5VGVtcGxhdGUocHJvamVjdFBhdGgsIHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvamVjdEZvbGRlcjtcbiAgfVxufSIsICJcbmltcG9ydCB7IG5vcm1hbGl6ZVBhdGggfSBmcm9tICdvYnNpZGlhbic7XG5cbmV4cG9ydCBjbGFzcyBQYXRoVXRpbHMge1xuICBzdGF0aWMgc2FuaXRpemVQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgocGF0aC5yZXBsYWNlKC9bXFwvOio/XCI8PnxdL2csICcnKS50cmltKCkpO1xuICB9XG5cbiAgc3RhdGljIGpvaW5QYXRoKC4uLnNlZ21lbnRzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgoc2VnbWVudHMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy8nKSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBURmlsZSwgbW9tZW50LCBub3JtYWxpemVQYXRoIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IExpbmtQbHVnaW4gZnJvbSAnLi4vbWFpbic7XG5pbXBvcnQgeyBEYXRlVXRpbHMgfSBmcm9tICcuLi91dGlscy9kYXRlVXRpbHMnO1xuaW1wb3J0IHsgSm91cm5hbEVudHJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgSm91cm5hbE1hbmFnZXIge1xuICBwbHVnaW46IExpbmtQbHVnaW47XG5cbiAgY29uc3RydWN0b3IocGx1Z2luOiBMaW5rUGx1Z2luKSB7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBvciBvcGVucyBhIGpvdXJuYWwgZW50cnkgZm9yIHRoZSBzcGVjaWZpZWQgZGF0ZVxuICAgKiBBdXRvbWF0aWNhbGx5IGNyZWF0ZXMgbW9udGhseSBmb2xkZXJzIGFzIG5lZWRlZFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlT3JPcGVuSm91cm5hbEVudHJ5KGRhdGU6IG1vbWVudC5Nb21lbnQpOiBQcm9taXNlPFRGaWxlPiB7XG4gICAgY29uc3QgeyB2YXVsdCB9ID0gdGhpcy5wbHVnaW4uYXBwO1xuICAgIGNvbnN0IHsgam91cm5hbERhdGVGb3JtYXQsIGpvdXJuYWxUZW1wbGF0ZSB9ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3M7XG5cbiAgICAvLyBDcmVhdGUgdGhlIG1vbnRobHkgZm9sZGVyIHN0cnVjdHVyZSBmb3IgdGhpcyBkYXRlXG4gICAgYXdhaXQgdGhpcy5lbnN1cmVNb250aGx5Rm9sZGVyRXhpc3RzKGRhdGUpO1xuXG4gICAgLy8gR2VuZXJhdGUgdGhlIGZpbGUgbmFtZSBhbmQgcGF0aCB1c2luZyB0aGUgbmV3IGJhc2UgZm9sZGVyIHN0cnVjdHVyZVxuICAgIGNvbnN0IG1vbnRobHlGb2xkZXJQYXRoID0gdGhpcy5nZXRNb250aGx5Rm9sZGVyUGF0aChkYXRlKTtcbiAgICBjb25zdCBmaWxlTmFtZSA9IGRhdGUuZm9ybWF0KGpvdXJuYWxEYXRlRm9ybWF0IHx8ICdZWVlZLU1NLUREIGRkZGQnKTtcbiAgICBjb25zdCBmaWxlUGF0aCA9IG5vcm1hbGl6ZVBhdGgoYCR7bW9udGhseUZvbGRlclBhdGh9LyR7ZmlsZU5hbWV9Lm1kYCk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgZmlsZSBhbHJlYWR5IGV4aXN0c1xuICAgIGxldCBmaWxlID0gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZpbGVQYXRoKSBhcyBURmlsZTtcblxuICAgIGlmICghZmlsZSkge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBmaWxlIHdpdGggdGVtcGxhdGUgY29udGVudFxuICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVKb3VybmFsQ29udGVudChkYXRlKTtcbiAgICAgIGZpbGUgPSBhd2FpdCB2YXVsdC5jcmVhdGUoZmlsZVBhdGgsIGNvbnRlbnQpO1xuICAgICAgY29uc29sZS5sb2coYENyZWF0ZWQgZGFpbHkgbm90ZTogJHtmaWxlUGF0aH1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoZSBtb250aGx5IGZvbGRlciBleGlzdHMgZm9yIHRoZSBnaXZlbiBkYXRlXG4gICAqIENyZWF0ZXMgdGhlIGZvbGRlciBzdHJ1Y3R1cmUgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgKi9cbiAgYXN5bmMgZW5zdXJlTW9udGhseUZvbGRlckV4aXN0cyhkYXRlOiBtb21lbnQuTW9tZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgbW9udGhseUZvbGRlclBhdGggPSB0aGlzLmdldE1vbnRobHlGb2xkZXJQYXRoKGRhdGUpO1xuICAgIGF3YWl0IHRoaXMucGx1Z2luLmRpcmVjdG9yeU1hbmFnZXIuZ2V0T3JDcmVhdGVEaXJlY3RvcnkobW9udGhseUZvbGRlclBhdGgpO1xuICAgIGNvbnNvbGUubG9nKGBFbnN1cmVkIG1vbnRobHkgZm9sZGVyIGV4aXN0czogJHttb250aGx5Rm9sZGVyUGF0aH1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtb250aGx5IGZvbGRlciBwYXRoIGZvciBhIGdpdmVuIGRhdGVcbiAgICogVXNlcyB0aGUgbmV3IGJhc2UgZm9sZGVyIHN0cnVjdHVyZTogTGlua1BsdWdpbi9qb3VybmFsL3lfWVlZWS9Nb250aE5hbWUvXG4gICAqL1xuICBwcml2YXRlIGdldE1vbnRobHlGb2xkZXJQYXRoKGRhdGU6IG1vbWVudC5Nb21lbnQpOiBzdHJpbmcge1xuICAgIGNvbnN0IGpvdXJuYWxCYXNlUGF0aCA9IHRoaXMucGx1Z2luLmRpcmVjdG9yeU1hbmFnZXIuZ2V0Sm91cm5hbFBhdGgoKTtcbiAgICBjb25zdCB5ZWFyID0gZGF0ZS5mb3JtYXQoJ1lZWVknKTtcbiAgICBjb25zdCBtb250aE5hbWUgPSBkYXRlLmZvcm1hdCgnTU1NTScpOyAvLyBGdWxsIG1vbnRoIG5hbWUgKEphbnVhcnksIEZlYnJ1YXJ5LCBldGMuKVxuICAgIFxuICAgIHJldHVybiBgJHtqb3VybmFsQmFzZVBhdGh9L3lfJHt5ZWFyfS8ke21vbnRoTmFtZX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkYWlseSBub3RlIGZvciB0b2RheSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAqIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyBtb250aGx5IGZvbGRlciBjcmVhdGlvblxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVG9kYXlOb3RlKCk6IFByb21pc2U8VEZpbGU+IHtcbiAgICBjb25zdCB0b2RheSA9IG1vbWVudCgpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZU9yT3BlbkpvdXJuYWxFbnRyeSh0b2RheSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGRhaWx5IG5vdGUgZm9yIGEgZnV0dXJlIGRhdGVcbiAgICogQXV0b21hdGljYWxseSBjcmVhdGVzIG1vbnRobHkgZm9sZGVycyBhcyBuZWVkZWRcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUZ1dHVyZURhaWx5Tm90ZShkYXRlOiBEYXRlIHwgc3RyaW5nKTogUHJvbWlzZTxURmlsZT4ge1xuICAgIGNvbnN0IHRhcmdldERhdGUgPSB0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycgPyBtb21lbnQoZGF0ZSkgOiBtb21lbnQoZGF0ZSk7XG4gICAgXG4gICAgLy8gVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgY3JlYXRlIHRoZSBtb250aGx5IGZvbGRlciBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlT3JPcGVuSm91cm5hbEVudHJ5KHRhcmdldERhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGNvbnRlbnQgZm9yIGEgam91cm5hbCBlbnRyeVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZUpvdXJuYWxDb250ZW50KGRhdGU6IG1vbWVudC5Nb21lbnQpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHsgam91cm5hbFRlbXBsYXRlLCBqb3VybmFsRGF0ZUZvcm1hdCB9ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3M7XG4gICAgY29uc3QgcHJldmlvdXNEYXkgPSBtb21lbnQoZGF0ZSkuc3VidHJhY3QoMSwgJ2RheScpO1xuICAgIGNvbnN0IG5leHREYXkgPSBtb21lbnQoZGF0ZSkuYWRkKDEsICdkYXknKTtcblxuICAgIGNvbnN0IHByZXZpb3VzTGluayA9IGBbWyR7cHJldmlvdXNEYXkuZm9ybWF0KGpvdXJuYWxEYXRlRm9ybWF0IHx8ICdZWVlZLU1NLUREIGRkZGQnKX1dXWA7XG4gICAgY29uc3QgbmV4dExpbmsgPSBgW1ske25leHREYXkuZm9ybWF0KGpvdXJuYWxEYXRlRm9ybWF0IHx8ICdZWVlZLU1NLUREIGRkZGQnKX1dXWA7XG4gICAgY29uc3QgY3VycmVudERhdGUgPSBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xuICAgIGNvbnN0IHRpdGxlID0gZGF0ZS5mb3JtYXQoam91cm5hbERhdGVGb3JtYXQgfHwgJ1lZWVktTU0tREQgZGRkZCcpO1xuXG4gICAgaWYgKGpvdXJuYWxUZW1wbGF0ZSkge1xuICAgICAgLy8gUmVwbGFjZSB0ZW1wbGF0ZSB2YXJpYWJsZXNcbiAgICAgIHJldHVybiBqb3VybmFsVGVtcGxhdGVcbiAgICAgICAgLnJlcGxhY2UoL3t7ZGF0ZX19L2csIGN1cnJlbnREYXRlKVxuICAgICAgICAucmVwbGFjZSgve3t0aXRsZX19L2csIHRpdGxlKVxuICAgICAgICAucmVwbGFjZSgve3twcmV2aW91c319L2csIHByZXZpb3VzTGluaylcbiAgICAgICAgLnJlcGxhY2UoL3t7bmV4dH19L2csIG5leHRMaW5rKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRlbXBsYXRlXG4gICAgcmV0dXJuIGAtLS1cbmRhdGU6ICR7Y3VycmVudERhdGV9XG5wcmV2aW91czogJHtwcmV2aW91c0xpbmt9XG5uZXh0OiAke25leHRMaW5rfVxudGFnczpcbiAgLSBqb3VybmFsXG4tLS1cblxuIyAke3RpdGxlfVxuXG4jIyBEYWlseSBMb2dcblxuIyMgVGFza3Ncbi0gWyBdIFxuXG4jIyBOb3Rlc1xuXG4jIyBSZWZsZWN0aW9uXG5cbi0tLVxuUHJldmlvdXM6ICR7cHJldmlvdXNMaW5rfSB8IE5leHQ6ICR7bmV4dExpbmt9XG5gO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBqb3VybmFsIGVudHJ5IGZvciB0b2RheVxuICAgKiBDcmVhdGVzIG1vbnRobHkgZm9sZGVyIGFuZCBkYWlseSBub3RlIGlmIHRoZXkgZG9uJ3QgZXhpc3RcbiAgICovXG4gIGFzeW5jIG9wZW5Ub2RheUpvdXJuYWwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgdG9kYXkgPSBtb21lbnQoKTtcbiAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy5jcmVhdGVPck9wZW5Kb3VybmFsRW50cnkodG9kYXkpO1xuXG4gICAgLy8gT3BlbiB0aGUgZmlsZSBpbiBhIG5ldyBsZWFmXG4gICAgY29uc3QgbGVhZiA9IHRoaXMucGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZigpO1xuICAgIGF3YWl0IGxlYWYub3BlbkZpbGUoZmlsZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IG1vbnRobHkgZm9sZGVyXG4gICAqIENhbGxlZCB3aGVuIHRoZSBwbHVnaW4gbG9hZHMgb3Igd2hlbiBjcmVhdGluZyBub3Rlc1xuICAgKi9cbiAgYXN5bmMgY2hlY2tBbmRDcmVhdGVDdXJyZW50TW9udGhGb2xkZXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY3VycmVudERhdGUgPSBtb21lbnQoKTtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZU1vbnRobHlGb2xkZXJFeGlzdHMoY3VycmVudERhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbW9udGhseSBmb2xkZXJzIGZvciBhIHJhbmdlIG9mIGRhdGVzXG4gICAqIFVzZWZ1bCBmb3IgYmF0Y2ggY3JlYXRpb24gb3Igc2V0dXBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZU1vbnRobHlGb2xkZXJzRm9yUmFuZ2Uoc3RhcnREYXRlOiBtb21lbnQuTW9tZW50LCBlbmREYXRlOiBtb21lbnQuTW9tZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY3VycmVudCA9IG1vbWVudChzdGFydERhdGUpLnN0YXJ0T2YoJ21vbnRoJyk7XG4gICAgY29uc3QgZW5kID0gbW9tZW50KGVuZERhdGUpLmVuZE9mKCdtb250aCcpO1xuXG4gICAgd2hpbGUgKGN1cnJlbnQuaXNTYW1lT3JCZWZvcmUoZW5kKSkge1xuICAgICAgYXdhaXQgdGhpcy5lbnN1cmVNb250aGx5Rm9sZGVyRXhpc3RzKGN1cnJlbnQpO1xuICAgICAgY3VycmVudC5hZGQoMSwgJ21vbnRoJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIGpvdXJuYWwgZW50cnkgZm9yIGEgc3BlY2lmaWMgZGF0ZVxuICAgKi9cbiAgYXN5bmMgb3BlbkpvdXJuYWxGb3JEYXRlKGRhdGU6IERhdGUgfCBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtb21lbnREYXRlID0gdHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnID8gbW9tZW50KGRhdGUpIDogbW9tZW50KGRhdGUpO1xuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLmNyZWF0ZU9yT3BlbkpvdXJuYWxFbnRyeShtb21lbnREYXRlKTtcblxuICAgIGNvbnN0IGxlYWYgPSB0aGlzLnBsdWdpbi5hcHAud29ya3NwYWNlLmdldExlYWYoKTtcbiAgICBhd2FpdCBsZWFmLm9wZW5GaWxlKGZpbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgbGlua3MgYmV0d2VlbiBqb3VybmFsIGVudHJpZXNcbiAgICovXG4gIGFzeW5jIHVwZGF0ZUpvdXJuYWxMaW5rcyhmaWxlOiBURmlsZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMucGx1Z2luLmFwcDtcbiAgICBjb25zdCB7IGpvdXJuYWxEYXRlRm9ybWF0IH0gPSB0aGlzLnBsdWdpbi5zZXR0aW5ncztcblxuICAgIC8vIEV4dHJhY3QgZGF0ZSBmcm9tIGZpbGVuYW1lXG4gICAgY29uc3QgZmlsZURhdGUgPSBEYXRlVXRpbHMuZXh0cmFjdERhdGVGcm9tRmlsZW5hbWUoZmlsZS5iYXNlbmFtZSwgam91cm5hbERhdGVGb3JtYXQpO1xuICAgIGlmICghZmlsZURhdGUpIHJldHVybjtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB2YXVsdC5yZWFkKGZpbGUpO1xuICAgIGNvbnN0IHByZXZpb3VzRGF5ID0gbW9tZW50KGZpbGVEYXRlKS5zdWJ0cmFjdCgxLCAnZGF5Jyk7XG4gICAgY29uc3QgbmV4dERheSA9IG1vbWVudChmaWxlRGF0ZSkuYWRkKDEsICdkYXknKTtcblxuICAgIGNvbnN0IHByZXZpb3VzRmlsZU5hbWUgPSBwcmV2aW91c0RheS5mb3JtYXQoam91cm5hbERhdGVGb3JtYXQgfHwgJ1lZWVktTU0tREQgZGRkZCcpO1xuICAgIGNvbnN0IG5leHRGaWxlTmFtZSA9IG5leHREYXkuZm9ybWF0KGpvdXJuYWxEYXRlRm9ybWF0IHx8ICdZWVlZLU1NLUREIGRkZGQnKTtcblxuICAgIC8vIFVwZGF0ZSBmcm9udG1hdHRlciBsaW5rc1xuICAgIGNvbnN0IHVwZGF0ZWRDb250ZW50ID0gY29udGVudFxuICAgICAgLnJlcGxhY2UoL3ByZXZpb3VzOiAnXFxbXFxbKC4qPylcXF1cXF0nL2csIGBwcmV2aW91czogJ1tbJHtwcmV2aW91c0ZpbGVOYW1lfV1dJ2ApXG4gICAgICAucmVwbGFjZSgvbmV4dDogJ1xcW1xcWyguKj8pXFxdXFxdJy9nLCBgbmV4dDogJ1tbJHtuZXh0RmlsZU5hbWV9XV0nYCk7XG5cbiAgICBpZiAoY29udGVudCAhPT0gdXBkYXRlZENvbnRlbnQpIHtcbiAgICAgIGF3YWl0IHZhdWx0Lm1vZGlmeShmaWxlLCB1cGRhdGVkQ29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgam91cm5hbCBlbnRyaWVzIGluIGEgZGF0ZSByYW5nZVxuICAgKi9cbiAgYXN5bmMgZ2V0Sm91cm5hbEVudHJpZXMoc3RhcnREYXRlOiBtb21lbnQuTW9tZW50LCBlbmREYXRlOiBtb21lbnQuTW9tZW50KTogUHJvbWlzZTxKb3VybmFsRW50cnlbXT4ge1xuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMucGx1Z2luLmFwcDtcbiAgICBjb25zdCBlbnRyaWVzOiBKb3VybmFsRW50cnlbXSA9IFtdO1xuXG4gICAgY29uc3QgY3VycmVudCA9IG1vbWVudChzdGFydERhdGUpO1xuICAgIHdoaWxlIChjdXJyZW50LmlzU2FtZU9yQmVmb3JlKGVuZERhdGUpKSB7XG4gICAgICBjb25zdCBlbnRyeVBhdGggPSBEYXRlVXRpbHMuZ2V0Sm91cm5hbFBhdGgoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmpvdXJuYWxSb290Rm9sZGVyLFxuICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5qb3VybmFsRm9sZGVyRm9ybWF0LFxuICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5qb3VybmFsRGF0ZUZvcm1hdFxuICAgICAgKTtcblxuICAgICAgY29uc3QgZmlsZSA9IHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChlbnRyeVBhdGgpIGFzIFRGaWxlO1xuICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAgICBkYXRlOiBjdXJyZW50LmZvcm1hdCgnWVlZWS1NTS1ERCcpLFxuICAgICAgICAgIHBhdGg6IGZpbGUucGF0aCxcbiAgICAgICAgICB0aXRsZTogZmlsZS5iYXNlbmFtZSxcbiAgICAgICAgICBwcmV2aW91czogbW9tZW50KGN1cnJlbnQpLnN1YnRyYWN0KDEsICdkYXknKS5mb3JtYXQoJ1lZWVktTU0tREQnKSxcbiAgICAgICAgICBuZXh0OiBtb21lbnQoY3VycmVudCkuYWRkKDEsICdkYXknKS5mb3JtYXQoJ1lZWVktTU0tREQnKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudC5hZGQoMSwgJ2RheScpO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG59IiwgIlxuaW1wb3J0IHsgbW9tZW50IH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5leHBvcnQgY2xhc3MgRGF0ZVV0aWxzIHtcbiAgc3RhdGljIGV4dHJhY3REYXRlRnJvbUZpbGVuYW1lKGZpbGVuYW1lOiBzdHJpbmcsIGZvcm1hdDogc3RyaW5nKTogbW9tZW50Lk1vbWVudCB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRlID0gKG1vbWVudCBhcyBhbnkpKGZpbGVuYW1lLCBmb3JtYXQsIHRydWUpO1xuICAgICAgcmV0dXJuIGRhdGUuaXNWYWxpZCgpID8gZGF0ZSA6IG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBmb3JtYXREYXRlKGRhdGU6IERhdGUgfCBtb21lbnQuTW9tZW50LCBmb3JtYXQ6IHN0cmluZyA9ICdZWVlZLU1NLUREJyk6IHN0cmluZyB7XG4gICAgY29uc3QgbSA9IChkYXRlIGluc3RhbmNlb2YgRGF0ZSkgPyAobW9tZW50IGFzIGFueSkoZGF0ZSkgOiBkYXRlO1xuICAgIHJldHVybiBtLmZvcm1hdChmb3JtYXQpO1xuICB9XG5cbiAgc3RhdGljIGdldEpvdXJuYWxQYXRoKGRhdGU6IERhdGUgfCBtb21lbnQuTW9tZW50LCBiYXNlRm9sZGVyOiBzdHJpbmcsIGpvdXJuYWxGb2xkZXI6IHN0cmluZywgZGF0ZUZvcm1hdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBtID0gKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSA/IChtb21lbnQgYXMgYW55KShkYXRlKSA6IGRhdGU7XG4gICAgY29uc3QgeWVhciA9IG0uZm9ybWF0KCdZWVlZJyk7XG4gICAgY29uc3QgbW9udGhOYW1lID0gbS5mb3JtYXQoJ01NTU0nKTtcbiAgICBjb25zdCBmaWxlTmFtZSA9IG0uZm9ybWF0KGRhdGVGb3JtYXQgfHwgJ1lZWVktTU0tREQgZGRkZCcpO1xuICAgIFxuICAgIHJldHVybiBgJHtiYXNlRm9sZGVyfS8ke2pvdXJuYWxGb2xkZXJ9L3lfJHt5ZWFyfS8ke21vbnRoTmFtZX0vJHtmaWxlTmFtZX0ubWRgO1xuICB9XG5cbiAgc3RhdGljIGdldEN1cnJlbnRNb250aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiAobW9tZW50IGFzIGFueSkoKS5mb3JtYXQoJ01NTU0nKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRDdXJyZW50WWVhcigpOiBzdHJpbmcge1xuICAgIHJldHVybiAobW9tZW50IGFzIGFueSkoKS5mb3JtYXQoJ1lZWVknKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRNb250aGx5Rm9sZGVyTmFtZShkYXRlOiBEYXRlIHwgbW9tZW50Lk1vbWVudCk6IHN0cmluZyB7XG4gICAgY29uc3QgbSA9IChkYXRlIGluc3RhbmNlb2YgRGF0ZSkgPyAobW9tZW50IGFzIGFueSkoZGF0ZSkgOiBkYXRlO1xuICAgIHJldHVybiBgeV8ke20uZm9ybWF0KCdZWVlZJyl9LyR7bS5mb3JtYXQoJ01NTU0nKX1gO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yLCBNYXJrZG93blZpZXcsIFRGaWxlLCBub3JtYWxpemVQYXRoIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IExpbmtQbHVnaW4gZnJvbSAnLi4vbWFpbic7XG5pbXBvcnQgeyBMaW5rU3VnZ2VzdGlvbiB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFBhdGhVdGlscyB9IGZyb20gJy4uL3V0aWxzL3BhdGhVdGlscyc7XG5pbXBvcnQgeyBSRUdFWF9QQVRURVJOUyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBjbGFzcyBMaW5rTWFuYWdlciB7XG4gIHBsdWdpbjogTGlua1BsdWdpbjtcblxuICBjb25zdHJ1Y3RvcihwbHVnaW46IExpbmtQbHVnaW4pIHtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbm90ZSBmcm9tIHNlbGVjdGVkIHRleHQgYW5kIGxpbmsgdG8gaXRcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUxpbmtlZE5vdGUoc2VsZWN0aW9uOiBzdHJpbmcsIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLnBsdWdpbi5hcHA7XG4gICAgY29uc3QgY3VycmVudEZpbGUgPSB2aWV3LmZpbGU7XG5cbiAgICBpZiAoIWN1cnJlbnRGaWxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBmaWxlIGZvdW5kJyk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgYSBmaWxlIHBhdGggZm9yIHRoZSBuZXcgbm90ZVxuICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5zYW5pdGl6ZUZpbGVOYW1lKHNlbGVjdGlvbik7XG4gICAgY29uc3QgZGlyZWN0b3J5UGF0aCA9IHRoaXMuZGV0ZXJtaW5lVGFyZ2V0RGlyZWN0b3J5KGZpbGVOYW1lKTtcbiAgICBjb25zdCBmaWxlUGF0aCA9IG5vcm1hbGl6ZVBhdGgoYCR7ZGlyZWN0b3J5UGF0aH0vJHtmaWxlTmFtZX0ubWRgKTtcblxuICAgIC8vIENoZWNrIGlmIGZpbGUgYWxyZWFkeSBleGlzdHNcbiAgICBsZXQgZmlsZSA9IHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlUGF0aCkgYXMgVEZpbGU7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGZpbGUgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgIGlmICghZmlsZSkge1xuICAgICAgLy8gRW5zdXJlIHRoZSBkaXJlY3RvcnkgZXhpc3RzXG4gICAgICBhd2FpdCB0aGlzLnBsdWdpbi5kaXJlY3RvcnlNYW5hZ2VyLmdldE9yQ3JlYXRlRGlyZWN0b3J5KGRpcmVjdG9yeVBhdGgpO1xuXG4gICAgICAvLyBDcmVhdGUgY29udGVudCBmb3IgdGhlIG5ldyBub3RlXG4gICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5nZW5lcmF0ZU5vdGVDb250ZW50KHNlbGVjdGlvbiwgY3VycmVudEZpbGUpO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIGZpbGVcbiAgICAgIGZpbGUgPSBhd2FpdCB2YXVsdC5jcmVhdGUoZmlsZVBhdGgsIGNvbnRlbnQpO1xuICAgIH1cblxuICAgIC8vIFJlcGxhY2UgdGhlIHNlbGVjdGVkIHRleHQgd2l0aCBhIGxpbmsgdG8gdGhlIG5vdGVcbiAgICBlZGl0b3IucmVwbGFjZVNlbGVjdGlvbihgW1ske2ZpbGVOYW1lfV1dYCk7XG5cbiAgICAvLyBPcGVuIHRoZSBub3RlIGluIGEgbmV3IHBhbmUgaWYgY29uZmlndXJlZFxuICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vcGVuTmV3Tm90ZSkge1xuICAgICAgY29uc3QgbGVhZiA9IHRoaXMucGx1Z2luLmFwcC53b3Jrc3BhY2Uuc3BsaXRBY3RpdmVMZWFmKCk7XG4gICAgICBhd2FpdCBsZWFmLm9wZW5GaWxlKGZpbGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGRpcmVjdG9yeSBmb3IgYSBuZXcgbm90ZVxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlcm1pbmVUYXJnZXREaXJlY3RvcnkodGl0bGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBkb2N1bWVudERpcmVjdG9yeSB9ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3M7XG5cbiAgICAvLyBMb2dpYyB0byBjYXRlZ29yaXplIG5vdGVzIGludG8gZGlmZmVyZW50IGRpcmVjdG9yaWVzIGJhc2VkIG9uIGtleXdvcmRzXG4gICAgY29uc3Qga2V5d29yZHMgPSB0aXRsZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGtleXdvcmRzLmluY2x1ZGVzKCdwcm9qZWN0JykgfHwga2V5d29yZHMuaW5jbHVkZXMoJ3dvcmsnKSkge1xuICAgICAgcmV0dXJuICdXb3Jrc3BhY2UnO1xuICAgIH0gZWxzZSBpZiAoa2V5d29yZHMuaW5jbHVkZXMoJ3JlZmVyZW5jZScpIHx8IGtleXdvcmRzLmluY2x1ZGVzKCdkZWZpbml0aW9uJykpIHtcbiAgICAgIHJldHVybiAnUmVmZXJlbmNlcyc7XG4gICAgfSBlbHNlIGlmIChrZXl3b3Jkcy5pbmNsdWRlcygndGVtcGxhdGUnKSkge1xuICAgICAgcmV0dXJuICdUZW1wbGF0ZXMnO1xuICAgIH1cblxuICAgIHJldHVybiBkb2N1bWVudERpcmVjdG9yeSB8fCAnRG9jdW1lbnRzJztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBjb250ZW50IGZvciBhIG5ldyBsaW5rZWQgbm90ZVxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZU5vdGVDb250ZW50KHRpdGxlOiBzdHJpbmcsIHNvdXJjZUZpbGU6IFRGaWxlKTogc3RyaW5nIHtcbiAgICBjb25zdCB7IG5vdGVUZW1wbGF0ZSB9ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3M7XG4gICAgY29uc3QgY3VycmVudERhdGUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcblxuICAgIGlmIChub3RlVGVtcGxhdGUpIHtcbiAgICAgIC8vIFJlcGxhY2UgdGVtcGxhdGUgdmFyaWFibGVzXG4gICAgICByZXR1cm4gbm90ZVRlbXBsYXRlXG4gICAgICAgIC5yZXBsYWNlKC97e3RpdGxlfX0vZywgdGl0bGUpXG4gICAgICAgIC5yZXBsYWNlKC97e2RhdGV9fS9nLCBjdXJyZW50RGF0ZSlcbiAgICAgICAgLnJlcGxhY2UoL3t7c291cmNlfX0vZywgYFtbJHtzb3VyY2VGaWxlLmJhc2VuYW1lfV1dYCk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0ZW1wbGF0ZVxuICAgIHJldHVybiBgLS0tXG50aXRsZTogJHt0aXRsZX1cbmNyZWF0ZWQ6ICR7Y3VycmVudERhdGV9XG5zb3VyY2U6IFtbJHtzb3VyY2VGaWxlLmJhc2VuYW1lfV1dXG50YWdzOiBbXVxuLS0tXG5cbiMgJHt0aXRsZX1cblxuYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYW5pdGl6ZSBhIHN0cmluZyBmb3IgdXNlIGFzIGEgZmlsZW5hbWVcbiAgICovXG4gIHByaXZhdGUgc2FuaXRpemVGaWxlTmFtZShpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaW5wdXRcbiAgICAgIC5yZXBsYWNlKFJFR0VYX1BBVFRFUk5TLklOVkFMSURfRklMRU5BTUVfQ0hBUlMsICcnKVxuICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKVxuICAgICAgLnRyaW0oKVxuICAgICAgLnN1YnN0cmluZygwLCAxMDApOyAvLyBMaW1pdCBsZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGFsbCBsaW5rcyBpbiBhIGZpbGVcbiAgICovXG4gIGFzeW5jIGZpbmRMaW5rc0luRmlsZShmaWxlOiBURmlsZSk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLnBsdWdpbi5hcHA7XG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IHZhdWx0LnJlYWQoZmlsZSk7XG4gICAgY29uc3QgbGlua3M6IHN0cmluZ1tdID0gW107XG5cbiAgICBsZXQgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IFJFR0VYX1BBVFRFUk5TLldJS0lfTElOSy5leGVjKGNvbnRlbnQpKSAhPT0gbnVsbCkge1xuICAgICAgbGlua3MucHVzaChtYXRjaFsxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmtzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYWxsIGJhY2tsaW5rcyB0byBhIGZpbGVcbiAgICovXG4gIGFzeW5jIGZpbmRCYWNrbGlua3MoZmlsZTogVEZpbGUpOiBQcm9taXNlPFRGaWxlW10+IHtcbiAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLnBsdWdpbi5hcHA7XG4gICAgY29uc3QgZmlsZXMgPSB2YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgY29uc3QgYmFja2xpbmtzOiBURmlsZVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHBvdGVudGlhbFNvdXJjZSBvZiBmaWxlcykge1xuICAgICAgaWYgKHBvdGVudGlhbFNvdXJjZS5wYXRoID09PSBmaWxlLnBhdGgpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBsaW5rcyA9IGF3YWl0IHRoaXMuZmluZExpbmtzSW5GaWxlKHBvdGVudGlhbFNvdXJjZSk7XG4gICAgICBpZiAobGlua3MuaW5jbHVkZXMoZmlsZS5iYXNlbmFtZSkpIHtcbiAgICAgICAgYmFja2xpbmtzLnB1c2gocG90ZW50aWFsU291cmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmFja2xpbmtzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYnJva2VuIGxpbmtzIGluIHRoZSB2YXVsdFxuICAgKi9cbiAgYXN5bmMgZmluZEJyb2tlbkxpbmtzKCk6IFByb21pc2U8eyBmaWxlOiBURmlsZTsgYnJva2VuTGlua3M6IHN0cmluZ1tdIH1bXT4ge1xuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMucGx1Z2luLmFwcDtcbiAgICBjb25zdCBmaWxlcyA9IHZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcbiAgICBjb25zdCBicm9rZW5MaW5rc0RhdGE6IHsgZmlsZTogVEZpbGU7IGJyb2tlbkxpbmtzOiBzdHJpbmdbXSB9W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgY29uc3QgbGlua3MgPSBhd2FpdCB0aGlzLmZpbmRMaW5rc0luRmlsZShmaWxlKTtcbiAgICAgIGNvbnN0IGJyb2tlbkxpbmtzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IGxpbmsgb2YgbGlua3MpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGxpbmtlZCBmaWxlIGV4aXN0c1xuICAgICAgICBjb25zdCBsaW5rZWRGaWxlID0gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGAke2xpbmt9Lm1kYCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGxpbmspO1xuXG4gICAgICAgIGlmICghbGlua2VkRmlsZSkge1xuICAgICAgICAgIGJyb2tlbkxpbmtzLnB1c2gobGluayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGJyb2tlbkxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYnJva2VuTGlua3NEYXRhLnB1c2goeyBmaWxlLCBicm9rZW5MaW5rcyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnJva2VuTGlua3NEYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgb3JwaGFuZWQgbm90ZXMgKG5vdGVzIHdpdGggbm8gYmFja2xpbmtzKVxuICAgKi9cbiAgYXN5bmMgZmluZE9ycGhhbmVkTm90ZXMoKTogUHJvbWlzZTxURmlsZVtdPiB7XG4gICAgY29uc3QgeyB2YXVsdCB9ID0gdGhpcy5wbHVnaW4uYXBwO1xuICAgIGNvbnN0IGZpbGVzID0gdmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgIGNvbnN0IG9ycGhhbmVkTm90ZXM6IFRGaWxlW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgY29uc3QgYmFja2xpbmtzID0gYXdhaXQgdGhpcy5maW5kQmFja2xpbmtzKGZpbGUpO1xuICAgICAgaWYgKGJhY2tsaW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgb3JwaGFuZWROb3Rlcy5wdXNoKGZpbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcnBoYW5lZE5vdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGxpbmsgc3VnZ2VzdGlvbnMgYmFzZWQgb24gY29udGVudCBzaW1pbGFyaXR5XG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZUxpbmtTdWdnZXN0aW9ucyhmaWxlOiBURmlsZSwgbGltaXQ6IG51bWJlciA9IDUpOiBQcm9taXNlPExpbmtTdWdnZXN0aW9uW10+IHtcbiAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLnBsdWdpbi5hcHA7XG4gICAgY29uc3QgZmlsZXMgPSB2YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnM6IExpbmtTdWdnZXN0aW9uW10gPSBbXTtcblxuICAgIGNvbnN0IGN1cnJlbnRDb250ZW50ID0gYXdhaXQgdmF1bHQucmVhZChmaWxlKTtcbiAgICBjb25zdCBjdXJyZW50V29yZHMgPSB0aGlzLmV4dHJhY3RXb3JkcyhjdXJyZW50Q29udGVudCk7XG5cbiAgICBmb3IgKGNvbnN0IG90aGVyRmlsZSBvZiBmaWxlcykge1xuICAgICAgaWYgKG90aGVyRmlsZS5wYXRoID09PSBmaWxlLnBhdGgpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBvdGhlckNvbnRlbnQgPSBhd2FpdCB2YXVsdC5yZWFkKG90aGVyRmlsZSk7XG4gICAgICBjb25zdCBvdGhlcldvcmRzID0gdGhpcy5leHRyYWN0V29yZHMob3RoZXJDb250ZW50KTtcblxuICAgICAgY29uc3QgcmVsZXZhbmNlID0gdGhpcy5jYWxjdWxhdGVSZWxldmFuY2UoY3VycmVudFdvcmRzLCBvdGhlcldvcmRzKTtcblxuICAgICAgaWYgKHJlbGV2YW5jZSA+IDAuMSkgeyAvLyBUaHJlc2hvbGQgZm9yIHJlbGV2YW5jZVxuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICB0aXRsZTogb3RoZXJGaWxlLmJhc2VuYW1lLFxuICAgICAgICAgIHBhdGg6IG90aGVyRmlsZS5wYXRoLFxuICAgICAgICAgIHJlbGV2YW5jZSxcbiAgICAgICAgICB0eXBlOiAnZXhpc3RpbmcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNvcnQgYnkgcmVsZXZhbmNlIGFuZCByZXR1cm4gdG9wIHN1Z2dlc3Rpb25zXG4gICAgcmV0dXJuIHN1Z2dlc3Rpb25zXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5yZWxldmFuY2UgLSBhLnJlbGV2YW5jZSlcbiAgICAgIC5zbGljZSgwLCBsaW1pdCk7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBtZWFuaW5nZnVsIHdvcmRzIGZyb20gY29udGVudFxuICAgKi9cbiAgcHJpdmF0ZSBleHRyYWN0V29yZHMoY29udGVudDogc3RyaW5nKTogU2V0PHN0cmluZz4ge1xuICAgIGNvbnN0IHdvcmRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3QgdGV4dCA9IGNvbnRlbnRcbiAgICAgIC5yZXBsYWNlKC9bIypgXFxbXFxdKCldL2csICcnKSAvLyBSZW1vdmUgbWFya2Rvd24gc3ludGF4XG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgLnNwbGl0KC9cXHMrLyk7XG5cbiAgICBmb3IgKGNvbnN0IHdvcmQgb2YgdGV4dCkge1xuICAgICAgaWYgKHdvcmQubGVuZ3RoID4gMyAmJiAhdGhpcy5pc1N0b3BXb3JkKHdvcmQpKSB7XG4gICAgICAgIHdvcmRzLmFkZCh3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd29yZHM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHJlbGV2YW5jZSBiZXR3ZWVuIHR3byBzZXRzIG9mIHdvcmRzXG4gICAqL1xuICBwcml2YXRlIGNhbGN1bGF0ZVJlbGV2YW5jZSh3b3JkczE6IFNldDxzdHJpbmc+LCB3b3JkczI6IFNldDxzdHJpbmc+KTogbnVtYmVyIHtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBuZXcgU2V0KFsuLi53b3JkczFdLmZpbHRlcih3b3JkID0+IHdvcmRzMi5oYXMod29yZCkpKTtcbiAgICBjb25zdCB1bmlvbiA9IG5ldyBTZXQoWy4uLndvcmRzMSwgLi4ud29yZHMyXSk7XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9uLnNpemUgLyB1bmlvbi5zaXplOyAvLyBKYWNjYXJkIHNpbWlsYXJpdHlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHdvcmQgaXMgYSBzdG9wIHdvcmRcbiAgICovXG4gIHByaXZhdGUgaXNTdG9wV29yZCh3b3JkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBzdG9wV29yZHMgPSBuZXcgU2V0KFtcbiAgICAgICd0aGUnLCAnYScsICdhbicsICdhbmQnLCAnb3InLCAnYnV0JywgJ2luJywgJ29uJywgJ2F0JywgJ3RvJywgJ2ZvcicsXG4gICAgICAnb2YnLCAnd2l0aCcsICdieScsICdpcycsICdhcmUnLCAnd2FzJywgJ3dlcmUnLCAnYmUnLCAnYmVlbicsICdoYXZlJyxcbiAgICAgICdoYXMnLCAnaGFkJywgJ2RvJywgJ2RvZXMnLCAnZGlkJywgJ3dpbGwnLCAnd291bGQnLCAnY291bGQnLCAnc2hvdWxkJyxcbiAgICAgICdtYXknLCAnbWlnaHQnLCAnbXVzdCcsICdjYW4nLCAndGhpcycsICd0aGF0JywgJ3RoZXNlJywgJ3Rob3NlJ1xuICAgIF0pO1xuXG4gICAgcmV0dXJuIHN0b3BXb3Jkcy5oYXMod29yZCk7XG4gIH1cbn0iLCAiaW1wb3J0IHsgVG9rZW4gfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBUb2tlbml6ZXIge1xuICAvKipcbiAgICogVG9rZW5pemUgYW4gRW1tZXQtbGlrZSBzaG9ydGNvZGUgc3RyaW5nXG4gICAqL1xuICB0b2tlbml6ZShpbnB1dDogc3RyaW5nKTogVG9rZW5bXSB7XG4gICAgY29uc3QgdG9rZW5zOiBUb2tlbltdID0gW107XG4gICAgbGV0IGN1cnJlbnRQb3MgPSAwO1xuXG4gICAgd2hpbGUgKGN1cnJlbnRQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBpbnB1dFtjdXJyZW50UG9zXTtcblxuICAgICAgLy8gSGFuZGxlIGVsZW1lbnQgbmFtZXMgKGgxLCBwLCBkaXYsIGV0YylcbiAgICAgIGlmICh0aGlzLmlzTmFtZUNoYXIoY2hhcikpIHtcbiAgICAgICAgY29uc3QgeyB0b2tlbiwgbmV3UG9zIH0gPSB0aGlzLnRva2VuaXplRWxlbWVudChpbnB1dCwgY3VycmVudFBvcyk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY3VycmVudFBvcyA9IG5ld1BvcztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBvcGVyYXRvcnMgKD4sICssICopXG4gICAgICBpZiAodGhpcy5pc09wZXJhdG9yKGNoYXIpKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnb3BlcmF0b3InLFxuICAgICAgICAgIHZhbHVlOiBjaGFyXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50UG9zKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgY29udGVudCB3aXRoaW4gY3VybHkgYnJhY2VzIHtjb250ZW50fVxuICAgICAgaWYgKGNoYXIgPT09ICd7Jykge1xuICAgICAgICBjb25zdCB7IHRva2VuLCBuZXdQb3MgfSA9IHRoaXMudG9rZW5pemVDb250ZW50KGlucHV0LCBjdXJyZW50UG9zKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjdXJyZW50UG9zID0gbmV3UG9zO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIGF0dHJpYnV0ZXMgd2l0aGluIHNxdWFyZSBicmFja2V0cyBbYXR0cl1cbiAgICAgIGlmIChjaGFyID09PSAnWycpIHtcbiAgICAgICAgY29uc3QgeyB0b2tlbiwgbmV3UG9zIH0gPSB0aGlzLnRva2VuaXplQXR0cmlidXRlKGlucHV0LCBjdXJyZW50UG9zKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjdXJyZW50UG9zID0gbmV3UG9zO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIGdyb3VwcyB3aXRoIHBhcmVudGhlc2VzIChncm91cClcbiAgICAgIGlmIChjaGFyID09PSAnKCcpIHtcbiAgICAgICAgY29uc3QgeyB0b2tlbiwgbmV3UG9zIH0gPSB0aGlzLnRva2VuaXplR3JvdXAoaW5wdXQsIGN1cnJlbnRQb3MpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGN1cnJlbnRQb3MgPSBuZXdQb3M7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIHdoaXRlc3BhY2VcbiAgICAgIGlmIChjaGFyID09PSAnICcgfHwgY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJ1xcbicpIHtcbiAgICAgICAgY3VycmVudFBvcysrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVW5rbm93biBjaGFyYWN0ZXJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXI6ICR7Y2hhcn0gYXQgcG9zaXRpb24gJHtjdXJyZW50UG9zfWApO1xuICAgIH1cblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBwcml2YXRlIHRva2VuaXplRWxlbWVudChpbnB1dDogc3RyaW5nLCBzdGFydFBvczogbnVtYmVyKTogeyB0b2tlbjogVG9rZW4sIG5ld1BvczogbnVtYmVyIH0ge1xuICAgIGxldCBlbmRQb3MgPSBzdGFydFBvcztcbiAgICB3aGlsZSAoZW5kUG9zIDwgaW5wdXQubGVuZ3RoICYmIHRoaXMuaXNOYW1lQ2hhcihpbnB1dFtlbmRQb3NdKSkge1xuICAgICAgZW5kUG9zKys7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIG11bHRpcGxpZXIgKCpOKVxuICAgIGlmIChlbmRQb3MgPCBpbnB1dC5sZW5ndGggJiYgaW5wdXRbZW5kUG9zXSA9PT0gJyonKSB7XG4gICAgICBjb25zdCBlbGVtZW50TmFtZSA9IGlucHV0LnN1YnN0cmluZyhzdGFydFBvcywgZW5kUG9zKTtcbiAgICAgIGVuZFBvcysrOyAvLyBTa2lwIHRoZSAqXG5cbiAgICAgIC8vIFBhcnNlIHRoZSBudW1iZXJcbiAgICAgIGNvbnN0IG51bWJlclN0YXJ0UG9zID0gZW5kUG9zO1xuICAgICAgd2hpbGUgKGVuZFBvcyA8IGlucHV0Lmxlbmd0aCAmJiAvXFxkLy50ZXN0KGlucHV0W2VuZFBvc10pKSB7XG4gICAgICAgIGVuZFBvcysrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtdWx0aXBsaWVyID0gcGFyc2VJbnQoaW5wdXQuc3Vic3RyaW5nKG51bWJlclN0YXJ0UG9zLCBlbmRQb3MpLCAxMCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiB7XG4gICAgICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuICAgICAgICAgIHZhbHVlOiBlbGVtZW50TmFtZSxcbiAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgIHR5cGU6ICdtdWx0aXBsaWVyJyxcbiAgICAgICAgICAgIHZhbHVlOiBtdWx0aXBsaWVyLnRvU3RyaW5nKClcbiAgICAgICAgICB9XVxuICAgICAgICB9LFxuICAgICAgICBuZXdQb3M6IGVuZFBvc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW46IHtcbiAgICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuICAgICAgICB2YWx1ZTogaW5wdXQuc3Vic3RyaW5nKHN0YXJ0UG9zLCBlbmRQb3MpXG4gICAgICB9LFxuICAgICAgbmV3UG9zOiBlbmRQb3NcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSB0b2tlbml6ZUNvbnRlbnQoaW5wdXQ6IHN0cmluZywgc3RhcnRQb3M6IG51bWJlcik6IHsgdG9rZW46IFRva2VuLCBuZXdQb3M6IG51bWJlciB9IHtcbiAgICBsZXQgZW5kUG9zID0gc3RhcnRQb3MgKyAxOyAvLyBTa2lwIG9wZW5pbmcge1xuICAgIGxldCBkZXB0aCA9IDE7XG5cbiAgICB3aGlsZSAoZW5kUG9zIDwgaW5wdXQubGVuZ3RoICYmIGRlcHRoID4gMCkge1xuICAgICAgaWYgKGlucHV0W2VuZFBvc10gPT09ICd7JykgZGVwdGgrKztcbiAgICAgIGlmIChpbnB1dFtlbmRQb3NdID09PSAnfScpIGRlcHRoLS07XG4gICAgICBlbmRQb3MrKztcbiAgICB9XG5cbiAgICBpZiAoZGVwdGggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgY29udGVudCBicmFjZXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW46IHtcbiAgICAgICAgdHlwZTogJ2NvbnRlbnQnLFxuICAgICAgICB2YWx1ZTogaW5wdXQuc3Vic3RyaW5nKHN0YXJ0UG9zICsgMSwgZW5kUG9zIC0gMSlcbiAgICAgIH0sXG4gICAgICBuZXdQb3M6IGVuZFBvc1xuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHRva2VuaXplQXR0cmlidXRlKGlucHV0OiBzdHJpbmcsIHN0YXJ0UG9zOiBudW1iZXIpOiB7IHRva2VuOiBUb2tlbiwgbmV3UG9zOiBudW1iZXIgfSB7XG4gICAgbGV0IGVuZFBvcyA9IHN0YXJ0UG9zICsgMTsgLy8gU2tpcCBvcGVuaW5nIFtcbiAgICBsZXQgZGVwdGggPSAxO1xuXG4gICAgd2hpbGUgKGVuZFBvcyA8IGlucHV0Lmxlbmd0aCAmJiBkZXB0aCA+IDApIHtcbiAgICAgIGlmIChpbnB1dFtlbmRQb3NdID09PSAnWycpIGRlcHRoKys7XG4gICAgICBpZiAoaW5wdXRbZW5kUG9zXSA9PT0gJ10nKSBkZXB0aC0tO1xuICAgICAgZW5kUG9zKys7XG4gICAgfVxuXG4gICAgaWYgKGRlcHRoICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIGF0dHJpYnV0ZSBicmFja2V0cycpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0b2tlbjoge1xuICAgICAgICB0eXBlOiAnYXR0cmlidXRlJyxcbiAgICAgICAgdmFsdWU6IGlucHV0LnN1YnN0cmluZyhzdGFydFBvcyArIDEsIGVuZFBvcyAtIDEpXG4gICAgICB9LFxuICAgICAgbmV3UG9zOiBlbmRQb3NcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSB0b2tlbml6ZUdyb3VwKGlucHV0OiBzdHJpbmcsIHN0YXJ0UG9zOiBudW1iZXIpOiB7IHRva2VuOiBUb2tlbiwgbmV3UG9zOiBudW1iZXIgfSB7XG4gICAgbGV0IGVuZFBvcyA9IHN0YXJ0UG9zICsgMTsgLy8gU2tpcCBvcGVuaW5nIChcbiAgICBsZXQgZGVwdGggPSAxO1xuXG4gICAgd2hpbGUgKGVuZFBvcyA8IGlucHV0Lmxlbmd0aCAmJiBkZXB0aCA+IDApIHtcbiAgICAgIGlmIChpbnB1dFtlbmRQb3NdID09PSAnKCcpIGRlcHRoKys7XG4gICAgICBpZiAoaW5wdXRbZW5kUG9zXSA9PT0gJyknKSBkZXB0aC0tO1xuICAgICAgZW5kUG9zKys7XG4gICAgfVxuXG4gICAgaWYgKGRlcHRoICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIGdyb3VwIHBhcmVudGhlc2VzJyk7XG4gICAgfVxuXG4gICAgLy8gVG9rZW5pemUgdGhlIGNvbnRlbnRzIG9mIHRoZSBncm91cFxuICAgIGNvbnN0IGdyb3VwQ29udGVudCA9IGlucHV0LnN1YnN0cmluZyhzdGFydFBvcyArIDEsIGVuZFBvcyAtIDEpO1xuICAgIGNvbnN0IGNoaWxkVG9rZW5zID0gbmV3IFRva2VuaXplcigpLnRva2VuaXplKGdyb3VwQ29udGVudCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW46IHtcbiAgICAgICAgdHlwZTogJ2dyb3VwJyxcbiAgICAgICAgdmFsdWU6IGdyb3VwQ29udGVudCxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkVG9rZW5zXG4gICAgICB9LFxuICAgICAgbmV3UG9zOiBlbmRQb3NcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBpc05hbWVDaGFyKGNoYXI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAvW2EtekEtWjAtOV8tXS8udGVzdChjaGFyKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNPcGVyYXRvcihjaGFyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gY2hhciA9PT0gJz4nIHx8IGNoYXIgPT09ICcrJyB8fCBjaGFyID09PSAnKic7XG4gIH1cbn0iLCAiaW1wb3J0IHsgVG9rZW4sIEFTVE5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBQYXJzZXIge1xuICAvKipcbiAgICogUGFyc2UgdG9rZW5zIGludG8gYW4gQWJzdHJhY3QgU3ludGF4IFRyZWVcbiAgICovXG4gIHBhcnNlKHRva2VuczogVG9rZW5bXSk6IEFTVE5vZGVbXSB7XG4gICAgY29uc3QgYXN0OiBBU1ROb2RlW10gPSBbXTtcbiAgICBsZXQgY3VycmVudE5vZGU6IEFTVE5vZGUgfCBudWxsID0gbnVsbDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2VsZW1lbnQnOlxuICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBlbGVtZW50IG5vZGVcbiAgICAgICAgICBjdXJyZW50Tm9kZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdlbGVtZW50JyxcbiAgICAgICAgICAgIG5hbWU6IHRva2VuLnZhbHVlLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIENoZWNrIGZvciBtdWx0aXBsaWVyXG4gICAgICAgICAgaWYgKHRva2VuLmNoaWxkcmVuICYmIHRva2VuLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSB0b2tlbi5jaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLnR5cGUgPT09ICdtdWx0aXBsaWVyJyk7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGllcikge1xuICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5yZXBlYXQgPSBwYXJzZUludChtdWx0aXBsaWVyLnZhbHVlLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXN0LnB1c2goY3VycmVudE5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NvbnRlbnQnOlxuICAgICAgICAgIC8vIEFkZCBjb250ZW50IHRvIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgICAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmNvbnRlbnQgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYXR0cmlidXRlJzpcbiAgICAgICAgICAvLyBQYXJzZSBhdHRyaWJ1dGVzIGFuZCBhZGQgdG8gY3VycmVudCBub2RlXG4gICAgICAgICAgaWYgKGN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5hdHRyaWJ1dGVzID0gdGhpcy5wYXJzZUF0dHJpYnV0ZXModG9rZW4udmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvcGVyYXRvcic6XG4gICAgICAgICAgLy8gSGFuZGxlIG9wZXJhdG9yc1xuICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJz4nICYmIGkgKyAxIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gQ2hpbGQgb3BlcmF0b3IgLSBwcm9jZXNzIHRoZSBuZXh0IHRva2VuIGFzIGEgY2hpbGQgb2YgY3VycmVudFxuICAgICAgICAgICAgY29uc3QgY2hpbGRUb2tlbnMgPSBbdG9rZW5zWysraV1dO1xuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMucGFyc2UoY2hpbGRUb2tlbnMpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuID0gY3VycmVudE5vZGUuY2hpbGRyZW4gfHwgW107XG4gICAgICAgICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuLnB1c2goLi4uY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICAgIC8vIFNldCBwYXJlbnQgcmVmZXJlbmNlXG4gICAgICAgICAgICAgIGNoaWxkTm9kZXMuZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5wYXJlbnQgPSBjdXJyZW50Tm9kZSEubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJysnKSB7XG4gICAgICAgICAgICAvLyBTaWJsaW5nIG9wZXJhdG9yIC0ganVzdCBjb250aW51ZSB0byBuZXh0IHRva2VuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZ3JvdXAnOlxuICAgICAgICAgIC8vIFByb2Nlc3MgZ3JvdXAgYXMgYSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzXG4gICAgICAgICAgaWYgKHRva2VuLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBncm91cE5vZGVzID0gdGhpcy5wYXJzZSh0b2tlbi5jaGlsZHJlbik7XG4gICAgICAgICAgICBhc3QucHVzaCguLi5ncm91cE5vZGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzdDtcbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VBdHRyaWJ1dGVzKGF0dHJTdHJpbmc6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICAgIC8vIFNpbXBsZSBhdHRyaWJ1dGUgcGFyc2luZyAtIGNhbiBiZSBlbmhhbmNlZCBmb3IgbW9yZSBjb21wbGV4IGNhc2VzXG4gICAgaWYgKGF0dHJTdHJpbmcuaW5jbHVkZXMoJz0nKSkge1xuICAgICAgLy8gRm9ybWF0OiBhdHRyMT12YWx1ZTEgYXR0cjI9dmFsdWUyXG4gICAgICBjb25zdCBwYWlycyA9IGF0dHJTdHJpbmcuc3BsaXQoL1xccysvKTtcbiAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBwYWlyLnNwbGl0KCc9Jyk7XG4gICAgICAgIGlmIChrZXkgJiYgdmFsdWUpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZS5yZXBsYWNlKC9bXCInXS9nLCAnJyk7IC8vIFJlbW92ZSBxdW90ZXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTaW5nbGUgdmFsdWUgYXR0cmlidXRlXG4gICAgICBhdHRyaWJ1dGVzLnZhbHVlID0gYXR0clN0cmluZztcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgQVNUIHN0cnVjdHVyZVxuICAgKi9cbiAgdmFsaWRhdGUoYXN0OiBBU1ROb2RlW10pOiBib29sZWFuIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgYXN0KSB7XG4gICAgICBpZiAoIW5vZGUubmFtZSAmJiBub2RlLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGUobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSIsICJcbmltcG9ydCB7IEFTVE5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtZXIge1xuICB0cmFuc2Zvcm0oYXN0OiBBU1ROb2RlW10pOiBzdHJpbmcge1xuICAgIHJldHVybiBhc3QubWFwKG5vZGUgPT4gbm9kZS5jb250ZW50IHx8ICcnKS5qb2luKCdcXG4nKTtcbiAgfVxufVxuIiwgIlxuaW1wb3J0IExpbmtQbHVnaW4gZnJvbSAnLi4vbWFpbic7XG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBUb2tlbml6ZXIgfSBmcm9tICcuL3Rva2VuaXplcic7XG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tICcuL3BhcnNlcic7XG5pbXBvcnQgeyBUcmFuc2Zvcm1lciB9IGZyb20gJy4vdHJhbnNmb3JtZXInO1xuXG5leHBvcnQgY2xhc3MgU2hvcnRjb2RlTWFuYWdlciB7XG4gIHBsdWdpbjogTGlua1BsdWdpbjtcbiAgdG9rZW5pemVyOiBUb2tlbml6ZXI7XG4gIHBhcnNlcjogUGFyc2VyO1xuICB0cmFuc2Zvcm1lcjogVHJhbnNmb3JtZXI7XG4gIGNvbnN0cnVjdG9yKHBsdWdpbjogTGlua1BsdWdpbikge1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIHRoaXMudG9rZW5pemVyID0gbmV3IFRva2VuaXplcigpO1xuICAgIHRoaXMucGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgIHRoaXMudHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtZXIoKTtcbiAgfVxuXG4gIGNoZWNrRm9yU2hvcnRjb2RlcyhlZGl0b3I6IEVkaXRvcik6IHZvaWQge1xuICAgIC8vIEltcGxlbWVudGF0aW9uIHBsYWNlaG9sZGVyXG4gIH1cblxuICBzaG93SGVscE1vZGFsKCk6IHZvaWQge1xuICAgIC8vIEltcGxlbWVudGF0aW9uIHBsYWNlaG9sZGVyXG4gIH1cbn1cbiIsICJcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBMaW5rUGx1Z2luIGZyb20gJy4uL21haW4nO1xuXG5leHBvcnQgY2xhc3MgRXJyb3JIYW5kbGVyIHtcbiAgcGx1Z2luOiBMaW5rUGx1Z2luO1xuICBcbiAgY29uc3RydWN0b3IocGx1Z2luOiBMaW5rUGx1Z2luKSB7IFxuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luOyBcbiAgfVxuICBcbiAgaGFuZGxlRXJyb3IoZXJyb3I6IGFueSwgY29udGV4dDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICBjb25zb2xlLmVycm9yKGAke2NvbnRleHR9OiAke21lc3NhZ2V9YCk7XG4gICAgbmV3IE5vdGljZShgJHtjb250ZXh0fTogJHttZXNzYWdlfWApO1xuICB9XG5cbiAgc2hvd05vdGljZShtZXNzYWdlOiBzdHJpbmcsIGR1cmF0aW9uPzogbnVtYmVyKTogdm9pZCB7XG4gICAgbmV3IE5vdGljZShtZXNzYWdlLCBkdXJhdGlvbik7XG4gIH1cblxuICBzaG93U3VjY2VzcyhtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBuZXcgTm90aWNlKG1lc3NhZ2UsIDMwMDApO1xuICB9XG5cbiAgc2hvd1dhcm5pbmcobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgbmV3IE5vdGljZShgXHUyNkEwXHVGRTBGICR7bWVzc2FnZX1gLCA1MDAwKTtcbiAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLG1CQUF1Qjs7O0FDQ2hCLElBQU0sc0JBQXNCO0FBRzVCLElBQU0sc0JBQXNCO0FBQUEsRUFDakM7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDRjtBQXdDTyxJQUFNLHVCQUF1QjtBQUFBLEVBQ2xDO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDRjtBQUVPLElBQU0sY0FBYztBQUFBLEVBQ3pCLG9CQUFvQjtBQUFBLEVBQ3BCLG1CQUFtQjtBQUFBLEVBQ25CLG9CQUFvQjtBQUFBLEVBQ3BCLG1CQUFtQjtBQUFBLEVBQ25CLG9CQUFvQjtBQUFBLEVBQ3BCLHdCQUF3QjtBQUFBLEVBQ3hCLGtCQUFrQjtBQUFBLEVBQ2xCLHVCQUF1QjtBQUN6QjtBQUVPLElBQU0sZUFBZTtBQUFBLEVBQzFCLGlCQUFpQjtBQUFBLEVBQ2pCLFVBQVU7QUFBQSxFQUNWLGVBQWU7QUFDakI7QUFvQk8sSUFBTSxvQkFBb0I7QUFBQSxFQUMvQixTQUFTO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtB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QUNwQixZQUFJO0FBRUYsZ0JBQU0sY0FBZSxPQUFlLE9BQU8sRUFBRSxRQUFRLE1BQU07QUFDM0QsZ0JBQU0sWUFBYSxPQUFlLE9BQU8sRUFBRSxNQUFNLE1BQU07QUFFdkQsZ0JBQU0sS0FBSyxlQUFlLDZCQUE2QixhQUFhLFNBQVM7QUFFN0UsZUFBSyxhQUFhLFdBQVcsMENBQTBDO0FBQUEsUUFDekUsU0FBUyxPQUFQO0FBQ0EsZUFBSyxhQUFhLFlBQVksT0FBTyxrQ0FBa0M7QUFBQSxRQUN6RTtBQUFBLE1BQ0Y7QUFBQSxJQUNGLENBQUM7QUFHRCxTQUFLLFdBQVc7QUFBQSxNQUNkLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFVBQVUsTUFBTTtBQUNkLFlBQUk7QUFDRixlQUFLLGlCQUFpQixjQUFjO0FBQUEsUUFDdEMsU0FBUyxPQUFQO0FBQ0EsZUFBSyxhQUFhLFlBQVksT0FBTywrQkFBK0I7QUFBQSxRQUN0RTtBQUFBLE1BQ0Y7QUFBQSxJQUNGLENBQUM7QUFBQSxFQUNIO0FBQUEsRUFFQSx3QkFBd0I7QUFFdEIsU0FBSztBQUFBLE1BQ0gsS0FBSyxJQUFJLFVBQVUsR0FBRyxpQkFBaUIsQ0FBQyxXQUFXO0FBQ2pELFlBQUksS0FBSyxTQUFTLGtCQUFrQjtBQUNsQyxlQUFLLGlCQUFpQixtQkFBbUIsTUFBTTtBQUFBLFFBQ2pEO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDSDtBQUdBLFNBQUs7QUFBQSxNQUNILEtBQUssSUFBSSxNQUFNLEdBQUcsVUFBVSxDQUFDLFNBQVM7QUFDcEMsWUFBSSxLQUFLLEtBQUssU0FBUyxLQUFLLFNBQVMsaUJBQWlCLEdBQUc7QUFDdkQsZUFBSyxlQUFlLG1CQUFtQixJQUFJO0FBQUEsUUFDN0M7QUFBQSxNQUNGLENBQUM7QUFBQSxJQUNIO0FBR0EsU0FBSztBQUFBLE1BQ0gsS0FBSyxJQUFJLE1BQU0sR0FBRyxVQUFVLENBQUMsU0FBUztBQUVwQyxZQUFJLEtBQUssU0FBUyxXQUFXO0FBQzNCLGtCQUFRLElBQUksa0JBQWtCLEtBQUssSUFBSTtBQUFBLFFBQ3pDO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDSDtBQUFBLEVBQ0Y7QUFBQSxFQUVBLFdBQVc7QUFDVCxZQUFRLElBQUksc0JBQXNCO0FBQUEsRUFDcEM7QUFDRjsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIl0KfQo=
